
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';


/**
 * Model Account
 */

export type Account = {
  id: number
  compoundId: string
  userId: number
  providerType: string
  providerId: string
  providerAccountId: string
  refreshToken: string | null
  accessToken: string | null
  accessTokenExpires: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Reward
 */

export type Reward = {
  id: number
  placement: number
  tournamentId: string
  points: number
}

/**
 * Model Session
 */

export type Session = {
  id: number
  userId: number
  expires: Date
  sessionToken: string
  accessToken: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 */

export type User = {
  id: number
  name: string | null
  email: string | null
  emailVerified: Date | null
  image: string | null
  createdAt: Date
  updatedAt: Date
  tournamentApplicationId: number | null
  tournamentParticipationTeamId: string | null
  tournamentParticipationTournamentId: string | null
  tournamentMatchStateId: number | null
}

/**
 * Model VerificationRequest
 */

export type VerificationRequest = {
  id: number
  identifier: string
  token: string
  expires: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Tournament
 */

export type Tournament = {
  id: string
  name: string
  closed: boolean
  started: boolean
  groupSize: number
  teamSize: number
  rounds: number
  startsAt: Date
  registrationClosesAt: Date
  imageId: number | null
  teamId: string
  gameId: string
}

/**
 * Model Admin
 */

export type Admin = {
  userId: number
}

/**
 * Model News
 */

export type News = {
  id: number
  title: string
  content: Prisma.JsonValue
  createdAt: Date
  userId: number
  imageId: number | null
}

/**
 * Model TournamentApplication
 */

export type TournamentApplication = {
  id: number
  createdAt: Date
  tournamentId: string
  teamId: string
}

/**
 * Model TournamentGridElement
 */

export type TournamentGridElement = {
  id: number
  round: number
  group: number
  tournamentId: string
  matchId: number | null
  teamId: string
}

/**
 * Model TournamentParticipation
 */

export type TournamentParticipation = {
  placement: number | null
  matchId: number | null
  tournamentId: string
  teamId: string
}

/**
 * Model TeamMembership
 */

export type TeamMembership = {
  role: TeamRoleType
  invitedAt: Date
  joinedAt: Date
  userId: number
  teamId: string
}

/**
 * Model TeamInvitation
 */

export type TeamInvitation = {
  invitedAt: Date
  userId: number
  teamId: string
}

/**
 * Model TournamentMatchState
 */

export type TournamentMatchState = {
  id: number
  state: Prisma.JsonValue
  createdAt: Date
  accepted: boolean
  matchId: number
}

/**
 * Model Team
 */

export type Team = {
  id: string
  name: string
  updatedAt: Date
  createdAt: Date
  imageId: number | null
}

/**
 * Model TournamentMatch
 */

export type TournamentMatch = {
  id: number
  joinUntil: Date | null
  createRoomUntil: Date
  state: MatchStateType
  roomCodeId: number
  tournamentId: string
}

/**
 * Model TournamentMatchReport
 */

export type TournamentMatchReport = {
  type: ReportType
  description: string
  matchId: number
  reporterId: number
}

/**
 * Model Notification
 */

export type Notification = {
  id: number
  type: NotificationType | null
  title: string
  description: string
  createdAt: Date
  read: boolean
  userId: number
}

/**
 * Model RoomCode
 */

export type RoomCode = {
  id: number
  name: string
  password: string | null
  gameId: string
}

/**
 * Model Image
 */

export type Image = {
  id: number
  path: string
  width: number
  height: number
  caption: string | null
  tournamentMatchReportMatchId: number | null
  tournamentMatchReportReporterId: number | null
}

/**
 * Model Game
 */

export type Game = {
  id: string
  name: string
}

/**
 * Model GameAccount
 */

export type GameAccount = {
  id: string
  gameId: string
  userId: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const TeamRoleType: {
  OWNER: 'OWNER',
  PLAYER: 'PLAYER'
};

export type TeamRoleType = (typeof TeamRoleType)[keyof typeof TeamRoleType]


export const MatchStateType: {
  WAITING_FOR_ROOM_CREATION: 'WAITING_FOR_ROOM_CREATION',
  ONGOING: 'ONGOING',
  FINISHED: 'FINISHED',
  REPORTED: 'REPORTED'
};

export type MatchStateType = (typeof MatchStateType)[keyof typeof MatchStateType]


export const ReportType: {
  STARTED_BEFORE_EVERYONE_JOINED: 'STARTED_BEFORE_EVERYONE_JOINED',
  DIDNT_JOIN: 'DIDNT_JOIN',
  LEFT_BEFORE_GAME_FINISHED: 'LEFT_BEFORE_GAME_FINISHED',
  INVALID_PLAYER_JOINED: 'INVALID_PLAYER_JOINED',
  ROOM_CODE_NOT_WORKING: 'ROOM_CODE_NOT_WORKING'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const NotificationType: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  SUCCESS: 'SUCCESS'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate;

  /**
   * `prisma.verificationRequest`: Exposes CRUD operations for the **VerificationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationRequests
    * const verificationRequests = await prisma.verificationRequest.findMany()
    * ```
    */
  get verificationRequest(): Prisma.VerificationRequestDelegate;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **Tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.TournamentDelegate;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate;

  /**
   * `prisma.tournamentApplication`: Exposes CRUD operations for the **TournamentApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentApplications
    * const tournamentApplications = await prisma.tournamentApplication.findMany()
    * ```
    */
  get tournamentApplication(): Prisma.TournamentApplicationDelegate;

  /**
   * `prisma.tournamentGridElement`: Exposes CRUD operations for the **TournamentGridElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentGridElements
    * const tournamentGridElements = await prisma.tournamentGridElement.findMany()
    * ```
    */
  get tournamentGridElement(): Prisma.TournamentGridElementDelegate;

  /**
   * `prisma.tournamentParticipation`: Exposes CRUD operations for the **TournamentParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentParticipations
    * const tournamentParticipations = await prisma.tournamentParticipation.findMany()
    * ```
    */
  get tournamentParticipation(): Prisma.TournamentParticipationDelegate;

  /**
   * `prisma.teamMembership`: Exposes CRUD operations for the **TeamMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMemberships
    * const teamMemberships = await prisma.teamMembership.findMany()
    * ```
    */
  get teamMembership(): Prisma.TeamMembershipDelegate;

  /**
   * `prisma.teamInvitation`: Exposes CRUD operations for the **TeamInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamInvitations
    * const teamInvitations = await prisma.teamInvitation.findMany()
    * ```
    */
  get teamInvitation(): Prisma.TeamInvitationDelegate;

  /**
   * `prisma.tournamentMatchState`: Exposes CRUD operations for the **TournamentMatchState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentMatchStates
    * const tournamentMatchStates = await prisma.tournamentMatchState.findMany()
    * ```
    */
  get tournamentMatchState(): Prisma.TournamentMatchStateDelegate;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate;

  /**
   * `prisma.tournamentMatch`: Exposes CRUD operations for the **TournamentMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentMatches
    * const tournamentMatches = await prisma.tournamentMatch.findMany()
    * ```
    */
  get tournamentMatch(): Prisma.TournamentMatchDelegate;

  /**
   * `prisma.tournamentMatchReport`: Exposes CRUD operations for the **TournamentMatchReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentMatchReports
    * const tournamentMatchReports = await prisma.tournamentMatchReport.findMany()
    * ```
    */
  get tournamentMatchReport(): Prisma.TournamentMatchReportDelegate;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate;

  /**
   * `prisma.roomCode`: Exposes CRUD operations for the **RoomCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomCodes
    * const roomCodes = await prisma.roomCode.findMany()
    * ```
    */
  get roomCode(): Prisma.RoomCodeDelegate;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate;

  /**
   * `prisma.gameAccount`: Exposes CRUD operations for the **GameAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameAccounts
    * const gameAccounts = await prisma.gameAccount.findMany()
    * ```
    */
  get gameAccount(): Prisma.GameAccountDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.15.0
   * Query Engine version: e51dc3b5a9ee790a07104bec1c9477d51740fe54
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    Reward: 'Reward',
    Session: 'Session',
    User: 'User',
    VerificationRequest: 'VerificationRequest',
    Tournament: 'Tournament',
    Admin: 'Admin',
    News: 'News',
    TournamentApplication: 'TournamentApplication',
    TournamentGridElement: 'TournamentGridElement',
    TournamentParticipation: 'TournamentParticipation',
    TeamMembership: 'TeamMembership',
    TeamInvitation: 'TeamInvitation',
    TournamentMatchState: 'TournamentMatchState',
    Team: 'Team',
    TournamentMatch: 'TournamentMatch',
    TournamentMatchReport: 'TournamentMatchReport',
    Notification: 'Notification',
    RoomCode: 'RoomCode',
    Image: 'Image',
    Game: 'Game',
    GameAccount: 'GameAccount'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Account
   */


  export type AggregateAccount = {
    count: AccountCountAggregateOutputType | null
    avg: AccountAvgAggregateOutputType | null
    sum: AccountSumAggregateOutputType | null
    min: AccountMinAggregateOutputType | null
    max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type AccountSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type AccountMinAggregateOutputType = {
    id: number
    compoundId: string | null
    userId: number
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number
    compoundId: string | null
    userId: number
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    accessTokenExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    compoundId: number | null
    userId: number
    providerType: number | null
    providerId: number | null
    providerAccountId: number | null
    refreshToken: number | null
    accessToken: number | null
    accessTokenExpires: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    compoundId?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    compoundId?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    compoundId?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    accessTokenExpires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
    **/
    where?: AccountWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Accounts to fetch.
    **/
    orderBy?: Enumerable<AccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }



  export type AccountSelect = {
    id?: boolean
    compoundId?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    accessTokenExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Account ?Account [P]
  : 
     never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account | null>, Prisma__AccountClient<AccountGetPayload<T> | null>>

    /**
     * Find the first Account that matches the filter.
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account | null>, Prisma__AccountClient<AccountGetPayload<T> | null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, Promise<Array<Account>>, Promise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Promise<GetAccountAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * Throw an Error if a Account can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Account to fetch.
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * Throw an Error if a Account can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Account to fetch.
    **/
    where?: AccountWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Accounts to fetch.
    **/
    orderBy?: Enumerable<AccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Accounts.
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * Filter, which Accounts to fetch.
    **/
    where?: AccountWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Accounts to fetch.
    **/
    orderBy?: Enumerable<AccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * The data needed to create a Account.
    **/
    data: XOR<AccountUncheckedCreateInput, AccountCreateInput>
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * The data needed to update a Account.
    **/
    data: XOR<AccountUncheckedUpdateInput, AccountUpdateInput>
    /**
     * Choose, which Account to update.
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    data: XOR<AccountUncheckedUpdateManyInput, AccountUpdateManyMutationInput>
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * The filter to search for the Account to update in case it exists.
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
    **/
    create: XOR<AccountUncheckedCreateInput, AccountCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AccountUncheckedUpdateInput, AccountUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
    /**
     * Filter which Account to delete.
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
    **/
    select?: AccountSelect | null
  }



  /**
   * Model Reward
   */


  export type AggregateReward = {
    count: RewardCountAggregateOutputType | null
    avg: RewardAvgAggregateOutputType | null
    sum: RewardSumAggregateOutputType | null
    min: RewardMinAggregateOutputType | null
    max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    id: number
    placement: number
    points: number
  }

  export type RewardSumAggregateOutputType = {
    id: number
    placement: number
    points: number
  }

  export type RewardMinAggregateOutputType = {
    id: number
    placement: number
    tournamentId: string | null
    points: number
  }

  export type RewardMaxAggregateOutputType = {
    id: number
    placement: number
    tournamentId: string | null
    points: number
  }

  export type RewardCountAggregateOutputType = {
    id: number
    placement: number
    tournamentId: number | null
    points: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    id?: true
    placement?: true
    points?: true
  }

  export type RewardSumAggregateInputType = {
    id?: true
    placement?: true
    points?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    placement?: true
    tournamentId?: true
    points?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    placement?: true
    tournamentId?: true
    points?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    placement?: true
    tournamentId?: true
    points?: true
    _all?: true
  }

  export type RewardAggregateArgs = {
    /**
     * Filter which Reward to aggregate.
    **/
    where?: RewardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Rewards to fetch.
    **/
    orderBy?: Enumerable<RewardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
    [P in keyof T & keyof AggregateReward]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }



  export type RewardSelect = {
    id?: boolean
    placement?: boolean
    tournamentId?: boolean
    tournament?: boolean | TournamentArgs
    points?: boolean
  }

  export type RewardInclude = {
    tournament?: boolean | TournamentArgs
  }

  export type RewardGetPayload<
    S extends boolean | null | undefined | RewardArgs,
    U = keyof S
      > = S extends true
        ? Reward
    : S extends undefined
    ? never
    : S extends RewardArgs | RewardFindManyArgs
    ?'include' extends U
    ? Reward  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tournament'
        ? TournamentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Reward ?Reward [P]
  : 
          P extends 'tournament'
        ? TournamentGetPayload<S['select'][P]> : never
  } 
    : Reward
  : Reward


  type RewardCountArgs = Merge<
    Omit<RewardFindManyArgs, 'select' | 'include'> & {
      select?: RewardCountAggregateInputType | true
    }
  >

  export interface RewardDelegate {
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RewardFindUniqueArgs>(
      args: SelectSubset<T, RewardFindUniqueArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward | null>, Prisma__RewardClient<RewardGetPayload<T> | null>>

    /**
     * Find the first Reward that matches the filter.
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RewardFindFirstArgs>(
      args?: SelectSubset<T, RewardFindFirstArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward | null>, Prisma__RewardClient<RewardGetPayload<T> | null>>

    /**
     * Find zero or more Rewards that matches the filter.
     * @param {RewardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RewardFindManyArgs>(
      args?: SelectSubset<T, RewardFindManyArgs>
    ): CheckSelect<T, Promise<Array<Reward>>, Promise<Array<RewardGetPayload<T>>>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
    **/
    create<T extends RewardCreateArgs>(
      args: SelectSubset<T, RewardCreateArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
    **/
    delete<T extends RewardDeleteArgs>(
      args: SelectSubset<T, RewardDeleteArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RewardUpdateArgs>(
      args: SelectSubset<T, RewardUpdateArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RewardDeleteManyArgs>(
      args?: SelectSubset<T, RewardDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RewardUpdateManyArgs>(
      args: SelectSubset<T, RewardUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
    **/
    upsert<T extends RewardUpsertArgs>(
      args: SelectSubset<T, RewardUpsertArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Count the number of Rewards.
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Promise<GetRewardAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RewardClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tournament<T extends TournamentArgs = {}>(args?: Subset<T, TournamentArgs>): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Reward findUnique
   */
  export type RewardFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * Throw an Error if a Reward can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Reward to fetch.
    **/
    where: RewardWhereUniqueInput
  }


  /**
   * Reward findFirst
   */
  export type RewardFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * Throw an Error if a Reward can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Reward to fetch.
    **/
    where?: RewardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Rewards to fetch.
    **/
    orderBy?: Enumerable<RewardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
    **/
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Rewards.
    **/
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward findMany
   */
  export type RewardFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * Filter, which Rewards to fetch.
    **/
    where?: RewardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Rewards to fetch.
    **/
    orderBy?: Enumerable<RewardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
    **/
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
    **/
    skip?: number
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward create
   */
  export type RewardCreateArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * The data needed to create a Reward.
    **/
    data: XOR<RewardUncheckedCreateInput, RewardCreateInput>
  }


  /**
   * Reward update
   */
  export type RewardUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * The data needed to update a Reward.
    **/
    data: XOR<RewardUncheckedUpdateInput, RewardUpdateInput>
    /**
     * Choose, which Reward to update.
    **/
    where: RewardWhereUniqueInput
  }


  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs = {
    data: XOR<RewardUncheckedUpdateManyInput, RewardUpdateManyMutationInput>
    where?: RewardWhereInput
  }


  /**
   * Reward upsert
   */
  export type RewardUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * The filter to search for the Reward to update in case it exists.
    **/
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
    **/
    create: XOR<RewardUncheckedCreateInput, RewardCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RewardUncheckedUpdateInput, RewardUpdateInput>
  }


  /**
   * Reward delete
   */
  export type RewardDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
    /**
     * Filter which Reward to delete.
    **/
    where: RewardWhereUniqueInput
  }


  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs = {
    where?: RewardWhereInput
  }


  /**
   * Reward without action
   */
  export type RewardArgs = {
    /**
     * Select specific fields to fetch from the Reward
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RewardInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    count: SessionCountAggregateOutputType | null
    avg: SessionAvgAggregateOutputType | null
    sum: SessionSumAggregateOutputType | null
    min: SessionMinAggregateOutputType | null
    max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type SessionSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type SessionMinAggregateOutputType = {
    id: number
    userId: number
    expires: Date | null
    sessionToken: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number
    userId: number
    expires: Date | null
    sessionToken: string | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    expires: number | null
    sessionToken: number | null
    accessToken: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    expires?: true
    sessionToken?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
    **/
    where?: SessionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Sessions to fetch.
    **/
    orderBy?: Enumerable<SessionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }



  export type SessionSelect = {
    id?: boolean
    userId?: boolean
    expires?: boolean
    sessionToken?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Session ?Session [P]
  : 
     never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session | null>, Prisma__SessionClient<SessionGetPayload<T> | null>>

    /**
     * Find the first Session that matches the filter.
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session | null>, Prisma__SessionClient<SessionGetPayload<T> | null>>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, Promise<Array<Session>>, Promise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Promise<GetSessionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * Throw an Error if a Session can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * Throw an Error if a Session can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
    **/
    where?: SessionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Sessions to fetch.
    **/
    orderBy?: Enumerable<SessionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Sessions.
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * Filter, which Sessions to fetch.
    **/
    where?: SessionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Sessions to fetch.
    **/
    orderBy?: Enumerable<SessionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * The data needed to create a Session.
    **/
    data: XOR<SessionUncheckedCreateInput, SessionCreateInput>
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * The data needed to update a Session.
    **/
    data: XOR<SessionUncheckedUpdateInput, SessionUpdateInput>
    /**
     * Choose, which Session to update.
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    data: XOR<SessionUncheckedUpdateManyInput, SessionUpdateManyMutationInput>
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * The filter to search for the Session to update in case it exists.
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
    **/
    create: XOR<SessionUncheckedCreateInput, SessionCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SessionUncheckedUpdateInput, SessionUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
    /**
     * Filter which Session to delete.
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
    **/
    select?: SessionSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number
    tournamentApplicationId: number | null
    tournamentMatchStateId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number
    tournamentApplicationId: number | null
    tournamentMatchStateId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tournamentApplicationId: number | null
    tournamentParticipationTeamId: string | null
    tournamentParticipationTournamentId: string | null
    tournamentMatchStateId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tournamentApplicationId: number | null
    tournamentParticipationTeamId: string | null
    tournamentParticipationTournamentId: string | null
    tournamentMatchStateId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number | null
    email: number | null
    emailVerified: number | null
    image: number | null
    createdAt: number | null
    updatedAt: number | null
    tournamentApplicationId: number | null
    tournamentParticipationTeamId: number | null
    tournamentParticipationTournamentId: number | null
    tournamentMatchStateId: number | null
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    tournamentApplicationId?: true
    tournamentMatchStateId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    tournamentApplicationId?: true
    tournamentMatchStateId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    tournamentApplicationId?: true
    tournamentParticipationTeamId?: true
    tournamentParticipationTournamentId?: true
    tournamentMatchStateId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    tournamentApplicationId?: true
    tournamentParticipationTeamId?: true
    tournamentParticipationTournamentId?: true
    tournamentMatchStateId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    tournamentApplicationId?: true
    tournamentParticipationTeamId?: true
    tournamentParticipationTournamentId?: true
    tournamentMatchStateId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }



  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | TeamMembershipFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    gameAccounts?: boolean | GameAccountFindManyArgs
    Admin?: boolean | AdminFindManyArgs
    News?: boolean | NewsFindManyArgs
    TournamentApplication?: boolean | TournamentApplicationArgs
    tournamentApplicationId?: boolean
    TournamentParticipation?: boolean | TournamentParticipationArgs
    tournamentParticipationTeamId?: boolean
    tournamentParticipationTournamentId?: boolean
    TeamInvitation?: boolean | TeamInvitationFindManyArgs
    TournamentMatchState?: boolean | TournamentMatchStateArgs
    tournamentMatchStateId?: boolean
    TournamentMatchReport?: boolean | TournamentMatchReportFindManyArgs
  }

  export type UserInclude = {
    memberships?: boolean | TeamMembershipFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    gameAccounts?: boolean | GameAccountFindManyArgs
    Admin?: boolean | AdminFindManyArgs
    News?: boolean | NewsFindManyArgs
    TournamentApplication?: boolean | TournamentApplicationArgs
    TournamentParticipation?: boolean | TournamentParticipationArgs
    TeamInvitation?: boolean | TeamInvitationFindManyArgs
    TournamentMatchState?: boolean | TournamentMatchStateArgs
    TournamentMatchReport?: boolean | TournamentMatchReportFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'memberships'
        ? Array < TeamMembershipGetPayload<S['include'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'gameAccounts'
        ? Array < GameAccountGetPayload<S['include'][P]>>  :
        P extends 'Admin'
        ? Array < AdminGetPayload<S['include'][P]>>  :
        P extends 'News'
        ? Array < NewsGetPayload<S['include'][P]>>  :
        P extends 'TournamentApplication'
        ? TournamentApplicationGetPayload<S['include'][P]> | null :
        P extends 'TournamentParticipation'
        ? TournamentParticipationGetPayload<S['include'][P]> | null :
        P extends 'TeamInvitation'
        ? Array < TeamInvitationGetPayload<S['include'][P]>>  :
        P extends 'TournamentMatchState'
        ? TournamentMatchStateGetPayload<S['include'][P]> | null :
        P extends 'TournamentMatchReport'
        ? Array < TournamentMatchReportGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'memberships'
        ? Array < TeamMembershipGetPayload<S['select'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'gameAccounts'
        ? Array < GameAccountGetPayload<S['select'][P]>>  :
        P extends 'Admin'
        ? Array < AdminGetPayload<S['select'][P]>>  :
        P extends 'News'
        ? Array < NewsGetPayload<S['select'][P]>>  :
        P extends 'TournamentApplication'
        ? TournamentApplicationGetPayload<S['select'][P]> | null :
        P extends 'TournamentParticipation'
        ? TournamentParticipationGetPayload<S['select'][P]> | null :
        P extends 'TeamInvitation'
        ? Array < TeamInvitationGetPayload<S['select'][P]>>  :
        P extends 'TournamentMatchState'
        ? TournamentMatchStateGetPayload<S['select'][P]> | null :
        P extends 'TournamentMatchReport'
        ? Array < TournamentMatchReportGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>

    /**
     * Find the first User that matches the filter.
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Users.
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Promise<GetUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    memberships<T extends TeamMembershipFindManyArgs = {}>(args?: Subset<T, TeamMembershipFindManyArgs>): CheckSelect<T, Promise<Array<TeamMembership>>, Promise<Array<TeamMembershipGetPayload<T>>>>;

    notifications<T extends NotificationFindManyArgs = {}>(args?: Subset<T, NotificationFindManyArgs>): CheckSelect<T, Promise<Array<Notification>>, Promise<Array<NotificationGetPayload<T>>>>;

    gameAccounts<T extends GameAccountFindManyArgs = {}>(args?: Subset<T, GameAccountFindManyArgs>): CheckSelect<T, Promise<Array<GameAccount>>, Promise<Array<GameAccountGetPayload<T>>>>;

    Admin<T extends AdminFindManyArgs = {}>(args?: Subset<T, AdminFindManyArgs>): CheckSelect<T, Promise<Array<Admin>>, Promise<Array<AdminGetPayload<T>>>>;

    News<T extends NewsFindManyArgs = {}>(args?: Subset<T, NewsFindManyArgs>): CheckSelect<T, Promise<Array<News>>, Promise<Array<NewsGetPayload<T>>>>;

    TournamentApplication<T extends TournamentApplicationArgs = {}>(args?: Subset<T, TournamentApplicationArgs>): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication | null>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T> | null>>;

    TournamentParticipation<T extends TournamentParticipationArgs = {}>(args?: Subset<T, TournamentParticipationArgs>): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation | null>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T> | null>>;

    TeamInvitation<T extends TeamInvitationFindManyArgs = {}>(args?: Subset<T, TeamInvitationFindManyArgs>): CheckSelect<T, Promise<Array<TeamInvitation>>, Promise<Array<TeamInvitationGetPayload<T>>>>;

    TournamentMatchState<T extends TournamentMatchStateArgs = {}>(args?: Subset<T, TournamentMatchStateArgs>): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState | null>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T> | null>>;

    TournamentMatchReport<T extends TournamentMatchReportFindManyArgs = {}>(args?: Subset<T, TournamentMatchReportFindManyArgs>): CheckSelect<T, Promise<Array<TournamentMatchReport>>, Promise<Array<TournamentMatchReportGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserUncheckedCreateInput, UserCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUncheckedUpdateInput, UserUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUncheckedUpdateManyInput, UserUpdateManyMutationInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserUncheckedCreateInput, UserCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUncheckedUpdateInput, UserUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model VerificationRequest
   */


  export type AggregateVerificationRequest = {
    count: VerificationRequestCountAggregateOutputType | null
    avg: VerificationRequestAvgAggregateOutputType | null
    sum: VerificationRequestSumAggregateOutputType | null
    min: VerificationRequestMinAggregateOutputType | null
    max: VerificationRequestMaxAggregateOutputType | null
  }

  export type VerificationRequestAvgAggregateOutputType = {
    id: number
  }

  export type VerificationRequestSumAggregateOutputType = {
    id: number
  }

  export type VerificationRequestMinAggregateOutputType = {
    id: number
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationRequestMaxAggregateOutputType = {
    id: number
    identifier: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationRequestCountAggregateOutputType = {
    id: number
    identifier: number | null
    token: number | null
    expires: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type VerificationRequestAvgAggregateInputType = {
    id?: true
  }

  export type VerificationRequestSumAggregateInputType = {
    id?: true
  }

  export type VerificationRequestMinAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationRequestMaxAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationRequestCountAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationRequestAggregateArgs = {
    /**
     * Filter which VerificationRequest to aggregate.
    **/
    where?: VerificationRequestWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of VerificationRequests to fetch.
    **/
    orderBy?: Enumerable<VerificationRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationRequests
    **/
    count?: true | VerificationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: VerificationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: VerificationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: VerificationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: VerificationRequestMaxAggregateInputType
  }

  export type GetVerificationRequestAggregateType<T extends VerificationRequestAggregateArgs> = {
    [P in keyof T & keyof AggregateVerificationRequest]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationRequest[P]>
      : GetScalarType<T[P], AggregateVerificationRequest[P]>
  }



  export type VerificationRequestSelect = {
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationRequestGetPayload<
    S extends boolean | null | undefined | VerificationRequestArgs,
    U = keyof S
      > = S extends true
        ? VerificationRequest
    : S extends undefined
    ? never
    : S extends VerificationRequestArgs | VerificationRequestFindManyArgs
    ?'include' extends U
    ? VerificationRequest 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VerificationRequest ?VerificationRequest [P]
  : 
     never
  } 
    : VerificationRequest
  : VerificationRequest


  type VerificationRequestCountArgs = Merge<
    Omit<VerificationRequestFindManyArgs, 'select' | 'include'> & {
      select?: VerificationRequestCountAggregateInputType | true
    }
  >

  export interface VerificationRequestDelegate {
    /**
     * Find zero or one VerificationRequest that matches the filter.
     * @param {VerificationRequestFindUniqueArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationRequestFindUniqueArgs>(
      args: SelectSubset<T, VerificationRequestFindUniqueArgs>
    ): CheckSelect<T, Prisma__VerificationRequestClient<VerificationRequest | null>, Prisma__VerificationRequestClient<VerificationRequestGetPayload<T> | null>>

    /**
     * Find the first VerificationRequest that matches the filter.
     * @param {VerificationRequestFindFirstArgs} args - Arguments to find a VerificationRequest
     * @example
     * // Get one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationRequestFindFirstArgs>(
      args?: SelectSubset<T, VerificationRequestFindFirstArgs>
    ): CheckSelect<T, Prisma__VerificationRequestClient<VerificationRequest | null>, Prisma__VerificationRequestClient<VerificationRequestGetPayload<T> | null>>

    /**
     * Find zero or more VerificationRequests that matches the filter.
     * @param {VerificationRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany()
     * 
     * // Get first 10 VerificationRequests
     * const verificationRequests = await prisma.verificationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationRequestWithIdOnly = await prisma.verificationRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VerificationRequestFindManyArgs>(
      args?: SelectSubset<T, VerificationRequestFindManyArgs>
    ): CheckSelect<T, Promise<Array<VerificationRequest>>, Promise<Array<VerificationRequestGetPayload<T>>>>

    /**
     * Create a VerificationRequest.
     * @param {VerificationRequestCreateArgs} args - Arguments to create a VerificationRequest.
     * @example
     * // Create one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.create({
     *   data: {
     *     // ... data to create a VerificationRequest
     *   }
     * })
     * 
    **/
    create<T extends VerificationRequestCreateArgs>(
      args: SelectSubset<T, VerificationRequestCreateArgs>
    ): CheckSelect<T, Prisma__VerificationRequestClient<VerificationRequest>, Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>>

    /**
     * Delete a VerificationRequest.
     * @param {VerificationRequestDeleteArgs} args - Arguments to delete one VerificationRequest.
     * @example
     * // Delete one VerificationRequest
     * const VerificationRequest = await prisma.verificationRequest.delete({
     *   where: {
     *     // ... filter to delete one VerificationRequest
     *   }
     * })
     * 
    **/
    delete<T extends VerificationRequestDeleteArgs>(
      args: SelectSubset<T, VerificationRequestDeleteArgs>
    ): CheckSelect<T, Prisma__VerificationRequestClient<VerificationRequest>, Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>>

    /**
     * Update one VerificationRequest.
     * @param {VerificationRequestUpdateArgs} args - Arguments to update one VerificationRequest.
     * @example
     * // Update one VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationRequestUpdateArgs>(
      args: SelectSubset<T, VerificationRequestUpdateArgs>
    ): CheckSelect<T, Prisma__VerificationRequestClient<VerificationRequest>, Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>>

    /**
     * Delete zero or more VerificationRequests.
     * @param {VerificationRequestDeleteManyArgs} args - Arguments to filter VerificationRequests to delete.
     * @example
     * // Delete a few VerificationRequests
     * const { count } = await prisma.verificationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationRequestDeleteManyArgs>(
      args?: SelectSubset<T, VerificationRequestDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more VerificationRequests.
     * @param {VerificationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationRequests
     * const verificationRequest = await prisma.verificationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationRequestUpdateManyArgs>(
      args: SelectSubset<T, VerificationRequestUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one VerificationRequest.
     * @param {VerificationRequestUpsertArgs} args - Arguments to update or create a VerificationRequest.
     * @example
     * // Update or create a VerificationRequest
     * const verificationRequest = await prisma.verificationRequest.upsert({
     *   create: {
     *     // ... data to create a VerificationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationRequest we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationRequestUpsertArgs>(
      args: SelectSubset<T, VerificationRequestUpsertArgs>
    ): CheckSelect<T, Prisma__VerificationRequestClient<VerificationRequest>, Prisma__VerificationRequestClient<VerificationRequestGetPayload<T>>>

    /**
     * Count the number of VerificationRequests.
     * @param {VerificationRequestCountArgs} args - Arguments to filter VerificationRequests to count.
     * @example
     * // Count the number of VerificationRequests
     * const count = await prisma.verificationRequest.count({
     *   where: {
     *     // ... the filter for the VerificationRequests we want to count
     *   }
     * })
    **/
    count<T extends VerificationRequestCountArgs>(
      args?: Subset<T, VerificationRequestCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationRequest.
     * @param {VerificationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationRequestAggregateArgs>(args: Subset<T, VerificationRequestAggregateArgs>): Promise<GetVerificationRequestAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationRequestClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VerificationRequest findUnique
   */
  export type VerificationRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * Throw an Error if a VerificationRequest can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VerificationRequest to fetch.
    **/
    where: VerificationRequestWhereUniqueInput
  }


  /**
   * VerificationRequest findFirst
   */
  export type VerificationRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * Throw an Error if a VerificationRequest can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VerificationRequest to fetch.
    **/
    where?: VerificationRequestWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of VerificationRequests to fetch.
    **/
    orderBy?: Enumerable<VerificationRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationRequests.
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of VerificationRequests.
    **/
    distinct?: Enumerable<VerificationRequestScalarFieldEnum>
  }


  /**
   * VerificationRequest findMany
   */
  export type VerificationRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * Filter, which VerificationRequests to fetch.
    **/
    where?: VerificationRequestWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of VerificationRequests to fetch.
    **/
    orderBy?: Enumerable<VerificationRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationRequests.
    **/
    cursor?: VerificationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationRequests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationRequests.
    **/
    skip?: number
    distinct?: Enumerable<VerificationRequestScalarFieldEnum>
  }


  /**
   * VerificationRequest create
   */
  export type VerificationRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * The data needed to create a VerificationRequest.
    **/
    data: XOR<VerificationRequestUncheckedCreateInput, VerificationRequestCreateInput>
  }


  /**
   * VerificationRequest update
   */
  export type VerificationRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * The data needed to update a VerificationRequest.
    **/
    data: XOR<VerificationRequestUncheckedUpdateInput, VerificationRequestUpdateInput>
    /**
     * Choose, which VerificationRequest to update.
    **/
    where: VerificationRequestWhereUniqueInput
  }


  /**
   * VerificationRequest updateMany
   */
  export type VerificationRequestUpdateManyArgs = {
    data: XOR<VerificationRequestUncheckedUpdateManyInput, VerificationRequestUpdateManyMutationInput>
    where?: VerificationRequestWhereInput
  }


  /**
   * VerificationRequest upsert
   */
  export type VerificationRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * The filter to search for the VerificationRequest to update in case it exists.
    **/
    where: VerificationRequestWhereUniqueInput
    /**
     * In case the VerificationRequest found by the `where` argument doesn't exist, create a new VerificationRequest with this data.
    **/
    create: XOR<VerificationRequestUncheckedCreateInput, VerificationRequestCreateInput>
    /**
     * In case the VerificationRequest was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<VerificationRequestUncheckedUpdateInput, VerificationRequestUpdateInput>
  }


  /**
   * VerificationRequest delete
   */
  export type VerificationRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
    /**
     * Filter which VerificationRequest to delete.
    **/
    where: VerificationRequestWhereUniqueInput
  }


  /**
   * VerificationRequest deleteMany
   */
  export type VerificationRequestDeleteManyArgs = {
    where?: VerificationRequestWhereInput
  }


  /**
   * VerificationRequest without action
   */
  export type VerificationRequestArgs = {
    /**
     * Select specific fields to fetch from the VerificationRequest
    **/
    select?: VerificationRequestSelect | null
  }



  /**
   * Model Tournament
   */


  export type AggregateTournament = {
    count: TournamentCountAggregateOutputType | null
    avg: TournamentAvgAggregateOutputType | null
    sum: TournamentSumAggregateOutputType | null
    min: TournamentMinAggregateOutputType | null
    max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    groupSize: number
    teamSize: number
    rounds: number
    imageId: number | null
  }

  export type TournamentSumAggregateOutputType = {
    groupSize: number
    teamSize: number
    rounds: number
    imageId: number | null
  }

  export type TournamentMinAggregateOutputType = {
    id: string | null
    name: string | null
    closed: boolean | null
    started: boolean | null
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | null
    registrationClosesAt: Date | null
    imageId: number | null
    teamId: string | null
    gameId: string | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    closed: boolean | null
    started: boolean | null
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | null
    registrationClosesAt: Date | null
    imageId: number | null
    teamId: string | null
    gameId: string | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number | null
    name: number | null
    closed: number | null
    started: number | null
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: number | null
    registrationClosesAt: number | null
    imageId: number | null
    teamId: number | null
    gameId: number | null
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    groupSize?: true
    teamSize?: true
    rounds?: true
    imageId?: true
  }

  export type TournamentSumAggregateInputType = {
    groupSize?: true
    teamSize?: true
    rounds?: true
    imageId?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    name?: true
    closed?: true
    started?: true
    groupSize?: true
    teamSize?: true
    rounds?: true
    startsAt?: true
    registrationClosesAt?: true
    imageId?: true
    teamId?: true
    gameId?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    name?: true
    closed?: true
    started?: true
    groupSize?: true
    teamSize?: true
    rounds?: true
    startsAt?: true
    registrationClosesAt?: true
    imageId?: true
    teamId?: true
    gameId?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    name?: true
    closed?: true
    started?: true
    groupSize?: true
    teamSize?: true
    rounds?: true
    startsAt?: true
    registrationClosesAt?: true
    imageId?: true
    teamId?: true
    gameId?: true
    _all?: true
  }

  export type TournamentAggregateArgs = {
    /**
     * Filter which Tournament to aggregate.
    **/
    where?: TournamentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Tournaments to fetch.
    **/
    orderBy?: Enumerable<TournamentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournaments
    **/
    count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
    [P in keyof T & keyof AggregateTournament]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }



  export type TournamentSelect = {
    id?: boolean
    name?: boolean
    closed?: boolean
    started?: boolean
    organizer?: boolean | TeamArgs
    game?: boolean | GameArgs
    icon?: boolean | ImageArgs
    groupSize?: boolean
    teamSize?: boolean
    rounds?: boolean
    startsAt?: boolean
    registrationClosesAt?: boolean
    participants?: boolean | TournamentParticipationFindManyArgs
    applicants?: boolean | TournamentApplicationFindManyArgs
    rewards?: boolean | RewardFindManyArgs
    imageId?: boolean
    teamId?: boolean
    gameId?: boolean
    TournamentGridElement?: boolean | TournamentGridElementFindManyArgs
    TournamentMatch?: boolean | TournamentMatchFindManyArgs
  }

  export type TournamentInclude = {
    organizer?: boolean | TeamArgs
    game?: boolean | GameArgs
    icon?: boolean | ImageArgs
    participants?: boolean | TournamentParticipationFindManyArgs
    applicants?: boolean | TournamentApplicationFindManyArgs
    rewards?: boolean | RewardFindManyArgs
    TournamentGridElement?: boolean | TournamentGridElementFindManyArgs
    TournamentMatch?: boolean | TournamentMatchFindManyArgs
  }

  export type TournamentGetPayload<
    S extends boolean | null | undefined | TournamentArgs,
    U = keyof S
      > = S extends true
        ? Tournament
    : S extends undefined
    ? never
    : S extends TournamentArgs | TournamentFindManyArgs
    ?'include' extends U
    ? Tournament  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'organizer'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'game'
        ? GameGetPayload<S['include'][P]> :
        P extends 'icon'
        ? ImageGetPayload<S['include'][P]> | null :
        P extends 'participants'
        ? Array < TournamentParticipationGetPayload<S['include'][P]>>  :
        P extends 'applicants'
        ? Array < TournamentApplicationGetPayload<S['include'][P]>>  :
        P extends 'rewards'
        ? Array < RewardGetPayload<S['include'][P]>>  :
        P extends 'TournamentGridElement'
        ? Array < TournamentGridElementGetPayload<S['include'][P]>>  :
        P extends 'TournamentMatch'
        ? Array < TournamentMatchGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tournament ?Tournament [P]
  : 
          P extends 'organizer'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'game'
        ? GameGetPayload<S['select'][P]> :
        P extends 'icon'
        ? ImageGetPayload<S['select'][P]> | null :
        P extends 'participants'
        ? Array < TournamentParticipationGetPayload<S['select'][P]>>  :
        P extends 'applicants'
        ? Array < TournamentApplicationGetPayload<S['select'][P]>>  :
        P extends 'rewards'
        ? Array < RewardGetPayload<S['select'][P]>>  :
        P extends 'TournamentGridElement'
        ? Array < TournamentGridElementGetPayload<S['select'][P]>>  :
        P extends 'TournamentMatch'
        ? Array < TournamentMatchGetPayload<S['select'][P]>>  : never
  } 
    : Tournament
  : Tournament


  type TournamentCountArgs = Merge<
    Omit<TournamentFindManyArgs, 'select' | 'include'> & {
      select?: TournamentCountAggregateInputType | true
    }
  >

  export interface TournamentDelegate {
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {TournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentFindUniqueArgs>(
      args: SelectSubset<T, TournamentFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>

    /**
     * Find the first Tournament that matches the filter.
     * @param {TournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentFindFirstArgs>(
      args?: SelectSubset<T, TournamentFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>

    /**
     * Find zero or more Tournaments that matches the filter.
     * @param {TournamentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TournamentFindManyArgs>(
      args?: SelectSubset<T, TournamentFindManyArgs>
    ): CheckSelect<T, Promise<Array<Tournament>>, Promise<Array<TournamentGetPayload<T>>>>

    /**
     * Create a Tournament.
     * @param {TournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
    **/
    create<T extends TournamentCreateArgs>(
      args: SelectSubset<T, TournamentCreateArgs>
    ): CheckSelect<T, Prisma__TournamentClient<Tournament>, Prisma__TournamentClient<TournamentGetPayload<T>>>

    /**
     * Delete a Tournament.
     * @param {TournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
    **/
    delete<T extends TournamentDeleteArgs>(
      args: SelectSubset<T, TournamentDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentClient<Tournament>, Prisma__TournamentClient<TournamentGetPayload<T>>>

    /**
     * Update one Tournament.
     * @param {TournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentUpdateArgs>(
      args: SelectSubset<T, TournamentUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentClient<Tournament>, Prisma__TournamentClient<TournamentGetPayload<T>>>

    /**
     * Delete zero or more Tournaments.
     * @param {TournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentDeleteManyArgs>(
      args?: SelectSubset<T, TournamentDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * @param {TournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentUpdateManyArgs>(
      args: SelectSubset<T, TournamentUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Tournament.
     * @param {TournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentUpsertArgs>(
      args: SelectSubset<T, TournamentUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentClient<Tournament>, Prisma__TournamentClient<TournamentGetPayload<T>>>

    /**
     * Count the number of Tournaments.
     * @param {TournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends TournamentCountArgs>(
      args?: Subset<T, TournamentCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Promise<GetTournamentAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organizer<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>;

    game<T extends GameArgs = {}>(args?: Subset<T, GameArgs>): CheckSelect<T, Prisma__GameClient<Game | null>, Prisma__GameClient<GameGetPayload<T> | null>>;

    icon<T extends ImageArgs = {}>(args?: Subset<T, ImageArgs>): CheckSelect<T, Prisma__ImageClient<Image | null>, Prisma__ImageClient<ImageGetPayload<T> | null>>;

    participants<T extends TournamentParticipationFindManyArgs = {}>(args?: Subset<T, TournamentParticipationFindManyArgs>): CheckSelect<T, Promise<Array<TournamentParticipation>>, Promise<Array<TournamentParticipationGetPayload<T>>>>;

    applicants<T extends TournamentApplicationFindManyArgs = {}>(args?: Subset<T, TournamentApplicationFindManyArgs>): CheckSelect<T, Promise<Array<TournamentApplication>>, Promise<Array<TournamentApplicationGetPayload<T>>>>;

    rewards<T extends RewardFindManyArgs = {}>(args?: Subset<T, RewardFindManyArgs>): CheckSelect<T, Promise<Array<Reward>>, Promise<Array<RewardGetPayload<T>>>>;

    TournamentGridElement<T extends TournamentGridElementFindManyArgs = {}>(args?: Subset<T, TournamentGridElementFindManyArgs>): CheckSelect<T, Promise<Array<TournamentGridElement>>, Promise<Array<TournamentGridElementGetPayload<T>>>>;

    TournamentMatch<T extends TournamentMatchFindManyArgs = {}>(args?: Subset<T, TournamentMatchFindManyArgs>): CheckSelect<T, Promise<Array<TournamentMatch>>, Promise<Array<TournamentMatchGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tournament findUnique
   */
  export type TournamentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * Throw an Error if a Tournament can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tournament to fetch.
    **/
    where: TournamentWhereUniqueInput
  }


  /**
   * Tournament findFirst
   */
  export type TournamentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * Throw an Error if a Tournament can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tournament to fetch.
    **/
    where?: TournamentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Tournaments to fetch.
    **/
    orderBy?: Enumerable<TournamentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
    **/
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Tournaments.
    **/
    distinct?: Enumerable<TournamentScalarFieldEnum>
  }


  /**
   * Tournament findMany
   */
  export type TournamentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * Filter, which Tournaments to fetch.
    **/
    where?: TournamentWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Tournaments to fetch.
    **/
    orderBy?: Enumerable<TournamentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournaments.
    **/
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
    **/
    skip?: number
    distinct?: Enumerable<TournamentScalarFieldEnum>
  }


  /**
   * Tournament create
   */
  export type TournamentCreateArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * The data needed to create a Tournament.
    **/
    data: XOR<TournamentUncheckedCreateInput, TournamentCreateInput>
  }


  /**
   * Tournament update
   */
  export type TournamentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * The data needed to update a Tournament.
    **/
    data: XOR<TournamentUncheckedUpdateInput, TournamentUpdateInput>
    /**
     * Choose, which Tournament to update.
    **/
    where: TournamentWhereUniqueInput
  }


  /**
   * Tournament updateMany
   */
  export type TournamentUpdateManyArgs = {
    data: XOR<TournamentUncheckedUpdateManyInput, TournamentUpdateManyMutationInput>
    where?: TournamentWhereInput
  }


  /**
   * Tournament upsert
   */
  export type TournamentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * The filter to search for the Tournament to update in case it exists.
    **/
    where: TournamentWhereUniqueInput
    /**
     * In case the Tournament found by the `where` argument doesn't exist, create a new Tournament with this data.
    **/
    create: XOR<TournamentUncheckedCreateInput, TournamentCreateInput>
    /**
     * In case the Tournament was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentUncheckedUpdateInput, TournamentUpdateInput>
  }


  /**
   * Tournament delete
   */
  export type TournamentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
    /**
     * Filter which Tournament to delete.
    **/
    where: TournamentWhereUniqueInput
  }


  /**
   * Tournament deleteMany
   */
  export type TournamentDeleteManyArgs = {
    where?: TournamentWhereInput
  }


  /**
   * Tournament without action
   */
  export type TournamentArgs = {
    /**
     * Select specific fields to fetch from the Tournament
    **/
    select?: TournamentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentInclude | null
  }



  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    count: AdminCountAggregateOutputType | null
    avg: AdminAvgAggregateOutputType | null
    sum: AdminSumAggregateOutputType | null
    min: AdminMinAggregateOutputType | null
    max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    userId: number
  }

  export type AdminSumAggregateOutputType = {
    userId: number
  }

  export type AdminMinAggregateOutputType = {
    userId: number
  }

  export type AdminMaxAggregateOutputType = {
    userId: number
  }

  export type AdminCountAggregateOutputType = {
    userId: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    userId?: true
  }

  export type AdminMaxAggregateInputType = {
    userId?: true
  }

  export type AdminCountAggregateInputType = {
    userId?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which Admin to aggregate.
    **/
    where?: AdminWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
    [P in keyof T & keyof AggregateAdmin]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }



  export type AdminSelect = {
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type AdminInclude = {
    user?: boolean | UserArgs
  }

  export type AdminGetPayload<
    S extends boolean | null | undefined | AdminArgs,
    U = keyof S
      > = S extends true
        ? Admin
    : S extends undefined
    ? never
    : S extends AdminArgs | AdminFindManyArgs
    ?'include' extends U
    ? Admin  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Admin ?Admin [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Admin
  : Admin


  type AdminCountArgs = Merge<
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }
  >

  export interface AdminDelegate {
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs>(
      args: SelectSubset<T, AdminFindUniqueArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin | null>, Prisma__AdminClient<AdminGetPayload<T> | null>>

    /**
     * Find the first Admin that matches the filter.
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs>(
      args?: SelectSubset<T, AdminFindFirstArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin | null>, Prisma__AdminClient<AdminGetPayload<T> | null>>

    /**
     * Find zero or more Admins that matches the filter.
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminWithUserIdOnly = await prisma.admin.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs>(
      args?: SelectSubset<T, AdminFindManyArgs>
    ): CheckSelect<T, Promise<Array<Admin>>, Promise<Array<AdminGetPayload<T>>>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs>(
      args: SelectSubset<T, AdminCreateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs>(
      args: SelectSubset<T, AdminDeleteArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs>(
      args: SelectSubset<T, AdminUpdateArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs>(
      args?: SelectSubset<T, AdminDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Admins.
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs>(
      args: SelectSubset<T, AdminUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs>(
      args: SelectSubset<T, AdminUpsertArgs>
    ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>

    /**
     * Count the number of Admins.
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Promise<GetAdminAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Throw an Error if a Admin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Throw an Error if a Admin can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admin to fetch.
    **/
    where?: AdminWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Admins.
    **/
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Filter, which Admins to fetch.
    **/
    where?: AdminWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Admins to fetch.
    **/
    orderBy?: Enumerable<AdminOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
    **/
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
    **/
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The data needed to create a Admin.
    **/
    data: XOR<AdminUncheckedCreateInput, AdminCreateInput>
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The data needed to update a Admin.
    **/
    data: XOR<AdminUncheckedUpdateInput, AdminUpdateInput>
    /**
     * Choose, which Admin to update.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs = {
    data: XOR<AdminUncheckedUpdateManyInput, AdminUpdateManyMutationInput>
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * The filter to search for the Admin to update in case it exists.
    **/
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
    **/
    create: XOR<AdminUncheckedCreateInput, AdminCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AdminUncheckedUpdateInput, AdminUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
    /**
     * Filter which Admin to delete.
    **/
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs = {
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs = {
    /**
     * Select specific fields to fetch from the Admin
    **/
    select?: AdminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminInclude | null
  }



  /**
   * Model News
   */


  export type AggregateNews = {
    count: NewsCountAggregateOutputType | null
    avg: NewsAvgAggregateOutputType | null
    sum: NewsSumAggregateOutputType | null
    min: NewsMinAggregateOutputType | null
    max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number
    userId: number
    imageId: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number
    userId: number
    imageId: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number
    title: string | null
    content: JsonValue | null
    createdAt: Date | null
    userId: number
    imageId: number | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number
    title: string | null
    content: JsonValue | null
    createdAt: Date | null
    userId: number
    imageId: number | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number | null
    content: number | null
    createdAt: number | null
    userId: number
    imageId: number | null
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
    userId?: true
    imageId?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
    userId?: true
    imageId?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    userId?: true
    imageId?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    userId?: true
    imageId?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    userId?: true
    imageId?: true
    _all?: true
  }

  export type NewsAggregateArgs = {
    /**
     * Filter which News to aggregate.
    **/
    where?: NewsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of News to fetch.
    **/
    orderBy?: Enumerable<NewsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
    [P in keyof T & keyof AggregateNews]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }



  export type NewsSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    author?: boolean | UserArgs
    cover?: boolean | ImageArgs
    userId?: boolean
    imageId?: boolean
  }

  export type NewsInclude = {
    author?: boolean | UserArgs
    cover?: boolean | ImageArgs
  }

  export type NewsGetPayload<
    S extends boolean | null | undefined | NewsArgs,
    U = keyof S
      > = S extends true
        ? News
    : S extends undefined
    ? never
    : S extends NewsArgs | NewsFindManyArgs
    ?'include' extends U
    ? News  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'author'
        ? UserGetPayload<S['include'][P]> :
        P extends 'cover'
        ? ImageGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof News ?News [P]
  : 
          P extends 'author'
        ? UserGetPayload<S['select'][P]> :
        P extends 'cover'
        ? ImageGetPayload<S['select'][P]> | null : never
  } 
    : News
  : News


  type NewsCountArgs = Merge<
    Omit<NewsFindManyArgs, 'select' | 'include'> & {
      select?: NewsCountAggregateInputType | true
    }
  >

  export interface NewsDelegate {
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NewsFindUniqueArgs>(
      args: SelectSubset<T, NewsFindUniqueArgs>
    ): CheckSelect<T, Prisma__NewsClient<News | null>, Prisma__NewsClient<NewsGetPayload<T> | null>>

    /**
     * Find the first News that matches the filter.
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NewsFindFirstArgs>(
      args?: SelectSubset<T, NewsFindFirstArgs>
    ): CheckSelect<T, Prisma__NewsClient<News | null>, Prisma__NewsClient<NewsGetPayload<T> | null>>

    /**
     * Find zero or more News that matches the filter.
     * @param {NewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NewsFindManyArgs>(
      args?: SelectSubset<T, NewsFindManyArgs>
    ): CheckSelect<T, Promise<Array<News>>, Promise<Array<NewsGetPayload<T>>>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
    **/
    create<T extends NewsCreateArgs>(
      args: SelectSubset<T, NewsCreateArgs>
    ): CheckSelect<T, Prisma__NewsClient<News>, Prisma__NewsClient<NewsGetPayload<T>>>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
    **/
    delete<T extends NewsDeleteArgs>(
      args: SelectSubset<T, NewsDeleteArgs>
    ): CheckSelect<T, Prisma__NewsClient<News>, Prisma__NewsClient<NewsGetPayload<T>>>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NewsUpdateArgs>(
      args: SelectSubset<T, NewsUpdateArgs>
    ): CheckSelect<T, Prisma__NewsClient<News>, Prisma__NewsClient<NewsGetPayload<T>>>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NewsDeleteManyArgs>(
      args?: SelectSubset<T, NewsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more News.
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NewsUpdateManyArgs>(
      args: SelectSubset<T, NewsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
    **/
    upsert<T extends NewsUpsertArgs>(
      args: SelectSubset<T, NewsUpsertArgs>
    ): CheckSelect<T, Prisma__NewsClient<News>, Prisma__NewsClient<NewsGetPayload<T>>>

    /**
     * Count the number of News.
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Promise<GetNewsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NewsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    cover<T extends ImageArgs = {}>(args?: Subset<T, ImageArgs>): CheckSelect<T, Prisma__ImageClient<Image | null>, Prisma__ImageClient<ImageGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * Throw an Error if a News can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which News to fetch.
    **/
    where: NewsWhereUniqueInput
  }


  /**
   * News findFirst
   */
  export type NewsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * Throw an Error if a News can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which News to fetch.
    **/
    where?: NewsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of News to fetch.
    **/
    orderBy?: Enumerable<NewsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of News.
    **/
    distinct?: Enumerable<NewsScalarFieldEnum>
  }


  /**
   * News findMany
   */
  export type NewsFindManyArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * Filter, which News to fetch.
    **/
    where?: NewsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of News to fetch.
    **/
    orderBy?: Enumerable<NewsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
    **/
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
    **/
    skip?: number
    distinct?: Enumerable<NewsScalarFieldEnum>
  }


  /**
   * News create
   */
  export type NewsCreateArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * The data needed to create a News.
    **/
    data: XOR<NewsUncheckedCreateInput, NewsCreateInput>
  }


  /**
   * News update
   */
  export type NewsUpdateArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * The data needed to update a News.
    **/
    data: XOR<NewsUncheckedUpdateInput, NewsUpdateInput>
    /**
     * Choose, which News to update.
    **/
    where: NewsWhereUniqueInput
  }


  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs = {
    data: XOR<NewsUncheckedUpdateManyInput, NewsUpdateManyMutationInput>
    where?: NewsWhereInput
  }


  /**
   * News upsert
   */
  export type NewsUpsertArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * The filter to search for the News to update in case it exists.
    **/
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
    **/
    create: XOR<NewsUncheckedCreateInput, NewsCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<NewsUncheckedUpdateInput, NewsUpdateInput>
  }


  /**
   * News delete
   */
  export type NewsDeleteArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
    /**
     * Filter which News to delete.
    **/
    where: NewsWhereUniqueInput
  }


  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs = {
    where?: NewsWhereInput
  }


  /**
   * News without action
   */
  export type NewsArgs = {
    /**
     * Select specific fields to fetch from the News
    **/
    select?: NewsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NewsInclude | null
  }



  /**
   * Model TournamentApplication
   */


  export type AggregateTournamentApplication = {
    count: TournamentApplicationCountAggregateOutputType | null
    avg: TournamentApplicationAvgAggregateOutputType | null
    sum: TournamentApplicationSumAggregateOutputType | null
    min: TournamentApplicationMinAggregateOutputType | null
    max: TournamentApplicationMaxAggregateOutputType | null
  }

  export type TournamentApplicationAvgAggregateOutputType = {
    id: number
  }

  export type TournamentApplicationSumAggregateOutputType = {
    id: number
  }

  export type TournamentApplicationMinAggregateOutputType = {
    id: number
    createdAt: Date | null
    tournamentId: string | null
    teamId: string | null
  }

  export type TournamentApplicationMaxAggregateOutputType = {
    id: number
    createdAt: Date | null
    tournamentId: string | null
    teamId: string | null
  }

  export type TournamentApplicationCountAggregateOutputType = {
    id: number
    createdAt: number | null
    tournamentId: number | null
    teamId: number | null
    _all: number
  }


  export type TournamentApplicationAvgAggregateInputType = {
    id?: true
  }

  export type TournamentApplicationSumAggregateInputType = {
    id?: true
  }

  export type TournamentApplicationMinAggregateInputType = {
    id?: true
    createdAt?: true
    tournamentId?: true
    teamId?: true
  }

  export type TournamentApplicationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    tournamentId?: true
    teamId?: true
  }

  export type TournamentApplicationCountAggregateInputType = {
    id?: true
    createdAt?: true
    tournamentId?: true
    teamId?: true
    _all?: true
  }

  export type TournamentApplicationAggregateArgs = {
    /**
     * Filter which TournamentApplication to aggregate.
    **/
    where?: TournamentApplicationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentApplications to fetch.
    **/
    orderBy?: Enumerable<TournamentApplicationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentApplications from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentApplications.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentApplications
    **/
    count?: true | TournamentApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentApplicationMaxAggregateInputType
  }

  export type GetTournamentApplicationAggregateType<T extends TournamentApplicationAggregateArgs> = {
    [P in keyof T & keyof AggregateTournamentApplication]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentApplication[P]>
      : GetScalarType<T[P], AggregateTournamentApplication[P]>
  }



  export type TournamentApplicationSelect = {
    id?: boolean
    tournament?: boolean | TournamentArgs
    team?: boolean | TeamArgs
    players?: boolean | UserFindManyArgs
    createdAt?: boolean
    tournamentId?: boolean
    teamId?: boolean
  }

  export type TournamentApplicationInclude = {
    tournament?: boolean | TournamentArgs
    team?: boolean | TeamArgs
    players?: boolean | UserFindManyArgs
  }

  export type TournamentApplicationGetPayload<
    S extends boolean | null | undefined | TournamentApplicationArgs,
    U = keyof S
      > = S extends true
        ? TournamentApplication
    : S extends undefined
    ? never
    : S extends TournamentApplicationArgs | TournamentApplicationFindManyArgs
    ?'include' extends U
    ? TournamentApplication  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tournament'
        ? TournamentGetPayload<S['include'][P]> :
        P extends 'team'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'players'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TournamentApplication ?TournamentApplication [P]
  : 
          P extends 'tournament'
        ? TournamentGetPayload<S['select'][P]> :
        P extends 'team'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'players'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : TournamentApplication
  : TournamentApplication


  type TournamentApplicationCountArgs = Merge<
    Omit<TournamentApplicationFindManyArgs, 'select' | 'include'> & {
      select?: TournamentApplicationCountAggregateInputType | true
    }
  >

  export interface TournamentApplicationDelegate {
    /**
     * Find zero or one TournamentApplication that matches the filter.
     * @param {TournamentApplicationFindUniqueArgs} args - Arguments to find a TournamentApplication
     * @example
     * // Get one TournamentApplication
     * const tournamentApplication = await prisma.tournamentApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentApplicationFindUniqueArgs>(
      args: SelectSubset<T, TournamentApplicationFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication | null>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T> | null>>

    /**
     * Find the first TournamentApplication that matches the filter.
     * @param {TournamentApplicationFindFirstArgs} args - Arguments to find a TournamentApplication
     * @example
     * // Get one TournamentApplication
     * const tournamentApplication = await prisma.tournamentApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentApplicationFindFirstArgs>(
      args?: SelectSubset<T, TournamentApplicationFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication | null>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T> | null>>

    /**
     * Find zero or more TournamentApplications that matches the filter.
     * @param {TournamentApplicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentApplications
     * const tournamentApplications = await prisma.tournamentApplication.findMany()
     * 
     * // Get first 10 TournamentApplications
     * const tournamentApplications = await prisma.tournamentApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentApplicationWithIdOnly = await prisma.tournamentApplication.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TournamentApplicationFindManyArgs>(
      args?: SelectSubset<T, TournamentApplicationFindManyArgs>
    ): CheckSelect<T, Promise<Array<TournamentApplication>>, Promise<Array<TournamentApplicationGetPayload<T>>>>

    /**
     * Create a TournamentApplication.
     * @param {TournamentApplicationCreateArgs} args - Arguments to create a TournamentApplication.
     * @example
     * // Create one TournamentApplication
     * const TournamentApplication = await prisma.tournamentApplication.create({
     *   data: {
     *     // ... data to create a TournamentApplication
     *   }
     * })
     * 
    **/
    create<T extends TournamentApplicationCreateArgs>(
      args: SelectSubset<T, TournamentApplicationCreateArgs>
    ): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T>>>

    /**
     * Delete a TournamentApplication.
     * @param {TournamentApplicationDeleteArgs} args - Arguments to delete one TournamentApplication.
     * @example
     * // Delete one TournamentApplication
     * const TournamentApplication = await prisma.tournamentApplication.delete({
     *   where: {
     *     // ... filter to delete one TournamentApplication
     *   }
     * })
     * 
    **/
    delete<T extends TournamentApplicationDeleteArgs>(
      args: SelectSubset<T, TournamentApplicationDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T>>>

    /**
     * Update one TournamentApplication.
     * @param {TournamentApplicationUpdateArgs} args - Arguments to update one TournamentApplication.
     * @example
     * // Update one TournamentApplication
     * const tournamentApplication = await prisma.tournamentApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentApplicationUpdateArgs>(
      args: SelectSubset<T, TournamentApplicationUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T>>>

    /**
     * Delete zero or more TournamentApplications.
     * @param {TournamentApplicationDeleteManyArgs} args - Arguments to filter TournamentApplications to delete.
     * @example
     * // Delete a few TournamentApplications
     * const { count } = await prisma.tournamentApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentApplicationDeleteManyArgs>(
      args?: SelectSubset<T, TournamentApplicationDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TournamentApplications.
     * @param {TournamentApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentApplications
     * const tournamentApplication = await prisma.tournamentApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentApplicationUpdateManyArgs>(
      args: SelectSubset<T, TournamentApplicationUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TournamentApplication.
     * @param {TournamentApplicationUpsertArgs} args - Arguments to update or create a TournamentApplication.
     * @example
     * // Update or create a TournamentApplication
     * const tournamentApplication = await prisma.tournamentApplication.upsert({
     *   create: {
     *     // ... data to create a TournamentApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentApplication we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentApplicationUpsertArgs>(
      args: SelectSubset<T, TournamentApplicationUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentApplicationClient<TournamentApplication>, Prisma__TournamentApplicationClient<TournamentApplicationGetPayload<T>>>

    /**
     * Count the number of TournamentApplications.
     * @param {TournamentApplicationCountArgs} args - Arguments to filter TournamentApplications to count.
     * @example
     * // Count the number of TournamentApplications
     * const count = await prisma.tournamentApplication.count({
     *   where: {
     *     // ... the filter for the TournamentApplications we want to count
     *   }
     * })
    **/
    count<T extends TournamentApplicationCountArgs>(
      args?: Subset<T, TournamentApplicationCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentApplication.
     * @param {TournamentApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentApplicationAggregateArgs>(args: Subset<T, TournamentApplicationAggregateArgs>): Promise<GetTournamentApplicationAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentApplicationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tournament<T extends TournamentArgs = {}>(args?: Subset<T, TournamentArgs>): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>;

    team<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>;

    players<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TournamentApplication findUnique
   */
  export type TournamentApplicationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * Throw an Error if a TournamentApplication can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentApplication to fetch.
    **/
    where: TournamentApplicationWhereUniqueInput
  }


  /**
   * TournamentApplication findFirst
   */
  export type TournamentApplicationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * Throw an Error if a TournamentApplication can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentApplication to fetch.
    **/
    where?: TournamentApplicationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentApplications to fetch.
    **/
    orderBy?: Enumerable<TournamentApplicationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentApplications.
    **/
    cursor?: TournamentApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentApplications from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentApplications.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TournamentApplications.
    **/
    distinct?: Enumerable<TournamentApplicationScalarFieldEnum>
  }


  /**
   * TournamentApplication findMany
   */
  export type TournamentApplicationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * Filter, which TournamentApplications to fetch.
    **/
    where?: TournamentApplicationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentApplications to fetch.
    **/
    orderBy?: Enumerable<TournamentApplicationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentApplications.
    **/
    cursor?: TournamentApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentApplications from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentApplications.
    **/
    skip?: number
    distinct?: Enumerable<TournamentApplicationScalarFieldEnum>
  }


  /**
   * TournamentApplication create
   */
  export type TournamentApplicationCreateArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * The data needed to create a TournamentApplication.
    **/
    data: XOR<TournamentApplicationUncheckedCreateInput, TournamentApplicationCreateInput>
  }


  /**
   * TournamentApplication update
   */
  export type TournamentApplicationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * The data needed to update a TournamentApplication.
    **/
    data: XOR<TournamentApplicationUncheckedUpdateInput, TournamentApplicationUpdateInput>
    /**
     * Choose, which TournamentApplication to update.
    **/
    where: TournamentApplicationWhereUniqueInput
  }


  /**
   * TournamentApplication updateMany
   */
  export type TournamentApplicationUpdateManyArgs = {
    data: XOR<TournamentApplicationUncheckedUpdateManyInput, TournamentApplicationUpdateManyMutationInput>
    where?: TournamentApplicationWhereInput
  }


  /**
   * TournamentApplication upsert
   */
  export type TournamentApplicationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * The filter to search for the TournamentApplication to update in case it exists.
    **/
    where: TournamentApplicationWhereUniqueInput
    /**
     * In case the TournamentApplication found by the `where` argument doesn't exist, create a new TournamentApplication with this data.
    **/
    create: XOR<TournamentApplicationUncheckedCreateInput, TournamentApplicationCreateInput>
    /**
     * In case the TournamentApplication was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentApplicationUncheckedUpdateInput, TournamentApplicationUpdateInput>
  }


  /**
   * TournamentApplication delete
   */
  export type TournamentApplicationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
    /**
     * Filter which TournamentApplication to delete.
    **/
    where: TournamentApplicationWhereUniqueInput
  }


  /**
   * TournamentApplication deleteMany
   */
  export type TournamentApplicationDeleteManyArgs = {
    where?: TournamentApplicationWhereInput
  }


  /**
   * TournamentApplication without action
   */
  export type TournamentApplicationArgs = {
    /**
     * Select specific fields to fetch from the TournamentApplication
    **/
    select?: TournamentApplicationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentApplicationInclude | null
  }



  /**
   * Model TournamentGridElement
   */


  export type AggregateTournamentGridElement = {
    count: TournamentGridElementCountAggregateOutputType | null
    avg: TournamentGridElementAvgAggregateOutputType | null
    sum: TournamentGridElementSumAggregateOutputType | null
    min: TournamentGridElementMinAggregateOutputType | null
    max: TournamentGridElementMaxAggregateOutputType | null
  }

  export type TournamentGridElementAvgAggregateOutputType = {
    id: number
    round: number
    group: number
    matchId: number | null
  }

  export type TournamentGridElementSumAggregateOutputType = {
    id: number
    round: number
    group: number
    matchId: number | null
  }

  export type TournamentGridElementMinAggregateOutputType = {
    id: number
    round: number
    group: number
    tournamentId: string | null
    matchId: number | null
    teamId: string | null
  }

  export type TournamentGridElementMaxAggregateOutputType = {
    id: number
    round: number
    group: number
    tournamentId: string | null
    matchId: number | null
    teamId: string | null
  }

  export type TournamentGridElementCountAggregateOutputType = {
    id: number
    round: number
    group: number
    tournamentId: number | null
    matchId: number | null
    teamId: number | null
    _all: number
  }


  export type TournamentGridElementAvgAggregateInputType = {
    id?: true
    round?: true
    group?: true
    matchId?: true
  }

  export type TournamentGridElementSumAggregateInputType = {
    id?: true
    round?: true
    group?: true
    matchId?: true
  }

  export type TournamentGridElementMinAggregateInputType = {
    id?: true
    round?: true
    group?: true
    tournamentId?: true
    matchId?: true
    teamId?: true
  }

  export type TournamentGridElementMaxAggregateInputType = {
    id?: true
    round?: true
    group?: true
    tournamentId?: true
    matchId?: true
    teamId?: true
  }

  export type TournamentGridElementCountAggregateInputType = {
    id?: true
    round?: true
    group?: true
    tournamentId?: true
    matchId?: true
    teamId?: true
    _all?: true
  }

  export type TournamentGridElementAggregateArgs = {
    /**
     * Filter which TournamentGridElement to aggregate.
    **/
    where?: TournamentGridElementWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentGridElements to fetch.
    **/
    orderBy?: Enumerable<TournamentGridElementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentGridElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentGridElements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentGridElements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentGridElements
    **/
    count?: true | TournamentGridElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentGridElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentGridElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentGridElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentGridElementMaxAggregateInputType
  }

  export type GetTournamentGridElementAggregateType<T extends TournamentGridElementAggregateArgs> = {
    [P in keyof T & keyof AggregateTournamentGridElement]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentGridElement[P]>
      : GetScalarType<T[P], AggregateTournamentGridElement[P]>
  }



  export type TournamentGridElementSelect = {
    id?: boolean
    tournament?: boolean | TournamentArgs
    participant?: boolean | TournamentParticipationArgs
    round?: boolean
    group?: boolean
    match?: boolean | TournamentMatchArgs
    tournamentId?: boolean
    matchId?: boolean
    teamId?: boolean
  }

  export type TournamentGridElementInclude = {
    tournament?: boolean | TournamentArgs
    participant?: boolean | TournamentParticipationArgs
    match?: boolean | TournamentMatchArgs
  }

  export type TournamentGridElementGetPayload<
    S extends boolean | null | undefined | TournamentGridElementArgs,
    U = keyof S
      > = S extends true
        ? TournamentGridElement
    : S extends undefined
    ? never
    : S extends TournamentGridElementArgs | TournamentGridElementFindManyArgs
    ?'include' extends U
    ? TournamentGridElement  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tournament'
        ? TournamentGetPayload<S['include'][P]> :
        P extends 'participant'
        ? TournamentParticipationGetPayload<S['include'][P]> :
        P extends 'match'
        ? TournamentMatchGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TournamentGridElement ?TournamentGridElement [P]
  : 
          P extends 'tournament'
        ? TournamentGetPayload<S['select'][P]> :
        P extends 'participant'
        ? TournamentParticipationGetPayload<S['select'][P]> :
        P extends 'match'
        ? TournamentMatchGetPayload<S['select'][P]> | null : never
  } 
    : TournamentGridElement
  : TournamentGridElement


  type TournamentGridElementCountArgs = Merge<
    Omit<TournamentGridElementFindManyArgs, 'select' | 'include'> & {
      select?: TournamentGridElementCountAggregateInputType | true
    }
  >

  export interface TournamentGridElementDelegate {
    /**
     * Find zero or one TournamentGridElement that matches the filter.
     * @param {TournamentGridElementFindUniqueArgs} args - Arguments to find a TournamentGridElement
     * @example
     * // Get one TournamentGridElement
     * const tournamentGridElement = await prisma.tournamentGridElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentGridElementFindUniqueArgs>(
      args: SelectSubset<T, TournamentGridElementFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentGridElementClient<TournamentGridElement | null>, Prisma__TournamentGridElementClient<TournamentGridElementGetPayload<T> | null>>

    /**
     * Find the first TournamentGridElement that matches the filter.
     * @param {TournamentGridElementFindFirstArgs} args - Arguments to find a TournamentGridElement
     * @example
     * // Get one TournamentGridElement
     * const tournamentGridElement = await prisma.tournamentGridElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentGridElementFindFirstArgs>(
      args?: SelectSubset<T, TournamentGridElementFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentGridElementClient<TournamentGridElement | null>, Prisma__TournamentGridElementClient<TournamentGridElementGetPayload<T> | null>>

    /**
     * Find zero or more TournamentGridElements that matches the filter.
     * @param {TournamentGridElementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentGridElements
     * const tournamentGridElements = await prisma.tournamentGridElement.findMany()
     * 
     * // Get first 10 TournamentGridElements
     * const tournamentGridElements = await prisma.tournamentGridElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentGridElementWithIdOnly = await prisma.tournamentGridElement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TournamentGridElementFindManyArgs>(
      args?: SelectSubset<T, TournamentGridElementFindManyArgs>
    ): CheckSelect<T, Promise<Array<TournamentGridElement>>, Promise<Array<TournamentGridElementGetPayload<T>>>>

    /**
     * Create a TournamentGridElement.
     * @param {TournamentGridElementCreateArgs} args - Arguments to create a TournamentGridElement.
     * @example
     * // Create one TournamentGridElement
     * const TournamentGridElement = await prisma.tournamentGridElement.create({
     *   data: {
     *     // ... data to create a TournamentGridElement
     *   }
     * })
     * 
    **/
    create<T extends TournamentGridElementCreateArgs>(
      args: SelectSubset<T, TournamentGridElementCreateArgs>
    ): CheckSelect<T, Prisma__TournamentGridElementClient<TournamentGridElement>, Prisma__TournamentGridElementClient<TournamentGridElementGetPayload<T>>>

    /**
     * Delete a TournamentGridElement.
     * @param {TournamentGridElementDeleteArgs} args - Arguments to delete one TournamentGridElement.
     * @example
     * // Delete one TournamentGridElement
     * const TournamentGridElement = await prisma.tournamentGridElement.delete({
     *   where: {
     *     // ... filter to delete one TournamentGridElement
     *   }
     * })
     * 
    **/
    delete<T extends TournamentGridElementDeleteArgs>(
      args: SelectSubset<T, TournamentGridElementDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentGridElementClient<TournamentGridElement>, Prisma__TournamentGridElementClient<TournamentGridElementGetPayload<T>>>

    /**
     * Update one TournamentGridElement.
     * @param {TournamentGridElementUpdateArgs} args - Arguments to update one TournamentGridElement.
     * @example
     * // Update one TournamentGridElement
     * const tournamentGridElement = await prisma.tournamentGridElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentGridElementUpdateArgs>(
      args: SelectSubset<T, TournamentGridElementUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentGridElementClient<TournamentGridElement>, Prisma__TournamentGridElementClient<TournamentGridElementGetPayload<T>>>

    /**
     * Delete zero or more TournamentGridElements.
     * @param {TournamentGridElementDeleteManyArgs} args - Arguments to filter TournamentGridElements to delete.
     * @example
     * // Delete a few TournamentGridElements
     * const { count } = await prisma.tournamentGridElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentGridElementDeleteManyArgs>(
      args?: SelectSubset<T, TournamentGridElementDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TournamentGridElements.
     * @param {TournamentGridElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentGridElements
     * const tournamentGridElement = await prisma.tournamentGridElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentGridElementUpdateManyArgs>(
      args: SelectSubset<T, TournamentGridElementUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TournamentGridElement.
     * @param {TournamentGridElementUpsertArgs} args - Arguments to update or create a TournamentGridElement.
     * @example
     * // Update or create a TournamentGridElement
     * const tournamentGridElement = await prisma.tournamentGridElement.upsert({
     *   create: {
     *     // ... data to create a TournamentGridElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentGridElement we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentGridElementUpsertArgs>(
      args: SelectSubset<T, TournamentGridElementUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentGridElementClient<TournamentGridElement>, Prisma__TournamentGridElementClient<TournamentGridElementGetPayload<T>>>

    /**
     * Count the number of TournamentGridElements.
     * @param {TournamentGridElementCountArgs} args - Arguments to filter TournamentGridElements to count.
     * @example
     * // Count the number of TournamentGridElements
     * const count = await prisma.tournamentGridElement.count({
     *   where: {
     *     // ... the filter for the TournamentGridElements we want to count
     *   }
     * })
    **/
    count<T extends TournamentGridElementCountArgs>(
      args?: Subset<T, TournamentGridElementCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentGridElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentGridElement.
     * @param {TournamentGridElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentGridElementAggregateArgs>(args: Subset<T, TournamentGridElementAggregateArgs>): Promise<GetTournamentGridElementAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentGridElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentGridElementClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tournament<T extends TournamentArgs = {}>(args?: Subset<T, TournamentArgs>): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>;

    participant<T extends TournamentParticipationArgs = {}>(args?: Subset<T, TournamentParticipationArgs>): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation | null>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T> | null>>;

    match<T extends TournamentMatchArgs = {}>(args?: Subset<T, TournamentMatchArgs>): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch | null>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TournamentGridElement findUnique
   */
  export type TournamentGridElementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * Throw an Error if a TournamentGridElement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentGridElement to fetch.
    **/
    where: TournamentGridElementWhereUniqueInput
  }


  /**
   * TournamentGridElement findFirst
   */
  export type TournamentGridElementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * Throw an Error if a TournamentGridElement can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentGridElement to fetch.
    **/
    where?: TournamentGridElementWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentGridElements to fetch.
    **/
    orderBy?: Enumerable<TournamentGridElementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentGridElements.
    **/
    cursor?: TournamentGridElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentGridElements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentGridElements.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TournamentGridElements.
    **/
    distinct?: Enumerable<TournamentGridElementScalarFieldEnum>
  }


  /**
   * TournamentGridElement findMany
   */
  export type TournamentGridElementFindManyArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * Filter, which TournamentGridElements to fetch.
    **/
    where?: TournamentGridElementWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentGridElements to fetch.
    **/
    orderBy?: Enumerable<TournamentGridElementOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentGridElements.
    **/
    cursor?: TournamentGridElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentGridElements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentGridElements.
    **/
    skip?: number
    distinct?: Enumerable<TournamentGridElementScalarFieldEnum>
  }


  /**
   * TournamentGridElement create
   */
  export type TournamentGridElementCreateArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * The data needed to create a TournamentGridElement.
    **/
    data: XOR<TournamentGridElementUncheckedCreateInput, TournamentGridElementCreateInput>
  }


  /**
   * TournamentGridElement update
   */
  export type TournamentGridElementUpdateArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * The data needed to update a TournamentGridElement.
    **/
    data: XOR<TournamentGridElementUncheckedUpdateInput, TournamentGridElementUpdateInput>
    /**
     * Choose, which TournamentGridElement to update.
    **/
    where: TournamentGridElementWhereUniqueInput
  }


  /**
   * TournamentGridElement updateMany
   */
  export type TournamentGridElementUpdateManyArgs = {
    data: XOR<TournamentGridElementUncheckedUpdateManyInput, TournamentGridElementUpdateManyMutationInput>
    where?: TournamentGridElementWhereInput
  }


  /**
   * TournamentGridElement upsert
   */
  export type TournamentGridElementUpsertArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * The filter to search for the TournamentGridElement to update in case it exists.
    **/
    where: TournamentGridElementWhereUniqueInput
    /**
     * In case the TournamentGridElement found by the `where` argument doesn't exist, create a new TournamentGridElement with this data.
    **/
    create: XOR<TournamentGridElementUncheckedCreateInput, TournamentGridElementCreateInput>
    /**
     * In case the TournamentGridElement was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentGridElementUncheckedUpdateInput, TournamentGridElementUpdateInput>
  }


  /**
   * TournamentGridElement delete
   */
  export type TournamentGridElementDeleteArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
    /**
     * Filter which TournamentGridElement to delete.
    **/
    where: TournamentGridElementWhereUniqueInput
  }


  /**
   * TournamentGridElement deleteMany
   */
  export type TournamentGridElementDeleteManyArgs = {
    where?: TournamentGridElementWhereInput
  }


  /**
   * TournamentGridElement without action
   */
  export type TournamentGridElementArgs = {
    /**
     * Select specific fields to fetch from the TournamentGridElement
    **/
    select?: TournamentGridElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentGridElementInclude | null
  }



  /**
   * Model TournamentParticipation
   */


  export type AggregateTournamentParticipation = {
    count: TournamentParticipationCountAggregateOutputType | null
    avg: TournamentParticipationAvgAggregateOutputType | null
    sum: TournamentParticipationSumAggregateOutputType | null
    min: TournamentParticipationMinAggregateOutputType | null
    max: TournamentParticipationMaxAggregateOutputType | null
  }

  export type TournamentParticipationAvgAggregateOutputType = {
    placement: number | null
    matchId: number | null
  }

  export type TournamentParticipationSumAggregateOutputType = {
    placement: number | null
    matchId: number | null
  }

  export type TournamentParticipationMinAggregateOutputType = {
    placement: number | null
    matchId: number | null
    tournamentId: string | null
    teamId: string | null
  }

  export type TournamentParticipationMaxAggregateOutputType = {
    placement: number | null
    matchId: number | null
    tournamentId: string | null
    teamId: string | null
  }

  export type TournamentParticipationCountAggregateOutputType = {
    placement: number | null
    matchId: number | null
    tournamentId: number | null
    teamId: number | null
    _all: number
  }


  export type TournamentParticipationAvgAggregateInputType = {
    placement?: true
    matchId?: true
  }

  export type TournamentParticipationSumAggregateInputType = {
    placement?: true
    matchId?: true
  }

  export type TournamentParticipationMinAggregateInputType = {
    placement?: true
    matchId?: true
    tournamentId?: true
    teamId?: true
  }

  export type TournamentParticipationMaxAggregateInputType = {
    placement?: true
    matchId?: true
    tournamentId?: true
    teamId?: true
  }

  export type TournamentParticipationCountAggregateInputType = {
    placement?: true
    matchId?: true
    tournamentId?: true
    teamId?: true
    _all?: true
  }

  export type TournamentParticipationAggregateArgs = {
    /**
     * Filter which TournamentParticipation to aggregate.
    **/
    where?: TournamentParticipationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentParticipations to fetch.
    **/
    orderBy?: Enumerable<TournamentParticipationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentParticipations
    **/
    count?: true | TournamentParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentParticipationMaxAggregateInputType
  }

  export type GetTournamentParticipationAggregateType<T extends TournamentParticipationAggregateArgs> = {
    [P in keyof T & keyof AggregateTournamentParticipation]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentParticipation[P]>
      : GetScalarType<T[P], AggregateTournamentParticipation[P]>
  }



  export type TournamentParticipationSelect = {
    team?: boolean | TeamArgs
    tournament?: boolean | TournamentArgs
    players?: boolean | UserFindManyArgs
    match?: boolean | TournamentMatchArgs
    placement?: boolean
    matchId?: boolean
    tournamentId?: boolean
    teamId?: boolean
    TournamentGridElement?: boolean | TournamentGridElementFindManyArgs
  }

  export type TournamentParticipationInclude = {
    team?: boolean | TeamArgs
    tournament?: boolean | TournamentArgs
    players?: boolean | UserFindManyArgs
    match?: boolean | TournamentMatchArgs
    TournamentGridElement?: boolean | TournamentGridElementFindManyArgs
  }

  export type TournamentParticipationGetPayload<
    S extends boolean | null | undefined | TournamentParticipationArgs,
    U = keyof S
      > = S extends true
        ? TournamentParticipation
    : S extends undefined
    ? never
    : S extends TournamentParticipationArgs | TournamentParticipationFindManyArgs
    ?'include' extends U
    ? TournamentParticipation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'team'
        ? TeamGetPayload<S['include'][P]> :
        P extends 'tournament'
        ? TournamentGetPayload<S['include'][P]> :
        P extends 'players'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'match'
        ? TournamentMatchGetPayload<S['include'][P]> | null :
        P extends 'TournamentGridElement'
        ? Array < TournamentGridElementGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TournamentParticipation ?TournamentParticipation [P]
  : 
          P extends 'team'
        ? TeamGetPayload<S['select'][P]> :
        P extends 'tournament'
        ? TournamentGetPayload<S['select'][P]> :
        P extends 'players'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'match'
        ? TournamentMatchGetPayload<S['select'][P]> | null :
        P extends 'TournamentGridElement'
        ? Array < TournamentGridElementGetPayload<S['select'][P]>>  : never
  } 
    : TournamentParticipation
  : TournamentParticipation


  type TournamentParticipationCountArgs = Merge<
    Omit<TournamentParticipationFindManyArgs, 'select' | 'include'> & {
      select?: TournamentParticipationCountAggregateInputType | true
    }
  >

  export interface TournamentParticipationDelegate {
    /**
     * Find zero or one TournamentParticipation that matches the filter.
     * @param {TournamentParticipationFindUniqueArgs} args - Arguments to find a TournamentParticipation
     * @example
     * // Get one TournamentParticipation
     * const tournamentParticipation = await prisma.tournamentParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentParticipationFindUniqueArgs>(
      args: SelectSubset<T, TournamentParticipationFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation | null>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T> | null>>

    /**
     * Find the first TournamentParticipation that matches the filter.
     * @param {TournamentParticipationFindFirstArgs} args - Arguments to find a TournamentParticipation
     * @example
     * // Get one TournamentParticipation
     * const tournamentParticipation = await prisma.tournamentParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentParticipationFindFirstArgs>(
      args?: SelectSubset<T, TournamentParticipationFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation | null>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T> | null>>

    /**
     * Find zero or more TournamentParticipations that matches the filter.
     * @param {TournamentParticipationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentParticipations
     * const tournamentParticipations = await prisma.tournamentParticipation.findMany()
     * 
     * // Get first 10 TournamentParticipations
     * const tournamentParticipations = await prisma.tournamentParticipation.findMany({ take: 10 })
     * 
     * // Only select the `placement`
     * const tournamentParticipationWithPlacementOnly = await prisma.tournamentParticipation.findMany({ select: { placement: true } })
     * 
    **/
    findMany<T extends TournamentParticipationFindManyArgs>(
      args?: SelectSubset<T, TournamentParticipationFindManyArgs>
    ): CheckSelect<T, Promise<Array<TournamentParticipation>>, Promise<Array<TournamentParticipationGetPayload<T>>>>

    /**
     * Create a TournamentParticipation.
     * @param {TournamentParticipationCreateArgs} args - Arguments to create a TournamentParticipation.
     * @example
     * // Create one TournamentParticipation
     * const TournamentParticipation = await prisma.tournamentParticipation.create({
     *   data: {
     *     // ... data to create a TournamentParticipation
     *   }
     * })
     * 
    **/
    create<T extends TournamentParticipationCreateArgs>(
      args: SelectSubset<T, TournamentParticipationCreateArgs>
    ): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T>>>

    /**
     * Delete a TournamentParticipation.
     * @param {TournamentParticipationDeleteArgs} args - Arguments to delete one TournamentParticipation.
     * @example
     * // Delete one TournamentParticipation
     * const TournamentParticipation = await prisma.tournamentParticipation.delete({
     *   where: {
     *     // ... filter to delete one TournamentParticipation
     *   }
     * })
     * 
    **/
    delete<T extends TournamentParticipationDeleteArgs>(
      args: SelectSubset<T, TournamentParticipationDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T>>>

    /**
     * Update one TournamentParticipation.
     * @param {TournamentParticipationUpdateArgs} args - Arguments to update one TournamentParticipation.
     * @example
     * // Update one TournamentParticipation
     * const tournamentParticipation = await prisma.tournamentParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentParticipationUpdateArgs>(
      args: SelectSubset<T, TournamentParticipationUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T>>>

    /**
     * Delete zero or more TournamentParticipations.
     * @param {TournamentParticipationDeleteManyArgs} args - Arguments to filter TournamentParticipations to delete.
     * @example
     * // Delete a few TournamentParticipations
     * const { count } = await prisma.tournamentParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentParticipationDeleteManyArgs>(
      args?: SelectSubset<T, TournamentParticipationDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TournamentParticipations.
     * @param {TournamentParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentParticipations
     * const tournamentParticipation = await prisma.tournamentParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentParticipationUpdateManyArgs>(
      args: SelectSubset<T, TournamentParticipationUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TournamentParticipation.
     * @param {TournamentParticipationUpsertArgs} args - Arguments to update or create a TournamentParticipation.
     * @example
     * // Update or create a TournamentParticipation
     * const tournamentParticipation = await prisma.tournamentParticipation.upsert({
     *   create: {
     *     // ... data to create a TournamentParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentParticipation we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentParticipationUpsertArgs>(
      args: SelectSubset<T, TournamentParticipationUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentParticipationClient<TournamentParticipation>, Prisma__TournamentParticipationClient<TournamentParticipationGetPayload<T>>>

    /**
     * Count the number of TournamentParticipations.
     * @param {TournamentParticipationCountArgs} args - Arguments to filter TournamentParticipations to count.
     * @example
     * // Count the number of TournamentParticipations
     * const count = await prisma.tournamentParticipation.count({
     *   where: {
     *     // ... the filter for the TournamentParticipations we want to count
     *   }
     * })
    **/
    count<T extends TournamentParticipationCountArgs>(
      args?: Subset<T, TournamentParticipationCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentParticipation.
     * @param {TournamentParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentParticipationAggregateArgs>(args: Subset<T, TournamentParticipationAggregateArgs>): Promise<GetTournamentParticipationAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentParticipationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    team<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>;

    tournament<T extends TournamentArgs = {}>(args?: Subset<T, TournamentArgs>): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>;

    players<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>;

    match<T extends TournamentMatchArgs = {}>(args?: Subset<T, TournamentMatchArgs>): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch | null>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T> | null>>;

    TournamentGridElement<T extends TournamentGridElementFindManyArgs = {}>(args?: Subset<T, TournamentGridElementFindManyArgs>): CheckSelect<T, Promise<Array<TournamentGridElement>>, Promise<Array<TournamentGridElementGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TournamentParticipation findUnique
   */
  export type TournamentParticipationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * Throw an Error if a TournamentParticipation can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentParticipation to fetch.
    **/
    where: TournamentParticipationWhereUniqueInput
  }


  /**
   * TournamentParticipation findFirst
   */
  export type TournamentParticipationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * Throw an Error if a TournamentParticipation can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentParticipation to fetch.
    **/
    where?: TournamentParticipationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentParticipations to fetch.
    **/
    orderBy?: Enumerable<TournamentParticipationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentParticipations.
    **/
    cursor?: TournamentParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipations.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TournamentParticipations.
    **/
    distinct?: Enumerable<TournamentParticipationScalarFieldEnum>
  }


  /**
   * TournamentParticipation findMany
   */
  export type TournamentParticipationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * Filter, which TournamentParticipations to fetch.
    **/
    where?: TournamentParticipationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentParticipations to fetch.
    **/
    orderBy?: Enumerable<TournamentParticipationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentParticipations.
    **/
    cursor?: TournamentParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipations.
    **/
    skip?: number
    distinct?: Enumerable<TournamentParticipationScalarFieldEnum>
  }


  /**
   * TournamentParticipation create
   */
  export type TournamentParticipationCreateArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * The data needed to create a TournamentParticipation.
    **/
    data: XOR<TournamentParticipationUncheckedCreateInput, TournamentParticipationCreateInput>
  }


  /**
   * TournamentParticipation update
   */
  export type TournamentParticipationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * The data needed to update a TournamentParticipation.
    **/
    data: XOR<TournamentParticipationUncheckedUpdateInput, TournamentParticipationUpdateInput>
    /**
     * Choose, which TournamentParticipation to update.
    **/
    where: TournamentParticipationWhereUniqueInput
  }


  /**
   * TournamentParticipation updateMany
   */
  export type TournamentParticipationUpdateManyArgs = {
    data: XOR<TournamentParticipationUncheckedUpdateManyInput, TournamentParticipationUpdateManyMutationInput>
    where?: TournamentParticipationWhereInput
  }


  /**
   * TournamentParticipation upsert
   */
  export type TournamentParticipationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * The filter to search for the TournamentParticipation to update in case it exists.
    **/
    where: TournamentParticipationWhereUniqueInput
    /**
     * In case the TournamentParticipation found by the `where` argument doesn't exist, create a new TournamentParticipation with this data.
    **/
    create: XOR<TournamentParticipationUncheckedCreateInput, TournamentParticipationCreateInput>
    /**
     * In case the TournamentParticipation was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentParticipationUncheckedUpdateInput, TournamentParticipationUpdateInput>
  }


  /**
   * TournamentParticipation delete
   */
  export type TournamentParticipationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
    /**
     * Filter which TournamentParticipation to delete.
    **/
    where: TournamentParticipationWhereUniqueInput
  }


  /**
   * TournamentParticipation deleteMany
   */
  export type TournamentParticipationDeleteManyArgs = {
    where?: TournamentParticipationWhereInput
  }


  /**
   * TournamentParticipation without action
   */
  export type TournamentParticipationArgs = {
    /**
     * Select specific fields to fetch from the TournamentParticipation
    **/
    select?: TournamentParticipationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentParticipationInclude | null
  }



  /**
   * Model TeamMembership
   */


  export type AggregateTeamMembership = {
    count: TeamMembershipCountAggregateOutputType | null
    avg: TeamMembershipAvgAggregateOutputType | null
    sum: TeamMembershipSumAggregateOutputType | null
    min: TeamMembershipMinAggregateOutputType | null
    max: TeamMembershipMaxAggregateOutputType | null
  }

  export type TeamMembershipAvgAggregateOutputType = {
    userId: number
  }

  export type TeamMembershipSumAggregateOutputType = {
    userId: number
  }

  export type TeamMembershipMinAggregateOutputType = {
    role: TeamRoleType | null
    invitedAt: Date | null
    joinedAt: Date | null
    userId: number
    teamId: string | null
  }

  export type TeamMembershipMaxAggregateOutputType = {
    role: TeamRoleType | null
    invitedAt: Date | null
    joinedAt: Date | null
    userId: number
    teamId: string | null
  }

  export type TeamMembershipCountAggregateOutputType = {
    role: number | null
    invitedAt: number | null
    joinedAt: number | null
    userId: number
    teamId: number | null
    _all: number
  }


  export type TeamMembershipAvgAggregateInputType = {
    userId?: true
  }

  export type TeamMembershipSumAggregateInputType = {
    userId?: true
  }

  export type TeamMembershipMinAggregateInputType = {
    role?: true
    invitedAt?: true
    joinedAt?: true
    userId?: true
    teamId?: true
  }

  export type TeamMembershipMaxAggregateInputType = {
    role?: true
    invitedAt?: true
    joinedAt?: true
    userId?: true
    teamId?: true
  }

  export type TeamMembershipCountAggregateInputType = {
    role?: true
    invitedAt?: true
    joinedAt?: true
    userId?: true
    teamId?: true
    _all?: true
  }

  export type TeamMembershipAggregateArgs = {
    /**
     * Filter which TeamMembership to aggregate.
    **/
    where?: TeamMembershipWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TeamMemberships to fetch.
    **/
    orderBy?: Enumerable<TeamMembershipOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMemberships
    **/
    count?: true | TeamMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TeamMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TeamMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TeamMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TeamMembershipMaxAggregateInputType
  }

  export type GetTeamMembershipAggregateType<T extends TeamMembershipAggregateArgs> = {
    [P in keyof T & keyof AggregateTeamMembership]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMembership[P]>
      : GetScalarType<T[P], AggregateTeamMembership[P]>
  }



  export type TeamMembershipSelect = {
    user?: boolean | UserArgs
    team?: boolean | TeamArgs
    role?: boolean
    invitedAt?: boolean
    joinedAt?: boolean
    userId?: boolean
    teamId?: boolean
  }

  export type TeamMembershipInclude = {
    user?: boolean | UserArgs
    team?: boolean | TeamArgs
  }

  export type TeamMembershipGetPayload<
    S extends boolean | null | undefined | TeamMembershipArgs,
    U = keyof S
      > = S extends true
        ? TeamMembership
    : S extends undefined
    ? never
    : S extends TeamMembershipArgs | TeamMembershipFindManyArgs
    ?'include' extends U
    ? TeamMembership  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'team'
        ? TeamGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TeamMembership ?TeamMembership [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'team'
        ? TeamGetPayload<S['select'][P]> : never
  } 
    : TeamMembership
  : TeamMembership


  type TeamMembershipCountArgs = Merge<
    Omit<TeamMembershipFindManyArgs, 'select' | 'include'> & {
      select?: TeamMembershipCountAggregateInputType | true
    }
  >

  export interface TeamMembershipDelegate {
    /**
     * Find zero or one TeamMembership that matches the filter.
     * @param {TeamMembershipFindUniqueArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamMembershipFindUniqueArgs>(
      args: SelectSubset<T, TeamMembershipFindUniqueArgs>
    ): CheckSelect<T, Prisma__TeamMembershipClient<TeamMembership | null>, Prisma__TeamMembershipClient<TeamMembershipGetPayload<T> | null>>

    /**
     * Find the first TeamMembership that matches the filter.
     * @param {TeamMembershipFindFirstArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamMembershipFindFirstArgs>(
      args?: SelectSubset<T, TeamMembershipFindFirstArgs>
    ): CheckSelect<T, Prisma__TeamMembershipClient<TeamMembership | null>, Prisma__TeamMembershipClient<TeamMembershipGetPayload<T> | null>>

    /**
     * Find zero or more TeamMemberships that matches the filter.
     * @param {TeamMembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMemberships
     * const teamMemberships = await prisma.teamMembership.findMany()
     * 
     * // Get first 10 TeamMemberships
     * const teamMemberships = await prisma.teamMembership.findMany({ take: 10 })
     * 
     * // Only select the `invitedAt`
     * const teamMembershipWithInvitedAtOnly = await prisma.teamMembership.findMany({ select: { invitedAt: true } })
     * 
    **/
    findMany<T extends TeamMembershipFindManyArgs>(
      args?: SelectSubset<T, TeamMembershipFindManyArgs>
    ): CheckSelect<T, Promise<Array<TeamMembership>>, Promise<Array<TeamMembershipGetPayload<T>>>>

    /**
     * Create a TeamMembership.
     * @param {TeamMembershipCreateArgs} args - Arguments to create a TeamMembership.
     * @example
     * // Create one TeamMembership
     * const TeamMembership = await prisma.teamMembership.create({
     *   data: {
     *     // ... data to create a TeamMembership
     *   }
     * })
     * 
    **/
    create<T extends TeamMembershipCreateArgs>(
      args: SelectSubset<T, TeamMembershipCreateArgs>
    ): CheckSelect<T, Prisma__TeamMembershipClient<TeamMembership>, Prisma__TeamMembershipClient<TeamMembershipGetPayload<T>>>

    /**
     * Delete a TeamMembership.
     * @param {TeamMembershipDeleteArgs} args - Arguments to delete one TeamMembership.
     * @example
     * // Delete one TeamMembership
     * const TeamMembership = await prisma.teamMembership.delete({
     *   where: {
     *     // ... filter to delete one TeamMembership
     *   }
     * })
     * 
    **/
    delete<T extends TeamMembershipDeleteArgs>(
      args: SelectSubset<T, TeamMembershipDeleteArgs>
    ): CheckSelect<T, Prisma__TeamMembershipClient<TeamMembership>, Prisma__TeamMembershipClient<TeamMembershipGetPayload<T>>>

    /**
     * Update one TeamMembership.
     * @param {TeamMembershipUpdateArgs} args - Arguments to update one TeamMembership.
     * @example
     * // Update one TeamMembership
     * const teamMembership = await prisma.teamMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamMembershipUpdateArgs>(
      args: SelectSubset<T, TeamMembershipUpdateArgs>
    ): CheckSelect<T, Prisma__TeamMembershipClient<TeamMembership>, Prisma__TeamMembershipClient<TeamMembershipGetPayload<T>>>

    /**
     * Delete zero or more TeamMemberships.
     * @param {TeamMembershipDeleteManyArgs} args - Arguments to filter TeamMemberships to delete.
     * @example
     * // Delete a few TeamMemberships
     * const { count } = await prisma.teamMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamMembershipDeleteManyArgs>(
      args?: SelectSubset<T, TeamMembershipDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TeamMemberships.
     * @param {TeamMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMemberships
     * const teamMembership = await prisma.teamMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamMembershipUpdateManyArgs>(
      args: SelectSubset<T, TeamMembershipUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TeamMembership.
     * @param {TeamMembershipUpsertArgs} args - Arguments to update or create a TeamMembership.
     * @example
     * // Update or create a TeamMembership
     * const teamMembership = await prisma.teamMembership.upsert({
     *   create: {
     *     // ... data to create a TeamMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMembership we want to update
     *   }
     * })
    **/
    upsert<T extends TeamMembershipUpsertArgs>(
      args: SelectSubset<T, TeamMembershipUpsertArgs>
    ): CheckSelect<T, Prisma__TeamMembershipClient<TeamMembership>, Prisma__TeamMembershipClient<TeamMembershipGetPayload<T>>>

    /**
     * Count the number of TeamMemberships.
     * @param {TeamMembershipCountArgs} args - Arguments to filter TeamMemberships to count.
     * @example
     * // Count the number of TeamMemberships
     * const count = await prisma.teamMembership.count({
     *   where: {
     *     // ... the filter for the TeamMemberships we want to count
     *   }
     * })
    **/
    count<T extends TeamMembershipCountArgs>(
      args?: Subset<T, TeamMembershipCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMembership.
     * @param {TeamMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMembershipAggregateArgs>(args: Subset<T, TeamMembershipAggregateArgs>): Promise<GetTeamMembershipAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamMembershipClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    team<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TeamMembership findUnique
   */
  export type TeamMembershipFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * Throw an Error if a TeamMembership can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamMembership to fetch.
    **/
    where: TeamMembershipWhereUniqueInput
  }


  /**
   * TeamMembership findFirst
   */
  export type TeamMembershipFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * Throw an Error if a TeamMembership can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamMembership to fetch.
    **/
    where?: TeamMembershipWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TeamMemberships to fetch.
    **/
    orderBy?: Enumerable<TeamMembershipOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMemberships.
    **/
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TeamMemberships.
    **/
    distinct?: Enumerable<TeamMembershipScalarFieldEnum>
  }


  /**
   * TeamMembership findMany
   */
  export type TeamMembershipFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * Filter, which TeamMemberships to fetch.
    **/
    where?: TeamMembershipWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TeamMemberships to fetch.
    **/
    orderBy?: Enumerable<TeamMembershipOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMemberships.
    **/
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
    **/
    skip?: number
    distinct?: Enumerable<TeamMembershipScalarFieldEnum>
  }


  /**
   * TeamMembership create
   */
  export type TeamMembershipCreateArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * The data needed to create a TeamMembership.
    **/
    data: XOR<TeamMembershipUncheckedCreateInput, TeamMembershipCreateInput>
  }


  /**
   * TeamMembership update
   */
  export type TeamMembershipUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * The data needed to update a TeamMembership.
    **/
    data: XOR<TeamMembershipUncheckedUpdateInput, TeamMembershipUpdateInput>
    /**
     * Choose, which TeamMembership to update.
    **/
    where: TeamMembershipWhereUniqueInput
  }


  /**
   * TeamMembership updateMany
   */
  export type TeamMembershipUpdateManyArgs = {
    data: XOR<TeamMembershipUncheckedUpdateManyInput, TeamMembershipUpdateManyMutationInput>
    where?: TeamMembershipWhereInput
  }


  /**
   * TeamMembership upsert
   */
  export type TeamMembershipUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * The filter to search for the TeamMembership to update in case it exists.
    **/
    where: TeamMembershipWhereUniqueInput
    /**
     * In case the TeamMembership found by the `where` argument doesn't exist, create a new TeamMembership with this data.
    **/
    create: XOR<TeamMembershipUncheckedCreateInput, TeamMembershipCreateInput>
    /**
     * In case the TeamMembership was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TeamMembershipUncheckedUpdateInput, TeamMembershipUpdateInput>
  }


  /**
   * TeamMembership delete
   */
  export type TeamMembershipDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
    /**
     * Filter which TeamMembership to delete.
    **/
    where: TeamMembershipWhereUniqueInput
  }


  /**
   * TeamMembership deleteMany
   */
  export type TeamMembershipDeleteManyArgs = {
    where?: TeamMembershipWhereInput
  }


  /**
   * TeamMembership without action
   */
  export type TeamMembershipArgs = {
    /**
     * Select specific fields to fetch from the TeamMembership
    **/
    select?: TeamMembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamMembershipInclude | null
  }



  /**
   * Model TeamInvitation
   */


  export type AggregateTeamInvitation = {
    count: TeamInvitationCountAggregateOutputType | null
    avg: TeamInvitationAvgAggregateOutputType | null
    sum: TeamInvitationSumAggregateOutputType | null
    min: TeamInvitationMinAggregateOutputType | null
    max: TeamInvitationMaxAggregateOutputType | null
  }

  export type TeamInvitationAvgAggregateOutputType = {
    userId: number
  }

  export type TeamInvitationSumAggregateOutputType = {
    userId: number
  }

  export type TeamInvitationMinAggregateOutputType = {
    invitedAt: Date | null
    userId: number
    teamId: string | null
  }

  export type TeamInvitationMaxAggregateOutputType = {
    invitedAt: Date | null
    userId: number
    teamId: string | null
  }

  export type TeamInvitationCountAggregateOutputType = {
    invitedAt: number | null
    userId: number
    teamId: number | null
    _all: number
  }


  export type TeamInvitationAvgAggregateInputType = {
    userId?: true
  }

  export type TeamInvitationSumAggregateInputType = {
    userId?: true
  }

  export type TeamInvitationMinAggregateInputType = {
    invitedAt?: true
    userId?: true
    teamId?: true
  }

  export type TeamInvitationMaxAggregateInputType = {
    invitedAt?: true
    userId?: true
    teamId?: true
  }

  export type TeamInvitationCountAggregateInputType = {
    invitedAt?: true
    userId?: true
    teamId?: true
    _all?: true
  }

  export type TeamInvitationAggregateArgs = {
    /**
     * Filter which TeamInvitation to aggregate.
    **/
    where?: TeamInvitationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TeamInvitations to fetch.
    **/
    orderBy?: Enumerable<TeamInvitationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamInvitations
    **/
    count?: true | TeamInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TeamInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TeamInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TeamInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TeamInvitationMaxAggregateInputType
  }

  export type GetTeamInvitationAggregateType<T extends TeamInvitationAggregateArgs> = {
    [P in keyof T & keyof AggregateTeamInvitation]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamInvitation[P]>
      : GetScalarType<T[P], AggregateTeamInvitation[P]>
  }



  export type TeamInvitationSelect = {
    user?: boolean | UserArgs
    team?: boolean | TeamArgs
    invitedAt?: boolean
    userId?: boolean
    teamId?: boolean
  }

  export type TeamInvitationInclude = {
    user?: boolean | UserArgs
    team?: boolean | TeamArgs
  }

  export type TeamInvitationGetPayload<
    S extends boolean | null | undefined | TeamInvitationArgs,
    U = keyof S
      > = S extends true
        ? TeamInvitation
    : S extends undefined
    ? never
    : S extends TeamInvitationArgs | TeamInvitationFindManyArgs
    ?'include' extends U
    ? TeamInvitation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'team'
        ? TeamGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TeamInvitation ?TeamInvitation [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'team'
        ? TeamGetPayload<S['select'][P]> : never
  } 
    : TeamInvitation
  : TeamInvitation


  type TeamInvitationCountArgs = Merge<
    Omit<TeamInvitationFindManyArgs, 'select' | 'include'> & {
      select?: TeamInvitationCountAggregateInputType | true
    }
  >

  export interface TeamInvitationDelegate {
    /**
     * Find zero or one TeamInvitation that matches the filter.
     * @param {TeamInvitationFindUniqueArgs} args - Arguments to find a TeamInvitation
     * @example
     * // Get one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamInvitationFindUniqueArgs>(
      args: SelectSubset<T, TeamInvitationFindUniqueArgs>
    ): CheckSelect<T, Prisma__TeamInvitationClient<TeamInvitation | null>, Prisma__TeamInvitationClient<TeamInvitationGetPayload<T> | null>>

    /**
     * Find the first TeamInvitation that matches the filter.
     * @param {TeamInvitationFindFirstArgs} args - Arguments to find a TeamInvitation
     * @example
     * // Get one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamInvitationFindFirstArgs>(
      args?: SelectSubset<T, TeamInvitationFindFirstArgs>
    ): CheckSelect<T, Prisma__TeamInvitationClient<TeamInvitation | null>, Prisma__TeamInvitationClient<TeamInvitationGetPayload<T> | null>>

    /**
     * Find zero or more TeamInvitations that matches the filter.
     * @param {TeamInvitationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamInvitations
     * const teamInvitations = await prisma.teamInvitation.findMany()
     * 
     * // Get first 10 TeamInvitations
     * const teamInvitations = await prisma.teamInvitation.findMany({ take: 10 })
     * 
     * // Only select the `invitedAt`
     * const teamInvitationWithInvitedAtOnly = await prisma.teamInvitation.findMany({ select: { invitedAt: true } })
     * 
    **/
    findMany<T extends TeamInvitationFindManyArgs>(
      args?: SelectSubset<T, TeamInvitationFindManyArgs>
    ): CheckSelect<T, Promise<Array<TeamInvitation>>, Promise<Array<TeamInvitationGetPayload<T>>>>

    /**
     * Create a TeamInvitation.
     * @param {TeamInvitationCreateArgs} args - Arguments to create a TeamInvitation.
     * @example
     * // Create one TeamInvitation
     * const TeamInvitation = await prisma.teamInvitation.create({
     *   data: {
     *     // ... data to create a TeamInvitation
     *   }
     * })
     * 
    **/
    create<T extends TeamInvitationCreateArgs>(
      args: SelectSubset<T, TeamInvitationCreateArgs>
    ): CheckSelect<T, Prisma__TeamInvitationClient<TeamInvitation>, Prisma__TeamInvitationClient<TeamInvitationGetPayload<T>>>

    /**
     * Delete a TeamInvitation.
     * @param {TeamInvitationDeleteArgs} args - Arguments to delete one TeamInvitation.
     * @example
     * // Delete one TeamInvitation
     * const TeamInvitation = await prisma.teamInvitation.delete({
     *   where: {
     *     // ... filter to delete one TeamInvitation
     *   }
     * })
     * 
    **/
    delete<T extends TeamInvitationDeleteArgs>(
      args: SelectSubset<T, TeamInvitationDeleteArgs>
    ): CheckSelect<T, Prisma__TeamInvitationClient<TeamInvitation>, Prisma__TeamInvitationClient<TeamInvitationGetPayload<T>>>

    /**
     * Update one TeamInvitation.
     * @param {TeamInvitationUpdateArgs} args - Arguments to update one TeamInvitation.
     * @example
     * // Update one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamInvitationUpdateArgs>(
      args: SelectSubset<T, TeamInvitationUpdateArgs>
    ): CheckSelect<T, Prisma__TeamInvitationClient<TeamInvitation>, Prisma__TeamInvitationClient<TeamInvitationGetPayload<T>>>

    /**
     * Delete zero or more TeamInvitations.
     * @param {TeamInvitationDeleteManyArgs} args - Arguments to filter TeamInvitations to delete.
     * @example
     * // Delete a few TeamInvitations
     * const { count } = await prisma.teamInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamInvitationDeleteManyArgs>(
      args?: SelectSubset<T, TeamInvitationDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TeamInvitations.
     * @param {TeamInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamInvitations
     * const teamInvitation = await prisma.teamInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamInvitationUpdateManyArgs>(
      args: SelectSubset<T, TeamInvitationUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TeamInvitation.
     * @param {TeamInvitationUpsertArgs} args - Arguments to update or create a TeamInvitation.
     * @example
     * // Update or create a TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.upsert({
     *   create: {
     *     // ... data to create a TeamInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamInvitation we want to update
     *   }
     * })
    **/
    upsert<T extends TeamInvitationUpsertArgs>(
      args: SelectSubset<T, TeamInvitationUpsertArgs>
    ): CheckSelect<T, Prisma__TeamInvitationClient<TeamInvitation>, Prisma__TeamInvitationClient<TeamInvitationGetPayload<T>>>

    /**
     * Count the number of TeamInvitations.
     * @param {TeamInvitationCountArgs} args - Arguments to filter TeamInvitations to count.
     * @example
     * // Count the number of TeamInvitations
     * const count = await prisma.teamInvitation.count({
     *   where: {
     *     // ... the filter for the TeamInvitations we want to count
     *   }
     * })
    **/
    count<T extends TeamInvitationCountArgs>(
      args?: Subset<T, TeamInvitationCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamInvitation.
     * @param {TeamInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamInvitationAggregateArgs>(args: Subset<T, TeamInvitationAggregateArgs>): Promise<GetTeamInvitationAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamInvitationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    team<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TeamInvitation findUnique
   */
  export type TeamInvitationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * Throw an Error if a TeamInvitation can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamInvitation to fetch.
    **/
    where: TeamInvitationWhereUniqueInput
  }


  /**
   * TeamInvitation findFirst
   */
  export type TeamInvitationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * Throw an Error if a TeamInvitation can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamInvitation to fetch.
    **/
    where?: TeamInvitationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TeamInvitations to fetch.
    **/
    orderBy?: Enumerable<TeamInvitationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInvitations.
    **/
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TeamInvitations.
    **/
    distinct?: Enumerable<TeamInvitationScalarFieldEnum>
  }


  /**
   * TeamInvitation findMany
   */
  export type TeamInvitationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * Filter, which TeamInvitations to fetch.
    **/
    where?: TeamInvitationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TeamInvitations to fetch.
    **/
    orderBy?: Enumerable<TeamInvitationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamInvitations.
    **/
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
    **/
    skip?: number
    distinct?: Enumerable<TeamInvitationScalarFieldEnum>
  }


  /**
   * TeamInvitation create
   */
  export type TeamInvitationCreateArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * The data needed to create a TeamInvitation.
    **/
    data: XOR<TeamInvitationUncheckedCreateInput, TeamInvitationCreateInput>
  }


  /**
   * TeamInvitation update
   */
  export type TeamInvitationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * The data needed to update a TeamInvitation.
    **/
    data: XOR<TeamInvitationUncheckedUpdateInput, TeamInvitationUpdateInput>
    /**
     * Choose, which TeamInvitation to update.
    **/
    where: TeamInvitationWhereUniqueInput
  }


  /**
   * TeamInvitation updateMany
   */
  export type TeamInvitationUpdateManyArgs = {
    data: XOR<TeamInvitationUncheckedUpdateManyInput, TeamInvitationUpdateManyMutationInput>
    where?: TeamInvitationWhereInput
  }


  /**
   * TeamInvitation upsert
   */
  export type TeamInvitationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * The filter to search for the TeamInvitation to update in case it exists.
    **/
    where: TeamInvitationWhereUniqueInput
    /**
     * In case the TeamInvitation found by the `where` argument doesn't exist, create a new TeamInvitation with this data.
    **/
    create: XOR<TeamInvitationUncheckedCreateInput, TeamInvitationCreateInput>
    /**
     * In case the TeamInvitation was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TeamInvitationUncheckedUpdateInput, TeamInvitationUpdateInput>
  }


  /**
   * TeamInvitation delete
   */
  export type TeamInvitationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
    /**
     * Filter which TeamInvitation to delete.
    **/
    where: TeamInvitationWhereUniqueInput
  }


  /**
   * TeamInvitation deleteMany
   */
  export type TeamInvitationDeleteManyArgs = {
    where?: TeamInvitationWhereInput
  }


  /**
   * TeamInvitation without action
   */
  export type TeamInvitationArgs = {
    /**
     * Select specific fields to fetch from the TeamInvitation
    **/
    select?: TeamInvitationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInvitationInclude | null
  }



  /**
   * Model TournamentMatchState
   */


  export type AggregateTournamentMatchState = {
    count: TournamentMatchStateCountAggregateOutputType | null
    avg: TournamentMatchStateAvgAggregateOutputType | null
    sum: TournamentMatchStateSumAggregateOutputType | null
    min: TournamentMatchStateMinAggregateOutputType | null
    max: TournamentMatchStateMaxAggregateOutputType | null
  }

  export type TournamentMatchStateAvgAggregateOutputType = {
    id: number
    matchId: number
  }

  export type TournamentMatchStateSumAggregateOutputType = {
    id: number
    matchId: number
  }

  export type TournamentMatchStateMinAggregateOutputType = {
    id: number
    state: JsonValue | null
    createdAt: Date | null
    accepted: boolean | null
    matchId: number
  }

  export type TournamentMatchStateMaxAggregateOutputType = {
    id: number
    state: JsonValue | null
    createdAt: Date | null
    accepted: boolean | null
    matchId: number
  }

  export type TournamentMatchStateCountAggregateOutputType = {
    id: number
    state: number | null
    createdAt: number | null
    accepted: number | null
    matchId: number
    _all: number
  }


  export type TournamentMatchStateAvgAggregateInputType = {
    id?: true
    matchId?: true
  }

  export type TournamentMatchStateSumAggregateInputType = {
    id?: true
    matchId?: true
  }

  export type TournamentMatchStateMinAggregateInputType = {
    id?: true
    state?: true
    createdAt?: true
    accepted?: true
    matchId?: true
  }

  export type TournamentMatchStateMaxAggregateInputType = {
    id?: true
    state?: true
    createdAt?: true
    accepted?: true
    matchId?: true
  }

  export type TournamentMatchStateCountAggregateInputType = {
    id?: true
    state?: true
    createdAt?: true
    accepted?: true
    matchId?: true
    _all?: true
  }

  export type TournamentMatchStateAggregateArgs = {
    /**
     * Filter which TournamentMatchState to aggregate.
    **/
    where?: TournamentMatchStateWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatchStates to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchStateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentMatchStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatchStates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatchStates.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentMatchStates
    **/
    count?: true | TournamentMatchStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentMatchStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentMatchStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentMatchStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentMatchStateMaxAggregateInputType
  }

  export type GetTournamentMatchStateAggregateType<T extends TournamentMatchStateAggregateArgs> = {
    [P in keyof T & keyof AggregateTournamentMatchState]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentMatchState[P]>
      : GetScalarType<T[P], AggregateTournamentMatchState[P]>
  }



  export type TournamentMatchStateSelect = {
    id?: boolean
    state?: boolean
    createdAt?: boolean
    acceptedBy?: boolean | UserFindManyArgs
    match?: boolean | TournamentMatchArgs
    accepted?: boolean
    matchId?: boolean
  }

  export type TournamentMatchStateInclude = {
    acceptedBy?: boolean | UserFindManyArgs
    match?: boolean | TournamentMatchArgs
  }

  export type TournamentMatchStateGetPayload<
    S extends boolean | null | undefined | TournamentMatchStateArgs,
    U = keyof S
      > = S extends true
        ? TournamentMatchState
    : S extends undefined
    ? never
    : S extends TournamentMatchStateArgs | TournamentMatchStateFindManyArgs
    ?'include' extends U
    ? TournamentMatchState  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'acceptedBy'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'match'
        ? TournamentMatchGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TournamentMatchState ?TournamentMatchState [P]
  : 
          P extends 'acceptedBy'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'match'
        ? TournamentMatchGetPayload<S['select'][P]> : never
  } 
    : TournamentMatchState
  : TournamentMatchState


  type TournamentMatchStateCountArgs = Merge<
    Omit<TournamentMatchStateFindManyArgs, 'select' | 'include'> & {
      select?: TournamentMatchStateCountAggregateInputType | true
    }
  >

  export interface TournamentMatchStateDelegate {
    /**
     * Find zero or one TournamentMatchState that matches the filter.
     * @param {TournamentMatchStateFindUniqueArgs} args - Arguments to find a TournamentMatchState
     * @example
     * // Get one TournamentMatchState
     * const tournamentMatchState = await prisma.tournamentMatchState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentMatchStateFindUniqueArgs>(
      args: SelectSubset<T, TournamentMatchStateFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState | null>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T> | null>>

    /**
     * Find the first TournamentMatchState that matches the filter.
     * @param {TournamentMatchStateFindFirstArgs} args - Arguments to find a TournamentMatchState
     * @example
     * // Get one TournamentMatchState
     * const tournamentMatchState = await prisma.tournamentMatchState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentMatchStateFindFirstArgs>(
      args?: SelectSubset<T, TournamentMatchStateFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState | null>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T> | null>>

    /**
     * Find zero or more TournamentMatchStates that matches the filter.
     * @param {TournamentMatchStateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentMatchStates
     * const tournamentMatchStates = await prisma.tournamentMatchState.findMany()
     * 
     * // Get first 10 TournamentMatchStates
     * const tournamentMatchStates = await prisma.tournamentMatchState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentMatchStateWithIdOnly = await prisma.tournamentMatchState.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TournamentMatchStateFindManyArgs>(
      args?: SelectSubset<T, TournamentMatchStateFindManyArgs>
    ): CheckSelect<T, Promise<Array<TournamentMatchState>>, Promise<Array<TournamentMatchStateGetPayload<T>>>>

    /**
     * Create a TournamentMatchState.
     * @param {TournamentMatchStateCreateArgs} args - Arguments to create a TournamentMatchState.
     * @example
     * // Create one TournamentMatchState
     * const TournamentMatchState = await prisma.tournamentMatchState.create({
     *   data: {
     *     // ... data to create a TournamentMatchState
     *   }
     * })
     * 
    **/
    create<T extends TournamentMatchStateCreateArgs>(
      args: SelectSubset<T, TournamentMatchStateCreateArgs>
    ): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T>>>

    /**
     * Delete a TournamentMatchState.
     * @param {TournamentMatchStateDeleteArgs} args - Arguments to delete one TournamentMatchState.
     * @example
     * // Delete one TournamentMatchState
     * const TournamentMatchState = await prisma.tournamentMatchState.delete({
     *   where: {
     *     // ... filter to delete one TournamentMatchState
     *   }
     * })
     * 
    **/
    delete<T extends TournamentMatchStateDeleteArgs>(
      args: SelectSubset<T, TournamentMatchStateDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T>>>

    /**
     * Update one TournamentMatchState.
     * @param {TournamentMatchStateUpdateArgs} args - Arguments to update one TournamentMatchState.
     * @example
     * // Update one TournamentMatchState
     * const tournamentMatchState = await prisma.tournamentMatchState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentMatchStateUpdateArgs>(
      args: SelectSubset<T, TournamentMatchStateUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T>>>

    /**
     * Delete zero or more TournamentMatchStates.
     * @param {TournamentMatchStateDeleteManyArgs} args - Arguments to filter TournamentMatchStates to delete.
     * @example
     * // Delete a few TournamentMatchStates
     * const { count } = await prisma.tournamentMatchState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentMatchStateDeleteManyArgs>(
      args?: SelectSubset<T, TournamentMatchStateDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TournamentMatchStates.
     * @param {TournamentMatchStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentMatchStates
     * const tournamentMatchState = await prisma.tournamentMatchState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentMatchStateUpdateManyArgs>(
      args: SelectSubset<T, TournamentMatchStateUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TournamentMatchState.
     * @param {TournamentMatchStateUpsertArgs} args - Arguments to update or create a TournamentMatchState.
     * @example
     * // Update or create a TournamentMatchState
     * const tournamentMatchState = await prisma.tournamentMatchState.upsert({
     *   create: {
     *     // ... data to create a TournamentMatchState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentMatchState we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentMatchStateUpsertArgs>(
      args: SelectSubset<T, TournamentMatchStateUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentMatchStateClient<TournamentMatchState>, Prisma__TournamentMatchStateClient<TournamentMatchStateGetPayload<T>>>

    /**
     * Count the number of TournamentMatchStates.
     * @param {TournamentMatchStateCountArgs} args - Arguments to filter TournamentMatchStates to count.
     * @example
     * // Count the number of TournamentMatchStates
     * const count = await prisma.tournamentMatchState.count({
     *   where: {
     *     // ... the filter for the TournamentMatchStates we want to count
     *   }
     * })
    **/
    count<T extends TournamentMatchStateCountArgs>(
      args?: Subset<T, TournamentMatchStateCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentMatchStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentMatchState.
     * @param {TournamentMatchStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentMatchStateAggregateArgs>(args: Subset<T, TournamentMatchStateAggregateArgs>): Promise<GetTournamentMatchStateAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentMatchState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentMatchStateClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    acceptedBy<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>;

    match<T extends TournamentMatchArgs = {}>(args?: Subset<T, TournamentMatchArgs>): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch | null>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TournamentMatchState findUnique
   */
  export type TournamentMatchStateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * Throw an Error if a TournamentMatchState can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentMatchState to fetch.
    **/
    where: TournamentMatchStateWhereUniqueInput
  }


  /**
   * TournamentMatchState findFirst
   */
  export type TournamentMatchStateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * Throw an Error if a TournamentMatchState can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentMatchState to fetch.
    **/
    where?: TournamentMatchStateWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatchStates to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchStateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentMatchStates.
    **/
    cursor?: TournamentMatchStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatchStates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatchStates.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TournamentMatchStates.
    **/
    distinct?: Enumerable<TournamentMatchStateScalarFieldEnum>
  }


  /**
   * TournamentMatchState findMany
   */
  export type TournamentMatchStateFindManyArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * Filter, which TournamentMatchStates to fetch.
    **/
    where?: TournamentMatchStateWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatchStates to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchStateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentMatchStates.
    **/
    cursor?: TournamentMatchStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatchStates from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatchStates.
    **/
    skip?: number
    distinct?: Enumerable<TournamentMatchStateScalarFieldEnum>
  }


  /**
   * TournamentMatchState create
   */
  export type TournamentMatchStateCreateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * The data needed to create a TournamentMatchState.
    **/
    data: XOR<TournamentMatchStateUncheckedCreateInput, TournamentMatchStateCreateInput>
  }


  /**
   * TournamentMatchState update
   */
  export type TournamentMatchStateUpdateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * The data needed to update a TournamentMatchState.
    **/
    data: XOR<TournamentMatchStateUncheckedUpdateInput, TournamentMatchStateUpdateInput>
    /**
     * Choose, which TournamentMatchState to update.
    **/
    where: TournamentMatchStateWhereUniqueInput
  }


  /**
   * TournamentMatchState updateMany
   */
  export type TournamentMatchStateUpdateManyArgs = {
    data: XOR<TournamentMatchStateUncheckedUpdateManyInput, TournamentMatchStateUpdateManyMutationInput>
    where?: TournamentMatchStateWhereInput
  }


  /**
   * TournamentMatchState upsert
   */
  export type TournamentMatchStateUpsertArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * The filter to search for the TournamentMatchState to update in case it exists.
    **/
    where: TournamentMatchStateWhereUniqueInput
    /**
     * In case the TournamentMatchState found by the `where` argument doesn't exist, create a new TournamentMatchState with this data.
    **/
    create: XOR<TournamentMatchStateUncheckedCreateInput, TournamentMatchStateCreateInput>
    /**
     * In case the TournamentMatchState was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentMatchStateUncheckedUpdateInput, TournamentMatchStateUpdateInput>
  }


  /**
   * TournamentMatchState delete
   */
  export type TournamentMatchStateDeleteArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
    /**
     * Filter which TournamentMatchState to delete.
    **/
    where: TournamentMatchStateWhereUniqueInput
  }


  /**
   * TournamentMatchState deleteMany
   */
  export type TournamentMatchStateDeleteManyArgs = {
    where?: TournamentMatchStateWhereInput
  }


  /**
   * TournamentMatchState without action
   */
  export type TournamentMatchStateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchState
    **/
    select?: TournamentMatchStateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchStateInclude | null
  }



  /**
   * Model Team
   */


  export type AggregateTeam = {
    count: TeamCountAggregateOutputType | null
    avg: TeamAvgAggregateOutputType | null
    sum: TeamSumAggregateOutputType | null
    min: TeamMinAggregateOutputType | null
    max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    imageId: number | null
  }

  export type TeamSumAggregateOutputType = {
    imageId: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    updatedAt: Date | null
    createdAt: Date | null
    imageId: number | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    updatedAt: Date | null
    createdAt: Date | null
    imageId: number | null
  }

  export type TeamCountAggregateOutputType = {
    id: number | null
    name: number | null
    updatedAt: number | null
    createdAt: number | null
    imageId: number | null
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    imageId?: true
  }

  export type TeamSumAggregateInputType = {
    imageId?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    updatedAt?: true
    createdAt?: true
    imageId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    updatedAt?: true
    createdAt?: true
    imageId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    updatedAt?: true
    createdAt?: true
    imageId?: true
    _all?: true
  }

  export type TeamAggregateArgs = {
    /**
     * Filter which Team to aggregate.
    **/
    where?: TeamWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Teams to fetch.
    **/
    orderBy?: Enumerable<TeamOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
    [P in keyof T & keyof AggregateTeam]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }



  export type TeamSelect = {
    id?: boolean
    name?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    icon?: boolean | ImageArgs
    members?: boolean | TeamMembershipFindManyArgs
    Tournament?: boolean | TournamentFindManyArgs
    TournamentApplication?: boolean | TournamentApplicationFindManyArgs
    TournamentParticipation?: boolean | TournamentParticipationFindManyArgs
    TeamInvitation?: boolean | TeamInvitationFindManyArgs
    imageId?: boolean
  }

  export type TeamInclude = {
    icon?: boolean | ImageArgs
    members?: boolean | TeamMembershipFindManyArgs
    Tournament?: boolean | TournamentFindManyArgs
    TournamentApplication?: boolean | TournamentApplicationFindManyArgs
    TournamentParticipation?: boolean | TournamentParticipationFindManyArgs
    TeamInvitation?: boolean | TeamInvitationFindManyArgs
  }

  export type TeamGetPayload<
    S extends boolean | null | undefined | TeamArgs,
    U = keyof S
      > = S extends true
        ? Team
    : S extends undefined
    ? never
    : S extends TeamArgs | TeamFindManyArgs
    ?'include' extends U
    ? Team  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'icon'
        ? ImageGetPayload<S['include'][P]> | null :
        P extends 'members'
        ? Array < TeamMembershipGetPayload<S['include'][P]>>  :
        P extends 'Tournament'
        ? Array < TournamentGetPayload<S['include'][P]>>  :
        P extends 'TournamentApplication'
        ? Array < TournamentApplicationGetPayload<S['include'][P]>>  :
        P extends 'TournamentParticipation'
        ? Array < TournamentParticipationGetPayload<S['include'][P]>>  :
        P extends 'TeamInvitation'
        ? Array < TeamInvitationGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Team ?Team [P]
  : 
          P extends 'icon'
        ? ImageGetPayload<S['select'][P]> | null :
        P extends 'members'
        ? Array < TeamMembershipGetPayload<S['select'][P]>>  :
        P extends 'Tournament'
        ? Array < TournamentGetPayload<S['select'][P]>>  :
        P extends 'TournamentApplication'
        ? Array < TournamentApplicationGetPayload<S['select'][P]>>  :
        P extends 'TournamentParticipation'
        ? Array < TournamentParticipationGetPayload<S['select'][P]>>  :
        P extends 'TeamInvitation'
        ? Array < TeamInvitationGetPayload<S['select'][P]>>  : never
  } 
    : Team
  : Team


  type TeamCountArgs = Merge<
    Omit<TeamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }
  >

  export interface TeamDelegate {
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamFindUniqueArgs>(
      args: SelectSubset<T, TeamFindUniqueArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>

    /**
     * Find the first Team that matches the filter.
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamFindFirstArgs>(
      args?: SelectSubset<T, TeamFindFirstArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team | null>, Prisma__TeamClient<TeamGetPayload<T> | null>>

    /**
     * Find zero or more Teams that matches the filter.
     * @param {TeamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamFindManyArgs>(
      args?: SelectSubset<T, TeamFindManyArgs>
    ): CheckSelect<T, Promise<Array<Team>>, Promise<Array<TeamGetPayload<T>>>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends TeamCreateArgs>(
      args: SelectSubset<T, TeamCreateArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends TeamDeleteArgs>(
      args: SelectSubset<T, TeamDeleteArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamUpdateArgs>(
      args: SelectSubset<T, TeamUpdateArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamDeleteManyArgs>(
      args?: SelectSubset<T, TeamDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Teams.
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamUpdateManyArgs>(
      args: SelectSubset<T, TeamUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends TeamUpsertArgs>(
      args: SelectSubset<T, TeamUpsertArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Count the number of Teams.
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Promise<GetTeamAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    icon<T extends ImageArgs = {}>(args?: Subset<T, ImageArgs>): CheckSelect<T, Prisma__ImageClient<Image | null>, Prisma__ImageClient<ImageGetPayload<T> | null>>;

    members<T extends TeamMembershipFindManyArgs = {}>(args?: Subset<T, TeamMembershipFindManyArgs>): CheckSelect<T, Promise<Array<TeamMembership>>, Promise<Array<TeamMembershipGetPayload<T>>>>;

    Tournament<T extends TournamentFindManyArgs = {}>(args?: Subset<T, TournamentFindManyArgs>): CheckSelect<T, Promise<Array<Tournament>>, Promise<Array<TournamentGetPayload<T>>>>;

    TournamentApplication<T extends TournamentApplicationFindManyArgs = {}>(args?: Subset<T, TournamentApplicationFindManyArgs>): CheckSelect<T, Promise<Array<TournamentApplication>>, Promise<Array<TournamentApplicationGetPayload<T>>>>;

    TournamentParticipation<T extends TournamentParticipationFindManyArgs = {}>(args?: Subset<T, TournamentParticipationFindManyArgs>): CheckSelect<T, Promise<Array<TournamentParticipation>>, Promise<Array<TournamentParticipationGetPayload<T>>>>;

    TeamInvitation<T extends TeamInvitationFindManyArgs = {}>(args?: Subset<T, TeamInvitationFindManyArgs>): CheckSelect<T, Promise<Array<TeamInvitation>>, Promise<Array<TeamInvitationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * Throw an Error if a Team can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Team to fetch.
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * Throw an Error if a Team can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Team to fetch.
    **/
    where?: TeamWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Teams to fetch.
    **/
    orderBy?: Enumerable<TeamOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Teams.
    **/
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team findMany
   */
  export type TeamFindManyArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * Filter, which Teams to fetch.
    **/
    where?: TeamWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Teams to fetch.
    **/
    orderBy?: Enumerable<TeamOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
    **/
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team create
   */
  export type TeamCreateArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * The data needed to create a Team.
    **/
    data: XOR<TeamUncheckedCreateInput, TeamCreateInput>
  }


  /**
   * Team update
   */
  export type TeamUpdateArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * The data needed to update a Team.
    **/
    data: XOR<TeamUncheckedUpdateInput, TeamUpdateInput>
    /**
     * Choose, which Team to update.
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs = {
    data: XOR<TeamUncheckedUpdateManyInput, TeamUpdateManyMutationInput>
    where?: TeamWhereInput
  }


  /**
   * Team upsert
   */
  export type TeamUpsertArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * The filter to search for the Team to update in case it exists.
    **/
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
    **/
    create: XOR<TeamUncheckedCreateInput, TeamCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TeamUncheckedUpdateInput, TeamUpdateInput>
  }


  /**
   * Team delete
   */
  export type TeamDeleteArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
    /**
     * Filter which Team to delete.
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs = {
    where?: TeamWhereInput
  }


  /**
   * Team without action
   */
  export type TeamArgs = {
    /**
     * Select specific fields to fetch from the Team
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TeamInclude | null
  }



  /**
   * Model TournamentMatch
   */


  export type AggregateTournamentMatch = {
    count: TournamentMatchCountAggregateOutputType | null
    avg: TournamentMatchAvgAggregateOutputType | null
    sum: TournamentMatchSumAggregateOutputType | null
    min: TournamentMatchMinAggregateOutputType | null
    max: TournamentMatchMaxAggregateOutputType | null
  }

  export type TournamentMatchAvgAggregateOutputType = {
    id: number
    roomCodeId: number
  }

  export type TournamentMatchSumAggregateOutputType = {
    id: number
    roomCodeId: number
  }

  export type TournamentMatchMinAggregateOutputType = {
    id: number
    joinUntil: Date | null
    createRoomUntil: Date | null
    state: MatchStateType | null
    roomCodeId: number
    tournamentId: string | null
  }

  export type TournamentMatchMaxAggregateOutputType = {
    id: number
    joinUntil: Date | null
    createRoomUntil: Date | null
    state: MatchStateType | null
    roomCodeId: number
    tournamentId: string | null
  }

  export type TournamentMatchCountAggregateOutputType = {
    id: number
    joinUntil: number | null
    createRoomUntil: number | null
    state: number | null
    roomCodeId: number
    tournamentId: number | null
    _all: number
  }


  export type TournamentMatchAvgAggregateInputType = {
    id?: true
    roomCodeId?: true
  }

  export type TournamentMatchSumAggregateInputType = {
    id?: true
    roomCodeId?: true
  }

  export type TournamentMatchMinAggregateInputType = {
    id?: true
    joinUntil?: true
    createRoomUntil?: true
    state?: true
    roomCodeId?: true
    tournamentId?: true
  }

  export type TournamentMatchMaxAggregateInputType = {
    id?: true
    joinUntil?: true
    createRoomUntil?: true
    state?: true
    roomCodeId?: true
    tournamentId?: true
  }

  export type TournamentMatchCountAggregateInputType = {
    id?: true
    joinUntil?: true
    createRoomUntil?: true
    state?: true
    roomCodeId?: true
    tournamentId?: true
    _all?: true
  }

  export type TournamentMatchAggregateArgs = {
    /**
     * Filter which TournamentMatch to aggregate.
    **/
    where?: TournamentMatchWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatches to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentMatches
    **/
    count?: true | TournamentMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentMatchMaxAggregateInputType
  }

  export type GetTournamentMatchAggregateType<T extends TournamentMatchAggregateArgs> = {
    [P in keyof T & keyof AggregateTournamentMatch]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentMatch[P]>
      : GetScalarType<T[P], AggregateTournamentMatch[P]>
  }



  export type TournamentMatchSelect = {
    id?: boolean
    tournament?: boolean | TournamentArgs
    roomCode?: boolean | RoomCodeArgs
    participants?: boolean | TournamentParticipationFindManyArgs
    joinUntil?: boolean
    createRoomUntil?: boolean
    state?: boolean
    roomCodeId?: boolean
    tournamentId?: boolean
    TournamentGridElement?: boolean | TournamentGridElementFindManyArgs
    TournamentMatchState?: boolean | TournamentMatchStateFindManyArgs
    TournamentMatchReport?: boolean | TournamentMatchReportFindManyArgs
  }

  export type TournamentMatchInclude = {
    tournament?: boolean | TournamentArgs
    roomCode?: boolean | RoomCodeArgs
    participants?: boolean | TournamentParticipationFindManyArgs
    TournamentGridElement?: boolean | TournamentGridElementFindManyArgs
    TournamentMatchState?: boolean | TournamentMatchStateFindManyArgs
    TournamentMatchReport?: boolean | TournamentMatchReportFindManyArgs
  }

  export type TournamentMatchGetPayload<
    S extends boolean | null | undefined | TournamentMatchArgs,
    U = keyof S
      > = S extends true
        ? TournamentMatch
    : S extends undefined
    ? never
    : S extends TournamentMatchArgs | TournamentMatchFindManyArgs
    ?'include' extends U
    ? TournamentMatch  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tournament'
        ? TournamentGetPayload<S['include'][P]> :
        P extends 'roomCode'
        ? RoomCodeGetPayload<S['include'][P]> :
        P extends 'participants'
        ? Array < TournamentParticipationGetPayload<S['include'][P]>>  :
        P extends 'TournamentGridElement'
        ? Array < TournamentGridElementGetPayload<S['include'][P]>>  :
        P extends 'TournamentMatchState'
        ? Array < TournamentMatchStateGetPayload<S['include'][P]>>  :
        P extends 'TournamentMatchReport'
        ? Array < TournamentMatchReportGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TournamentMatch ?TournamentMatch [P]
  : 
          P extends 'tournament'
        ? TournamentGetPayload<S['select'][P]> :
        P extends 'roomCode'
        ? RoomCodeGetPayload<S['select'][P]> :
        P extends 'participants'
        ? Array < TournamentParticipationGetPayload<S['select'][P]>>  :
        P extends 'TournamentGridElement'
        ? Array < TournamentGridElementGetPayload<S['select'][P]>>  :
        P extends 'TournamentMatchState'
        ? Array < TournamentMatchStateGetPayload<S['select'][P]>>  :
        P extends 'TournamentMatchReport'
        ? Array < TournamentMatchReportGetPayload<S['select'][P]>>  : never
  } 
    : TournamentMatch
  : TournamentMatch


  type TournamentMatchCountArgs = Merge<
    Omit<TournamentMatchFindManyArgs, 'select' | 'include'> & {
      select?: TournamentMatchCountAggregateInputType | true
    }
  >

  export interface TournamentMatchDelegate {
    /**
     * Find zero or one TournamentMatch that matches the filter.
     * @param {TournamentMatchFindUniqueArgs} args - Arguments to find a TournamentMatch
     * @example
     * // Get one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentMatchFindUniqueArgs>(
      args: SelectSubset<T, TournamentMatchFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch | null>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T> | null>>

    /**
     * Find the first TournamentMatch that matches the filter.
     * @param {TournamentMatchFindFirstArgs} args - Arguments to find a TournamentMatch
     * @example
     * // Get one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentMatchFindFirstArgs>(
      args?: SelectSubset<T, TournamentMatchFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch | null>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T> | null>>

    /**
     * Find zero or more TournamentMatches that matches the filter.
     * @param {TournamentMatchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentMatches
     * const tournamentMatches = await prisma.tournamentMatch.findMany()
     * 
     * // Get first 10 TournamentMatches
     * const tournamentMatches = await prisma.tournamentMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentMatchWithIdOnly = await prisma.tournamentMatch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TournamentMatchFindManyArgs>(
      args?: SelectSubset<T, TournamentMatchFindManyArgs>
    ): CheckSelect<T, Promise<Array<TournamentMatch>>, Promise<Array<TournamentMatchGetPayload<T>>>>

    /**
     * Create a TournamentMatch.
     * @param {TournamentMatchCreateArgs} args - Arguments to create a TournamentMatch.
     * @example
     * // Create one TournamentMatch
     * const TournamentMatch = await prisma.tournamentMatch.create({
     *   data: {
     *     // ... data to create a TournamentMatch
     *   }
     * })
     * 
    **/
    create<T extends TournamentMatchCreateArgs>(
      args: SelectSubset<T, TournamentMatchCreateArgs>
    ): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T>>>

    /**
     * Delete a TournamentMatch.
     * @param {TournamentMatchDeleteArgs} args - Arguments to delete one TournamentMatch.
     * @example
     * // Delete one TournamentMatch
     * const TournamentMatch = await prisma.tournamentMatch.delete({
     *   where: {
     *     // ... filter to delete one TournamentMatch
     *   }
     * })
     * 
    **/
    delete<T extends TournamentMatchDeleteArgs>(
      args: SelectSubset<T, TournamentMatchDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T>>>

    /**
     * Update one TournamentMatch.
     * @param {TournamentMatchUpdateArgs} args - Arguments to update one TournamentMatch.
     * @example
     * // Update one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentMatchUpdateArgs>(
      args: SelectSubset<T, TournamentMatchUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T>>>

    /**
     * Delete zero or more TournamentMatches.
     * @param {TournamentMatchDeleteManyArgs} args - Arguments to filter TournamentMatches to delete.
     * @example
     * // Delete a few TournamentMatches
     * const { count } = await prisma.tournamentMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentMatchDeleteManyArgs>(
      args?: SelectSubset<T, TournamentMatchDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TournamentMatches.
     * @param {TournamentMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentMatches
     * const tournamentMatch = await prisma.tournamentMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentMatchUpdateManyArgs>(
      args: SelectSubset<T, TournamentMatchUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TournamentMatch.
     * @param {TournamentMatchUpsertArgs} args - Arguments to update or create a TournamentMatch.
     * @example
     * // Update or create a TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.upsert({
     *   create: {
     *     // ... data to create a TournamentMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentMatch we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentMatchUpsertArgs>(
      args: SelectSubset<T, TournamentMatchUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T>>>

    /**
     * Count the number of TournamentMatches.
     * @param {TournamentMatchCountArgs} args - Arguments to filter TournamentMatches to count.
     * @example
     * // Count the number of TournamentMatches
     * const count = await prisma.tournamentMatch.count({
     *   where: {
     *     // ... the filter for the TournamentMatches we want to count
     *   }
     * })
    **/
    count<T extends TournamentMatchCountArgs>(
      args?: Subset<T, TournamentMatchCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentMatch.
     * @param {TournamentMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentMatchAggregateArgs>(args: Subset<T, TournamentMatchAggregateArgs>): Promise<GetTournamentMatchAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentMatchClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tournament<T extends TournamentArgs = {}>(args?: Subset<T, TournamentArgs>): CheckSelect<T, Prisma__TournamentClient<Tournament | null>, Prisma__TournamentClient<TournamentGetPayload<T> | null>>;

    roomCode<T extends RoomCodeArgs = {}>(args?: Subset<T, RoomCodeArgs>): CheckSelect<T, Prisma__RoomCodeClient<RoomCode | null>, Prisma__RoomCodeClient<RoomCodeGetPayload<T> | null>>;

    participants<T extends TournamentParticipationFindManyArgs = {}>(args?: Subset<T, TournamentParticipationFindManyArgs>): CheckSelect<T, Promise<Array<TournamentParticipation>>, Promise<Array<TournamentParticipationGetPayload<T>>>>;

    TournamentGridElement<T extends TournamentGridElementFindManyArgs = {}>(args?: Subset<T, TournamentGridElementFindManyArgs>): CheckSelect<T, Promise<Array<TournamentGridElement>>, Promise<Array<TournamentGridElementGetPayload<T>>>>;

    TournamentMatchState<T extends TournamentMatchStateFindManyArgs = {}>(args?: Subset<T, TournamentMatchStateFindManyArgs>): CheckSelect<T, Promise<Array<TournamentMatchState>>, Promise<Array<TournamentMatchStateGetPayload<T>>>>;

    TournamentMatchReport<T extends TournamentMatchReportFindManyArgs = {}>(args?: Subset<T, TournamentMatchReportFindManyArgs>): CheckSelect<T, Promise<Array<TournamentMatchReport>>, Promise<Array<TournamentMatchReportGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TournamentMatch findUnique
   */
  export type TournamentMatchFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * Throw an Error if a TournamentMatch can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentMatch to fetch.
    **/
    where: TournamentMatchWhereUniqueInput
  }


  /**
   * TournamentMatch findFirst
   */
  export type TournamentMatchFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * Throw an Error if a TournamentMatch can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentMatch to fetch.
    **/
    where?: TournamentMatchWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatches to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentMatches.
    **/
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TournamentMatches.
    **/
    distinct?: Enumerable<TournamentMatchScalarFieldEnum>
  }


  /**
   * TournamentMatch findMany
   */
  export type TournamentMatchFindManyArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * Filter, which TournamentMatches to fetch.
    **/
    where?: TournamentMatchWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatches to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentMatches.
    **/
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
    **/
    skip?: number
    distinct?: Enumerable<TournamentMatchScalarFieldEnum>
  }


  /**
   * TournamentMatch create
   */
  export type TournamentMatchCreateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * The data needed to create a TournamentMatch.
    **/
    data: XOR<TournamentMatchUncheckedCreateInput, TournamentMatchCreateInput>
  }


  /**
   * TournamentMatch update
   */
  export type TournamentMatchUpdateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * The data needed to update a TournamentMatch.
    **/
    data: XOR<TournamentMatchUncheckedUpdateInput, TournamentMatchUpdateInput>
    /**
     * Choose, which TournamentMatch to update.
    **/
    where: TournamentMatchWhereUniqueInput
  }


  /**
   * TournamentMatch updateMany
   */
  export type TournamentMatchUpdateManyArgs = {
    data: XOR<TournamentMatchUncheckedUpdateManyInput, TournamentMatchUpdateManyMutationInput>
    where?: TournamentMatchWhereInput
  }


  /**
   * TournamentMatch upsert
   */
  export type TournamentMatchUpsertArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * The filter to search for the TournamentMatch to update in case it exists.
    **/
    where: TournamentMatchWhereUniqueInput
    /**
     * In case the TournamentMatch found by the `where` argument doesn't exist, create a new TournamentMatch with this data.
    **/
    create: XOR<TournamentMatchUncheckedCreateInput, TournamentMatchCreateInput>
    /**
     * In case the TournamentMatch was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentMatchUncheckedUpdateInput, TournamentMatchUpdateInput>
  }


  /**
   * TournamentMatch delete
   */
  export type TournamentMatchDeleteArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
    /**
     * Filter which TournamentMatch to delete.
    **/
    where: TournamentMatchWhereUniqueInput
  }


  /**
   * TournamentMatch deleteMany
   */
  export type TournamentMatchDeleteManyArgs = {
    where?: TournamentMatchWhereInput
  }


  /**
   * TournamentMatch without action
   */
  export type TournamentMatchArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatch
    **/
    select?: TournamentMatchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchInclude | null
  }



  /**
   * Model TournamentMatchReport
   */


  export type AggregateTournamentMatchReport = {
    count: TournamentMatchReportCountAggregateOutputType | null
    avg: TournamentMatchReportAvgAggregateOutputType | null
    sum: TournamentMatchReportSumAggregateOutputType | null
    min: TournamentMatchReportMinAggregateOutputType | null
    max: TournamentMatchReportMaxAggregateOutputType | null
  }

  export type TournamentMatchReportAvgAggregateOutputType = {
    matchId: number
    reporterId: number
  }

  export type TournamentMatchReportSumAggregateOutputType = {
    matchId: number
    reporterId: number
  }

  export type TournamentMatchReportMinAggregateOutputType = {
    type: ReportType | null
    description: string | null
    matchId: number
    reporterId: number
  }

  export type TournamentMatchReportMaxAggregateOutputType = {
    type: ReportType | null
    description: string | null
    matchId: number
    reporterId: number
  }

  export type TournamentMatchReportCountAggregateOutputType = {
    type: number | null
    description: number | null
    matchId: number
    reporterId: number
    _all: number
  }


  export type TournamentMatchReportAvgAggregateInputType = {
    matchId?: true
    reporterId?: true
  }

  export type TournamentMatchReportSumAggregateInputType = {
    matchId?: true
    reporterId?: true
  }

  export type TournamentMatchReportMinAggregateInputType = {
    type?: true
    description?: true
    matchId?: true
    reporterId?: true
  }

  export type TournamentMatchReportMaxAggregateInputType = {
    type?: true
    description?: true
    matchId?: true
    reporterId?: true
  }

  export type TournamentMatchReportCountAggregateInputType = {
    type?: true
    description?: true
    matchId?: true
    reporterId?: true
    _all?: true
  }

  export type TournamentMatchReportAggregateArgs = {
    /**
     * Filter which TournamentMatchReport to aggregate.
    **/
    where?: TournamentMatchReportWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatchReports to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TournamentMatchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatchReports from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatchReports.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentMatchReports
    **/
    count?: true | TournamentMatchReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TournamentMatchReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TournamentMatchReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TournamentMatchReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TournamentMatchReportMaxAggregateInputType
  }

  export type GetTournamentMatchReportAggregateType<T extends TournamentMatchReportAggregateArgs> = {
    [P in keyof T & keyof AggregateTournamentMatchReport]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentMatchReport[P]>
      : GetScalarType<T[P], AggregateTournamentMatchReport[P]>
  }



  export type TournamentMatchReportSelect = {
    reporter?: boolean | UserArgs
    match?: boolean | TournamentMatchArgs
    type?: boolean
    description?: boolean
    attachments?: boolean | ImageFindManyArgs
    matchId?: boolean
    reporterId?: boolean
  }

  export type TournamentMatchReportInclude = {
    reporter?: boolean | UserArgs
    match?: boolean | TournamentMatchArgs
    attachments?: boolean | ImageFindManyArgs
  }

  export type TournamentMatchReportGetPayload<
    S extends boolean | null | undefined | TournamentMatchReportArgs,
    U = keyof S
      > = S extends true
        ? TournamentMatchReport
    : S extends undefined
    ? never
    : S extends TournamentMatchReportArgs | TournamentMatchReportFindManyArgs
    ?'include' extends U
    ? TournamentMatchReport  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'reporter'
        ? UserGetPayload<S['include'][P]> :
        P extends 'match'
        ? TournamentMatchGetPayload<S['include'][P]> :
        P extends 'attachments'
        ? Array < ImageGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TournamentMatchReport ?TournamentMatchReport [P]
  : 
          P extends 'reporter'
        ? UserGetPayload<S['select'][P]> :
        P extends 'match'
        ? TournamentMatchGetPayload<S['select'][P]> :
        P extends 'attachments'
        ? Array < ImageGetPayload<S['select'][P]>>  : never
  } 
    : TournamentMatchReport
  : TournamentMatchReport


  type TournamentMatchReportCountArgs = Merge<
    Omit<TournamentMatchReportFindManyArgs, 'select' | 'include'> & {
      select?: TournamentMatchReportCountAggregateInputType | true
    }
  >

  export interface TournamentMatchReportDelegate {
    /**
     * Find zero or one TournamentMatchReport that matches the filter.
     * @param {TournamentMatchReportFindUniqueArgs} args - Arguments to find a TournamentMatchReport
     * @example
     * // Get one TournamentMatchReport
     * const tournamentMatchReport = await prisma.tournamentMatchReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TournamentMatchReportFindUniqueArgs>(
      args: SelectSubset<T, TournamentMatchReportFindUniqueArgs>
    ): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport | null>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T> | null>>

    /**
     * Find the first TournamentMatchReport that matches the filter.
     * @param {TournamentMatchReportFindFirstArgs} args - Arguments to find a TournamentMatchReport
     * @example
     * // Get one TournamentMatchReport
     * const tournamentMatchReport = await prisma.tournamentMatchReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TournamentMatchReportFindFirstArgs>(
      args?: SelectSubset<T, TournamentMatchReportFindFirstArgs>
    ): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport | null>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T> | null>>

    /**
     * Find zero or more TournamentMatchReports that matches the filter.
     * @param {TournamentMatchReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentMatchReports
     * const tournamentMatchReports = await prisma.tournamentMatchReport.findMany()
     * 
     * // Get first 10 TournamentMatchReports
     * const tournamentMatchReports = await prisma.tournamentMatchReport.findMany({ take: 10 })
     * 
     * // Only select the `description`
     * const tournamentMatchReportWithDescriptionOnly = await prisma.tournamentMatchReport.findMany({ select: { description: true } })
     * 
    **/
    findMany<T extends TournamentMatchReportFindManyArgs>(
      args?: SelectSubset<T, TournamentMatchReportFindManyArgs>
    ): CheckSelect<T, Promise<Array<TournamentMatchReport>>, Promise<Array<TournamentMatchReportGetPayload<T>>>>

    /**
     * Create a TournamentMatchReport.
     * @param {TournamentMatchReportCreateArgs} args - Arguments to create a TournamentMatchReport.
     * @example
     * // Create one TournamentMatchReport
     * const TournamentMatchReport = await prisma.tournamentMatchReport.create({
     *   data: {
     *     // ... data to create a TournamentMatchReport
     *   }
     * })
     * 
    **/
    create<T extends TournamentMatchReportCreateArgs>(
      args: SelectSubset<T, TournamentMatchReportCreateArgs>
    ): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T>>>

    /**
     * Delete a TournamentMatchReport.
     * @param {TournamentMatchReportDeleteArgs} args - Arguments to delete one TournamentMatchReport.
     * @example
     * // Delete one TournamentMatchReport
     * const TournamentMatchReport = await prisma.tournamentMatchReport.delete({
     *   where: {
     *     // ... filter to delete one TournamentMatchReport
     *   }
     * })
     * 
    **/
    delete<T extends TournamentMatchReportDeleteArgs>(
      args: SelectSubset<T, TournamentMatchReportDeleteArgs>
    ): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T>>>

    /**
     * Update one TournamentMatchReport.
     * @param {TournamentMatchReportUpdateArgs} args - Arguments to update one TournamentMatchReport.
     * @example
     * // Update one TournamentMatchReport
     * const tournamentMatchReport = await prisma.tournamentMatchReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TournamentMatchReportUpdateArgs>(
      args: SelectSubset<T, TournamentMatchReportUpdateArgs>
    ): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T>>>

    /**
     * Delete zero or more TournamentMatchReports.
     * @param {TournamentMatchReportDeleteManyArgs} args - Arguments to filter TournamentMatchReports to delete.
     * @example
     * // Delete a few TournamentMatchReports
     * const { count } = await prisma.tournamentMatchReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TournamentMatchReportDeleteManyArgs>(
      args?: SelectSubset<T, TournamentMatchReportDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TournamentMatchReports.
     * @param {TournamentMatchReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentMatchReports
     * const tournamentMatchReport = await prisma.tournamentMatchReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TournamentMatchReportUpdateManyArgs>(
      args: SelectSubset<T, TournamentMatchReportUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TournamentMatchReport.
     * @param {TournamentMatchReportUpsertArgs} args - Arguments to update or create a TournamentMatchReport.
     * @example
     * // Update or create a TournamentMatchReport
     * const tournamentMatchReport = await prisma.tournamentMatchReport.upsert({
     *   create: {
     *     // ... data to create a TournamentMatchReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentMatchReport we want to update
     *   }
     * })
    **/
    upsert<T extends TournamentMatchReportUpsertArgs>(
      args: SelectSubset<T, TournamentMatchReportUpsertArgs>
    ): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T>>>

    /**
     * Count the number of TournamentMatchReports.
     * @param {TournamentMatchReportCountArgs} args - Arguments to filter TournamentMatchReports to count.
     * @example
     * // Count the number of TournamentMatchReports
     * const count = await prisma.tournamentMatchReport.count({
     *   where: {
     *     // ... the filter for the TournamentMatchReports we want to count
     *   }
     * })
    **/
    count<T extends TournamentMatchReportCountArgs>(
      args?: Subset<T, TournamentMatchReportCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentMatchReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentMatchReport.
     * @param {TournamentMatchReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentMatchReportAggregateArgs>(args: Subset<T, TournamentMatchReportAggregateArgs>): Promise<GetTournamentMatchReportAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentMatchReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TournamentMatchReportClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reporter<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    match<T extends TournamentMatchArgs = {}>(args?: Subset<T, TournamentMatchArgs>): CheckSelect<T, Prisma__TournamentMatchClient<TournamentMatch | null>, Prisma__TournamentMatchClient<TournamentMatchGetPayload<T> | null>>;

    attachments<T extends ImageFindManyArgs = {}>(args?: Subset<T, ImageFindManyArgs>): CheckSelect<T, Promise<Array<Image>>, Promise<Array<ImageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TournamentMatchReport findUnique
   */
  export type TournamentMatchReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * Throw an Error if a TournamentMatchReport can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentMatchReport to fetch.
    **/
    where: TournamentMatchReportWhereUniqueInput
  }


  /**
   * TournamentMatchReport findFirst
   */
  export type TournamentMatchReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * Throw an Error if a TournamentMatchReport can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TournamentMatchReport to fetch.
    **/
    where?: TournamentMatchReportWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatchReports to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentMatchReports.
    **/
    cursor?: TournamentMatchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatchReports from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatchReports.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TournamentMatchReports.
    **/
    distinct?: Enumerable<TournamentMatchReportScalarFieldEnum>
  }


  /**
   * TournamentMatchReport findMany
   */
  export type TournamentMatchReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * Filter, which TournamentMatchReports to fetch.
    **/
    where?: TournamentMatchReportWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TournamentMatchReports to fetch.
    **/
    orderBy?: Enumerable<TournamentMatchReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentMatchReports.
    **/
    cursor?: TournamentMatchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatchReports from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatchReports.
    **/
    skip?: number
    distinct?: Enumerable<TournamentMatchReportScalarFieldEnum>
  }


  /**
   * TournamentMatchReport create
   */
  export type TournamentMatchReportCreateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * The data needed to create a TournamentMatchReport.
    **/
    data: XOR<TournamentMatchReportUncheckedCreateInput, TournamentMatchReportCreateInput>
  }


  /**
   * TournamentMatchReport update
   */
  export type TournamentMatchReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * The data needed to update a TournamentMatchReport.
    **/
    data: XOR<TournamentMatchReportUncheckedUpdateInput, TournamentMatchReportUpdateInput>
    /**
     * Choose, which TournamentMatchReport to update.
    **/
    where: TournamentMatchReportWhereUniqueInput
  }


  /**
   * TournamentMatchReport updateMany
   */
  export type TournamentMatchReportUpdateManyArgs = {
    data: XOR<TournamentMatchReportUncheckedUpdateManyInput, TournamentMatchReportUpdateManyMutationInput>
    where?: TournamentMatchReportWhereInput
  }


  /**
   * TournamentMatchReport upsert
   */
  export type TournamentMatchReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * The filter to search for the TournamentMatchReport to update in case it exists.
    **/
    where: TournamentMatchReportWhereUniqueInput
    /**
     * In case the TournamentMatchReport found by the `where` argument doesn't exist, create a new TournamentMatchReport with this data.
    **/
    create: XOR<TournamentMatchReportUncheckedCreateInput, TournamentMatchReportCreateInput>
    /**
     * In case the TournamentMatchReport was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TournamentMatchReportUncheckedUpdateInput, TournamentMatchReportUpdateInput>
  }


  /**
   * TournamentMatchReport delete
   */
  export type TournamentMatchReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
    /**
     * Filter which TournamentMatchReport to delete.
    **/
    where: TournamentMatchReportWhereUniqueInput
  }


  /**
   * TournamentMatchReport deleteMany
   */
  export type TournamentMatchReportDeleteManyArgs = {
    where?: TournamentMatchReportWhereInput
  }


  /**
   * TournamentMatchReport without action
   */
  export type TournamentMatchReportArgs = {
    /**
     * Select specific fields to fetch from the TournamentMatchReport
    **/
    select?: TournamentMatchReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TournamentMatchReportInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    count: NotificationCountAggregateOutputType | null
    avg: NotificationAvgAggregateOutputType | null
    sum: NotificationSumAggregateOutputType | null
    min: NotificationMinAggregateOutputType | null
    max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number
    userId: number
  }

  export type NotificationSumAggregateOutputType = {
    id: number
    userId: number
  }

  export type NotificationMinAggregateOutputType = {
    id: number
    type: NotificationType | null
    title: string | null
    description: string | null
    createdAt: Date | null
    read: boolean | null
    userId: number
  }

  export type NotificationMaxAggregateOutputType = {
    id: number
    type: NotificationType | null
    title: string | null
    description: string | null
    createdAt: Date | null
    read: boolean | null
    userId: number
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number | null
    title: number | null
    description: number | null
    createdAt: number | null
    read: number | null
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    createdAt?: true
    read?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    createdAt?: true
    read?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    createdAt?: true
    read?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
    **/
    where?: NotificationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Notifications to fetch.
    **/
    orderBy?: Enumerable<NotificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }



  export type NotificationSelect = {
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    read?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type NotificationInclude = {
    user?: boolean | UserArgs
  }

  export type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationArgs,
    U = keyof S
      > = S extends true
        ? Notification
    : S extends undefined
    ? never
    : S extends NotificationArgs | NotificationFindManyArgs
    ?'include' extends U
    ? Notification  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Notification ?Notification [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Notification
  : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification | null>, Prisma__NotificationClient<NotificationGetPayload<T> | null>>

    /**
     * Find the first Notification that matches the filter.
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification | null>, Prisma__NotificationClient<NotificationGetPayload<T> | null>>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): CheckSelect<T, Promise<Array<Notification>>, Promise<Array<NotificationGetPayload<T>>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Promise<GetNotificationAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
    **/
    where?: NotificationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Notifications to fetch.
    **/
    orderBy?: Enumerable<NotificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Notifications.
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
    **/
    where?: NotificationWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Notifications to fetch.
    **/
    orderBy?: Enumerable<NotificationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
    **/
    data: XOR<NotificationUncheckedCreateInput, NotificationCreateInput>
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
    **/
    data: XOR<NotificationUncheckedUpdateInput, NotificationUpdateInput>
    /**
     * Choose, which Notification to update.
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    data: XOR<NotificationUncheckedUpdateManyInput, NotificationUpdateManyMutationInput>
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
    **/
    create: XOR<NotificationUncheckedCreateInput, NotificationCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<NotificationUncheckedUpdateInput, NotificationUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: NotificationInclude | null
  }



  /**
   * Model RoomCode
   */


  export type AggregateRoomCode = {
    count: RoomCodeCountAggregateOutputType | null
    avg: RoomCodeAvgAggregateOutputType | null
    sum: RoomCodeSumAggregateOutputType | null
    min: RoomCodeMinAggregateOutputType | null
    max: RoomCodeMaxAggregateOutputType | null
  }

  export type RoomCodeAvgAggregateOutputType = {
    id: number
  }

  export type RoomCodeSumAggregateOutputType = {
    id: number
  }

  export type RoomCodeMinAggregateOutputType = {
    id: number
    name: string | null
    password: string | null
    gameId: string | null
  }

  export type RoomCodeMaxAggregateOutputType = {
    id: number
    name: string | null
    password: string | null
    gameId: string | null
  }

  export type RoomCodeCountAggregateOutputType = {
    id: number
    name: number | null
    password: number | null
    gameId: number | null
    _all: number
  }


  export type RoomCodeAvgAggregateInputType = {
    id?: true
  }

  export type RoomCodeSumAggregateInputType = {
    id?: true
  }

  export type RoomCodeMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    gameId?: true
  }

  export type RoomCodeMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    gameId?: true
  }

  export type RoomCodeCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    gameId?: true
    _all?: true
  }

  export type RoomCodeAggregateArgs = {
    /**
     * Filter which RoomCode to aggregate.
    **/
    where?: RoomCodeWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of RoomCodes to fetch.
    **/
    orderBy?: Enumerable<RoomCodeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RoomCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomCodes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomCodes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomCodes
    **/
    count?: true | RoomCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RoomCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RoomCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RoomCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RoomCodeMaxAggregateInputType
  }

  export type GetRoomCodeAggregateType<T extends RoomCodeAggregateArgs> = {
    [P in keyof T & keyof AggregateRoomCode]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomCode[P]>
      : GetScalarType<T[P], AggregateRoomCode[P]>
  }



  export type RoomCodeSelect = {
    id?: boolean
    name?: boolean
    password?: boolean
    game?: boolean | GameArgs
    gameId?: boolean
    TournamentMatch?: boolean | TournamentMatchFindManyArgs
  }

  export type RoomCodeInclude = {
    game?: boolean | GameArgs
    TournamentMatch?: boolean | TournamentMatchFindManyArgs
  }

  export type RoomCodeGetPayload<
    S extends boolean | null | undefined | RoomCodeArgs,
    U = keyof S
      > = S extends true
        ? RoomCode
    : S extends undefined
    ? never
    : S extends RoomCodeArgs | RoomCodeFindManyArgs
    ?'include' extends U
    ? RoomCode  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'game'
        ? GameGetPayload<S['include'][P]> :
        P extends 'TournamentMatch'
        ? Array < TournamentMatchGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RoomCode ?RoomCode [P]
  : 
          P extends 'game'
        ? GameGetPayload<S['select'][P]> :
        P extends 'TournamentMatch'
        ? Array < TournamentMatchGetPayload<S['select'][P]>>  : never
  } 
    : RoomCode
  : RoomCode


  type RoomCodeCountArgs = Merge<
    Omit<RoomCodeFindManyArgs, 'select' | 'include'> & {
      select?: RoomCodeCountAggregateInputType | true
    }
  >

  export interface RoomCodeDelegate {
    /**
     * Find zero or one RoomCode that matches the filter.
     * @param {RoomCodeFindUniqueArgs} args - Arguments to find a RoomCode
     * @example
     * // Get one RoomCode
     * const roomCode = await prisma.roomCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomCodeFindUniqueArgs>(
      args: SelectSubset<T, RoomCodeFindUniqueArgs>
    ): CheckSelect<T, Prisma__RoomCodeClient<RoomCode | null>, Prisma__RoomCodeClient<RoomCodeGetPayload<T> | null>>

    /**
     * Find the first RoomCode that matches the filter.
     * @param {RoomCodeFindFirstArgs} args - Arguments to find a RoomCode
     * @example
     * // Get one RoomCode
     * const roomCode = await prisma.roomCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomCodeFindFirstArgs>(
      args?: SelectSubset<T, RoomCodeFindFirstArgs>
    ): CheckSelect<T, Prisma__RoomCodeClient<RoomCode | null>, Prisma__RoomCodeClient<RoomCodeGetPayload<T> | null>>

    /**
     * Find zero or more RoomCodes that matches the filter.
     * @param {RoomCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomCodes
     * const roomCodes = await prisma.roomCode.findMany()
     * 
     * // Get first 10 RoomCodes
     * const roomCodes = await prisma.roomCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomCodeWithIdOnly = await prisma.roomCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomCodeFindManyArgs>(
      args?: SelectSubset<T, RoomCodeFindManyArgs>
    ): CheckSelect<T, Promise<Array<RoomCode>>, Promise<Array<RoomCodeGetPayload<T>>>>

    /**
     * Create a RoomCode.
     * @param {RoomCodeCreateArgs} args - Arguments to create a RoomCode.
     * @example
     * // Create one RoomCode
     * const RoomCode = await prisma.roomCode.create({
     *   data: {
     *     // ... data to create a RoomCode
     *   }
     * })
     * 
    **/
    create<T extends RoomCodeCreateArgs>(
      args: SelectSubset<T, RoomCodeCreateArgs>
    ): CheckSelect<T, Prisma__RoomCodeClient<RoomCode>, Prisma__RoomCodeClient<RoomCodeGetPayload<T>>>

    /**
     * Delete a RoomCode.
     * @param {RoomCodeDeleteArgs} args - Arguments to delete one RoomCode.
     * @example
     * // Delete one RoomCode
     * const RoomCode = await prisma.roomCode.delete({
     *   where: {
     *     // ... filter to delete one RoomCode
     *   }
     * })
     * 
    **/
    delete<T extends RoomCodeDeleteArgs>(
      args: SelectSubset<T, RoomCodeDeleteArgs>
    ): CheckSelect<T, Prisma__RoomCodeClient<RoomCode>, Prisma__RoomCodeClient<RoomCodeGetPayload<T>>>

    /**
     * Update one RoomCode.
     * @param {RoomCodeUpdateArgs} args - Arguments to update one RoomCode.
     * @example
     * // Update one RoomCode
     * const roomCode = await prisma.roomCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomCodeUpdateArgs>(
      args: SelectSubset<T, RoomCodeUpdateArgs>
    ): CheckSelect<T, Prisma__RoomCodeClient<RoomCode>, Prisma__RoomCodeClient<RoomCodeGetPayload<T>>>

    /**
     * Delete zero or more RoomCodes.
     * @param {RoomCodeDeleteManyArgs} args - Arguments to filter RoomCodes to delete.
     * @example
     * // Delete a few RoomCodes
     * const { count } = await prisma.roomCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomCodeDeleteManyArgs>(
      args?: SelectSubset<T, RoomCodeDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more RoomCodes.
     * @param {RoomCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomCodes
     * const roomCode = await prisma.roomCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomCodeUpdateManyArgs>(
      args: SelectSubset<T, RoomCodeUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one RoomCode.
     * @param {RoomCodeUpsertArgs} args - Arguments to update or create a RoomCode.
     * @example
     * // Update or create a RoomCode
     * const roomCode = await prisma.roomCode.upsert({
     *   create: {
     *     // ... data to create a RoomCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomCode we want to update
     *   }
     * })
    **/
    upsert<T extends RoomCodeUpsertArgs>(
      args: SelectSubset<T, RoomCodeUpsertArgs>
    ): CheckSelect<T, Prisma__RoomCodeClient<RoomCode>, Prisma__RoomCodeClient<RoomCodeGetPayload<T>>>

    /**
     * Count the number of RoomCodes.
     * @param {RoomCodeCountArgs} args - Arguments to filter RoomCodes to count.
     * @example
     * // Count the number of RoomCodes
     * const count = await prisma.roomCode.count({
     *   where: {
     *     // ... the filter for the RoomCodes we want to count
     *   }
     * })
    **/
    count<T extends RoomCodeCountArgs>(
      args?: Subset<T, RoomCodeCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomCode.
     * @param {RoomCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomCodeAggregateArgs>(args: Subset<T, RoomCodeAggregateArgs>): Promise<GetRoomCodeAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoomCodeClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    game<T extends GameArgs = {}>(args?: Subset<T, GameArgs>): CheckSelect<T, Prisma__GameClient<Game | null>, Prisma__GameClient<GameGetPayload<T> | null>>;

    TournamentMatch<T extends TournamentMatchFindManyArgs = {}>(args?: Subset<T, TournamentMatchFindManyArgs>): CheckSelect<T, Promise<Array<TournamentMatch>>, Promise<Array<TournamentMatchGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RoomCode findUnique
   */
  export type RoomCodeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * Throw an Error if a RoomCode can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RoomCode to fetch.
    **/
    where: RoomCodeWhereUniqueInput
  }


  /**
   * RoomCode findFirst
   */
  export type RoomCodeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * Throw an Error if a RoomCode can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RoomCode to fetch.
    **/
    where?: RoomCodeWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of RoomCodes to fetch.
    **/
    orderBy?: Enumerable<RoomCodeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomCodes.
    **/
    cursor?: RoomCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomCodes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomCodes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of RoomCodes.
    **/
    distinct?: Enumerable<RoomCodeScalarFieldEnum>
  }


  /**
   * RoomCode findMany
   */
  export type RoomCodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * Filter, which RoomCodes to fetch.
    **/
    where?: RoomCodeWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of RoomCodes to fetch.
    **/
    orderBy?: Enumerable<RoomCodeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomCodes.
    **/
    cursor?: RoomCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomCodes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomCodes.
    **/
    skip?: number
    distinct?: Enumerable<RoomCodeScalarFieldEnum>
  }


  /**
   * RoomCode create
   */
  export type RoomCodeCreateArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * The data needed to create a RoomCode.
    **/
    data: XOR<RoomCodeUncheckedCreateInput, RoomCodeCreateInput>
  }


  /**
   * RoomCode update
   */
  export type RoomCodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * The data needed to update a RoomCode.
    **/
    data: XOR<RoomCodeUncheckedUpdateInput, RoomCodeUpdateInput>
    /**
     * Choose, which RoomCode to update.
    **/
    where: RoomCodeWhereUniqueInput
  }


  /**
   * RoomCode updateMany
   */
  export type RoomCodeUpdateManyArgs = {
    data: XOR<RoomCodeUncheckedUpdateManyInput, RoomCodeUpdateManyMutationInput>
    where?: RoomCodeWhereInput
  }


  /**
   * RoomCode upsert
   */
  export type RoomCodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * The filter to search for the RoomCode to update in case it exists.
    **/
    where: RoomCodeWhereUniqueInput
    /**
     * In case the RoomCode found by the `where` argument doesn't exist, create a new RoomCode with this data.
    **/
    create: XOR<RoomCodeUncheckedCreateInput, RoomCodeCreateInput>
    /**
     * In case the RoomCode was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RoomCodeUncheckedUpdateInput, RoomCodeUpdateInput>
  }


  /**
   * RoomCode delete
   */
  export type RoomCodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
    /**
     * Filter which RoomCode to delete.
    **/
    where: RoomCodeWhereUniqueInput
  }


  /**
   * RoomCode deleteMany
   */
  export type RoomCodeDeleteManyArgs = {
    where?: RoomCodeWhereInput
  }


  /**
   * RoomCode without action
   */
  export type RoomCodeArgs = {
    /**
     * Select specific fields to fetch from the RoomCode
    **/
    select?: RoomCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoomCodeInclude | null
  }



  /**
   * Model Image
   */


  export type AggregateImage = {
    count: ImageCountAggregateOutputType | null
    avg: ImageAvgAggregateOutputType | null
    sum: ImageSumAggregateOutputType | null
    min: ImageMinAggregateOutputType | null
    max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number
    width: number
    height: number
    tournamentMatchReportMatchId: number | null
    tournamentMatchReportReporterId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number
    width: number
    height: number
    tournamentMatchReportMatchId: number | null
    tournamentMatchReportReporterId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number
    path: string | null
    width: number
    height: number
    caption: string | null
    tournamentMatchReportMatchId: number | null
    tournamentMatchReportReporterId: number | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number
    path: string | null
    width: number
    height: number
    caption: string | null
    tournamentMatchReportMatchId: number | null
    tournamentMatchReportReporterId: number | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    path: number | null
    width: number
    height: number
    caption: number | null
    tournamentMatchReportMatchId: number | null
    tournamentMatchReportReporterId: number | null
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    tournamentMatchReportMatchId?: true
    tournamentMatchReportReporterId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    tournamentMatchReportMatchId?: true
    tournamentMatchReportReporterId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    path?: true
    width?: true
    height?: true
    caption?: true
    tournamentMatchReportMatchId?: true
    tournamentMatchReportReporterId?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    path?: true
    width?: true
    height?: true
    caption?: true
    tournamentMatchReportMatchId?: true
    tournamentMatchReportReporterId?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    path?: true
    width?: true
    height?: true
    caption?: true
    tournamentMatchReportMatchId?: true
    tournamentMatchReportReporterId?: true
    _all?: true
  }

  export type ImageAggregateArgs = {
    /**
     * Filter which Image to aggregate.
    **/
    where?: ImageWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Images to fetch.
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
    [P in keyof T & keyof AggregateImage]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }



  export type ImageSelect = {
    id?: boolean
    path?: boolean
    width?: boolean
    height?: boolean
    caption?: boolean
    Tournament?: boolean | TournamentFindManyArgs
    News?: boolean | NewsFindManyArgs
    Team?: boolean | TeamFindManyArgs
    TournamentMatchReport?: boolean | TournamentMatchReportArgs
    tournamentMatchReportMatchId?: boolean
    tournamentMatchReportReporterId?: boolean
  }

  export type ImageInclude = {
    Tournament?: boolean | TournamentFindManyArgs
    News?: boolean | NewsFindManyArgs
    Team?: boolean | TeamFindManyArgs
    TournamentMatchReport?: boolean | TournamentMatchReportArgs
  }

  export type ImageGetPayload<
    S extends boolean | null | undefined | ImageArgs,
    U = keyof S
      > = S extends true
        ? Image
    : S extends undefined
    ? never
    : S extends ImageArgs | ImageFindManyArgs
    ?'include' extends U
    ? Image  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Tournament'
        ? Array < TournamentGetPayload<S['include'][P]>>  :
        P extends 'News'
        ? Array < NewsGetPayload<S['include'][P]>>  :
        P extends 'Team'
        ? Array < TeamGetPayload<S['include'][P]>>  :
        P extends 'TournamentMatchReport'
        ? TournamentMatchReportGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Image ?Image [P]
  : 
          P extends 'Tournament'
        ? Array < TournamentGetPayload<S['select'][P]>>  :
        P extends 'News'
        ? Array < NewsGetPayload<S['select'][P]>>  :
        P extends 'Team'
        ? Array < TeamGetPayload<S['select'][P]>>  :
        P extends 'TournamentMatchReport'
        ? TournamentMatchReportGetPayload<S['select'][P]> | null : never
  } 
    : Image
  : Image


  type ImageCountArgs = Merge<
    Omit<ImageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }
  >

  export interface ImageDelegate {
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs>(
      args: SelectSubset<T, ImageFindUniqueArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image | null>, Prisma__ImageClient<ImageGetPayload<T> | null>>

    /**
     * Find the first Image that matches the filter.
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs>(
      args?: SelectSubset<T, ImageFindFirstArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image | null>, Prisma__ImageClient<ImageGetPayload<T> | null>>

    /**
     * Find zero or more Images that matches the filter.
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs>(
      args?: SelectSubset<T, ImageFindManyArgs>
    ): CheckSelect<T, Promise<Array<Image>>, Promise<Array<ImageGetPayload<T>>>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs>(
      args: SelectSubset<T, ImageCreateArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs>(
      args: SelectSubset<T, ImageDeleteArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs>(
      args: SelectSubset<T, ImageUpdateArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs>(
      args?: SelectSubset<T, ImageDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Images.
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs>(
      args: SelectSubset<T, ImageUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs>(
      args: SelectSubset<T, ImageUpsertArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Count the number of Images.
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Promise<GetImageAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Tournament<T extends TournamentFindManyArgs = {}>(args?: Subset<T, TournamentFindManyArgs>): CheckSelect<T, Promise<Array<Tournament>>, Promise<Array<TournamentGetPayload<T>>>>;

    News<T extends NewsFindManyArgs = {}>(args?: Subset<T, NewsFindManyArgs>): CheckSelect<T, Promise<Array<News>>, Promise<Array<NewsGetPayload<T>>>>;

    Team<T extends TeamFindManyArgs = {}>(args?: Subset<T, TeamFindManyArgs>): CheckSelect<T, Promise<Array<Team>>, Promise<Array<TeamGetPayload<T>>>>;

    TournamentMatchReport<T extends TournamentMatchReportArgs = {}>(args?: Subset<T, TournamentMatchReportArgs>): CheckSelect<T, Prisma__TournamentMatchReportClient<TournamentMatchReport | null>, Prisma__TournamentMatchReportClient<TournamentMatchReportGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Throw an Error if a Image can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Image to fetch.
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Throw an Error if a Image can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Image to fetch.
    **/
    where?: ImageWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Images to fetch.
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Images.
    **/
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Filter, which Images to fetch.
    **/
    where?: ImageWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Images to fetch.
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
    **/
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image create
   */
  export type ImageCreateArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * The data needed to create a Image.
    **/
    data: XOR<ImageUncheckedCreateInput, ImageCreateInput>
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * The data needed to update a Image.
    **/
    data: XOR<ImageUncheckedUpdateInput, ImageUpdateInput>
    /**
     * Choose, which Image to update.
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs = {
    data: XOR<ImageUncheckedUpdateManyInput, ImageUpdateManyMutationInput>
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * The filter to search for the Image to update in case it exists.
    **/
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
    **/
    create: XOR<ImageUncheckedCreateInput, ImageCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ImageUncheckedUpdateInput, ImageUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Filter which Image to delete.
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs = {
    where?: ImageWhereInput
  }


  /**
   * Image without action
   */
  export type ImageArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
  }



  /**
   * Model Game
   */


  export type AggregateGame = {
    count: GameCountAggregateOutputType | null
    min: GameMinAggregateOutputType | null
    max: GameMaxAggregateOutputType | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number | null
    name: number | null
    _all: number
  }


  export type GameMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GameAggregateArgs = {
    /**
     * Filter which Game to aggregate.
    **/
    where?: GameWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Games to fetch.
    **/
    orderBy?: Enumerable<GameOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
    [P in keyof T & keyof AggregateGame]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }



  export type GameSelect = {
    id?: boolean
    name?: boolean
    Tournament?: boolean | TournamentFindManyArgs
    RoomCode?: boolean | RoomCodeFindManyArgs
    GameAccount?: boolean | GameAccountFindManyArgs
  }

  export type GameInclude = {
    Tournament?: boolean | TournamentFindManyArgs
    RoomCode?: boolean | RoomCodeFindManyArgs
    GameAccount?: boolean | GameAccountFindManyArgs
  }

  export type GameGetPayload<
    S extends boolean | null | undefined | GameArgs,
    U = keyof S
      > = S extends true
        ? Game
    : S extends undefined
    ? never
    : S extends GameArgs | GameFindManyArgs
    ?'include' extends U
    ? Game  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Tournament'
        ? Array < TournamentGetPayload<S['include'][P]>>  :
        P extends 'RoomCode'
        ? Array < RoomCodeGetPayload<S['include'][P]>>  :
        P extends 'GameAccount'
        ? Array < GameAccountGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Game ?Game [P]
  : 
          P extends 'Tournament'
        ? Array < TournamentGetPayload<S['select'][P]>>  :
        P extends 'RoomCode'
        ? Array < RoomCodeGetPayload<S['select'][P]>>  :
        P extends 'GameAccount'
        ? Array < GameAccountGetPayload<S['select'][P]>>  : never
  } 
    : Game
  : Game


  type GameCountArgs = Merge<
    Omit<GameFindManyArgs, 'select' | 'include'> & {
      select?: GameCountAggregateInputType | true
    }
  >

  export interface GameDelegate {
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameFindUniqueArgs>(
      args: SelectSubset<T, GameFindUniqueArgs>
    ): CheckSelect<T, Prisma__GameClient<Game | null>, Prisma__GameClient<GameGetPayload<T> | null>>

    /**
     * Find the first Game that matches the filter.
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameFindFirstArgs>(
      args?: SelectSubset<T, GameFindFirstArgs>
    ): CheckSelect<T, Prisma__GameClient<Game | null>, Prisma__GameClient<GameGetPayload<T> | null>>

    /**
     * Find zero or more Games that matches the filter.
     * @param {GameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GameFindManyArgs>(
      args?: SelectSubset<T, GameFindManyArgs>
    ): CheckSelect<T, Promise<Array<Game>>, Promise<Array<GameGetPayload<T>>>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
    **/
    create<T extends GameCreateArgs>(
      args: SelectSubset<T, GameCreateArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
    **/
    delete<T extends GameDeleteArgs>(
      args: SelectSubset<T, GameDeleteArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameUpdateArgs>(
      args: SelectSubset<T, GameUpdateArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameDeleteManyArgs>(
      args?: SelectSubset<T, GameDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Games.
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameUpdateManyArgs>(
      args: SelectSubset<T, GameUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
    **/
    upsert<T extends GameUpsertArgs>(
      args: SelectSubset<T, GameUpsertArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Count the number of Games.
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Promise<GetGameAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GameClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Tournament<T extends TournamentFindManyArgs = {}>(args?: Subset<T, TournamentFindManyArgs>): CheckSelect<T, Promise<Array<Tournament>>, Promise<Array<TournamentGetPayload<T>>>>;

    RoomCode<T extends RoomCodeFindManyArgs = {}>(args?: Subset<T, RoomCodeFindManyArgs>): CheckSelect<T, Promise<Array<RoomCode>>, Promise<Array<RoomCodeGetPayload<T>>>>;

    GameAccount<T extends GameAccountFindManyArgs = {}>(args?: Subset<T, GameAccountFindManyArgs>): CheckSelect<T, Promise<Array<GameAccount>>, Promise<Array<GameAccountGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * Throw an Error if a Game can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Game to fetch.
    **/
    where: GameWhereUniqueInput
  }


  /**
   * Game findFirst
   */
  export type GameFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * Throw an Error if a Game can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Game to fetch.
    **/
    where?: GameWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Games to fetch.
    **/
    orderBy?: Enumerable<GameOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
    **/
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Games.
    **/
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Game findMany
   */
  export type GameFindManyArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * Filter, which Games to fetch.
    **/
    where?: GameWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Games to fetch.
    **/
    orderBy?: Enumerable<GameOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
    **/
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
    **/
    skip?: number
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Game create
   */
  export type GameCreateArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * The data needed to create a Game.
    **/
    data: XOR<GameUncheckedCreateInput, GameCreateInput>
  }


  /**
   * Game update
   */
  export type GameUpdateArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * The data needed to update a Game.
    **/
    data: XOR<GameUncheckedUpdateInput, GameUpdateInput>
    /**
     * Choose, which Game to update.
    **/
    where: GameWhereUniqueInput
  }


  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs = {
    data: XOR<GameUncheckedUpdateManyInput, GameUpdateManyMutationInput>
    where?: GameWhereInput
  }


  /**
   * Game upsert
   */
  export type GameUpsertArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * The filter to search for the Game to update in case it exists.
    **/
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
    **/
    create: XOR<GameUncheckedCreateInput, GameCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<GameUncheckedUpdateInput, GameUpdateInput>
  }


  /**
   * Game delete
   */
  export type GameDeleteArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
    /**
     * Filter which Game to delete.
    **/
    where: GameWhereUniqueInput
  }


  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs = {
    where?: GameWhereInput
  }


  /**
   * Game without action
   */
  export type GameArgs = {
    /**
     * Select specific fields to fetch from the Game
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameInclude | null
  }



  /**
   * Model GameAccount
   */


  export type AggregateGameAccount = {
    count: GameAccountCountAggregateOutputType | null
    avg: GameAccountAvgAggregateOutputType | null
    sum: GameAccountSumAggregateOutputType | null
    min: GameAccountMinAggregateOutputType | null
    max: GameAccountMaxAggregateOutputType | null
  }

  export type GameAccountAvgAggregateOutputType = {
    userId: number
  }

  export type GameAccountSumAggregateOutputType = {
    userId: number
  }

  export type GameAccountMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: number
  }

  export type GameAccountMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    userId: number
  }

  export type GameAccountCountAggregateOutputType = {
    id: number | null
    gameId: number | null
    userId: number
    _all: number
  }


  export type GameAccountAvgAggregateInputType = {
    userId?: true
  }

  export type GameAccountSumAggregateInputType = {
    userId?: true
  }

  export type GameAccountMinAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
  }

  export type GameAccountMaxAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
  }

  export type GameAccountCountAggregateInputType = {
    id?: true
    gameId?: true
    userId?: true
    _all?: true
  }

  export type GameAccountAggregateArgs = {
    /**
     * Filter which GameAccount to aggregate.
    **/
    where?: GameAccountWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of GameAccounts to fetch.
    **/
    orderBy?: Enumerable<GameAccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameAccounts
    **/
    count?: true | GameAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GameAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GameAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GameAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GameAccountMaxAggregateInputType
  }

  export type GetGameAccountAggregateType<T extends GameAccountAggregateArgs> = {
    [P in keyof T & keyof AggregateGameAccount]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameAccount[P]>
      : GetScalarType<T[P], AggregateGameAccount[P]>
  }



  export type GameAccountSelect = {
    id?: boolean
    game?: boolean | GameArgs
    user?: boolean | UserArgs
    gameId?: boolean
    userId?: boolean
  }

  export type GameAccountInclude = {
    game?: boolean | GameArgs
    user?: boolean | UserArgs
  }

  export type GameAccountGetPayload<
    S extends boolean | null | undefined | GameAccountArgs,
    U = keyof S
      > = S extends true
        ? GameAccount
    : S extends undefined
    ? never
    : S extends GameAccountArgs | GameAccountFindManyArgs
    ?'include' extends U
    ? GameAccount  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'game'
        ? GameGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GameAccount ?GameAccount [P]
  : 
          P extends 'game'
        ? GameGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : GameAccount
  : GameAccount


  type GameAccountCountArgs = Merge<
    Omit<GameAccountFindManyArgs, 'select' | 'include'> & {
      select?: GameAccountCountAggregateInputType | true
    }
  >

  export interface GameAccountDelegate {
    /**
     * Find zero or one GameAccount that matches the filter.
     * @param {GameAccountFindUniqueArgs} args - Arguments to find a GameAccount
     * @example
     * // Get one GameAccount
     * const gameAccount = await prisma.gameAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameAccountFindUniqueArgs>(
      args: SelectSubset<T, GameAccountFindUniqueArgs>
    ): CheckSelect<T, Prisma__GameAccountClient<GameAccount | null>, Prisma__GameAccountClient<GameAccountGetPayload<T> | null>>

    /**
     * Find the first GameAccount that matches the filter.
     * @param {GameAccountFindFirstArgs} args - Arguments to find a GameAccount
     * @example
     * // Get one GameAccount
     * const gameAccount = await prisma.gameAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameAccountFindFirstArgs>(
      args?: SelectSubset<T, GameAccountFindFirstArgs>
    ): CheckSelect<T, Prisma__GameAccountClient<GameAccount | null>, Prisma__GameAccountClient<GameAccountGetPayload<T> | null>>

    /**
     * Find zero or more GameAccounts that matches the filter.
     * @param {GameAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameAccounts
     * const gameAccounts = await prisma.gameAccount.findMany()
     * 
     * // Get first 10 GameAccounts
     * const gameAccounts = await prisma.gameAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameAccountWithIdOnly = await prisma.gameAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GameAccountFindManyArgs>(
      args?: SelectSubset<T, GameAccountFindManyArgs>
    ): CheckSelect<T, Promise<Array<GameAccount>>, Promise<Array<GameAccountGetPayload<T>>>>

    /**
     * Create a GameAccount.
     * @param {GameAccountCreateArgs} args - Arguments to create a GameAccount.
     * @example
     * // Create one GameAccount
     * const GameAccount = await prisma.gameAccount.create({
     *   data: {
     *     // ... data to create a GameAccount
     *   }
     * })
     * 
    **/
    create<T extends GameAccountCreateArgs>(
      args: SelectSubset<T, GameAccountCreateArgs>
    ): CheckSelect<T, Prisma__GameAccountClient<GameAccount>, Prisma__GameAccountClient<GameAccountGetPayload<T>>>

    /**
     * Delete a GameAccount.
     * @param {GameAccountDeleteArgs} args - Arguments to delete one GameAccount.
     * @example
     * // Delete one GameAccount
     * const GameAccount = await prisma.gameAccount.delete({
     *   where: {
     *     // ... filter to delete one GameAccount
     *   }
     * })
     * 
    **/
    delete<T extends GameAccountDeleteArgs>(
      args: SelectSubset<T, GameAccountDeleteArgs>
    ): CheckSelect<T, Prisma__GameAccountClient<GameAccount>, Prisma__GameAccountClient<GameAccountGetPayload<T>>>

    /**
     * Update one GameAccount.
     * @param {GameAccountUpdateArgs} args - Arguments to update one GameAccount.
     * @example
     * // Update one GameAccount
     * const gameAccount = await prisma.gameAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameAccountUpdateArgs>(
      args: SelectSubset<T, GameAccountUpdateArgs>
    ): CheckSelect<T, Prisma__GameAccountClient<GameAccount>, Prisma__GameAccountClient<GameAccountGetPayload<T>>>

    /**
     * Delete zero or more GameAccounts.
     * @param {GameAccountDeleteManyArgs} args - Arguments to filter GameAccounts to delete.
     * @example
     * // Delete a few GameAccounts
     * const { count } = await prisma.gameAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameAccountDeleteManyArgs>(
      args?: SelectSubset<T, GameAccountDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more GameAccounts.
     * @param {GameAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameAccounts
     * const gameAccount = await prisma.gameAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameAccountUpdateManyArgs>(
      args: SelectSubset<T, GameAccountUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one GameAccount.
     * @param {GameAccountUpsertArgs} args - Arguments to update or create a GameAccount.
     * @example
     * // Update or create a GameAccount
     * const gameAccount = await prisma.gameAccount.upsert({
     *   create: {
     *     // ... data to create a GameAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameAccount we want to update
     *   }
     * })
    **/
    upsert<T extends GameAccountUpsertArgs>(
      args: SelectSubset<T, GameAccountUpsertArgs>
    ): CheckSelect<T, Prisma__GameAccountClient<GameAccount>, Prisma__GameAccountClient<GameAccountGetPayload<T>>>

    /**
     * Count the number of GameAccounts.
     * @param {GameAccountCountArgs} args - Arguments to filter GameAccounts to count.
     * @example
     * // Count the number of GameAccounts
     * const count = await prisma.gameAccount.count({
     *   where: {
     *     // ... the filter for the GameAccounts we want to count
     *   }
     * })
    **/
    count<T extends GameAccountCountArgs>(
      args?: Subset<T, GameAccountCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameAccount.
     * @param {GameAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAccountAggregateArgs>(args: Subset<T, GameAccountAggregateArgs>): Promise<GetGameAccountAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for GameAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GameAccountClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    game<T extends GameArgs = {}>(args?: Subset<T, GameArgs>): CheckSelect<T, Prisma__GameClient<Game | null>, Prisma__GameClient<GameGetPayload<T> | null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GameAccount findUnique
   */
  export type GameAccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * Throw an Error if a GameAccount can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GameAccount to fetch.
    **/
    where: GameAccountWhereUniqueInput
  }


  /**
   * GameAccount findFirst
   */
  export type GameAccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * Throw an Error if a GameAccount can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GameAccount to fetch.
    **/
    where?: GameAccountWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of GameAccounts to fetch.
    **/
    orderBy?: Enumerable<GameAccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAccounts.
    **/
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of GameAccounts.
    **/
    distinct?: Enumerable<GameAccountScalarFieldEnum>
  }


  /**
   * GameAccount findMany
   */
  export type GameAccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * Filter, which GameAccounts to fetch.
    **/
    where?: GameAccountWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of GameAccounts to fetch.
    **/
    orderBy?: Enumerable<GameAccountOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameAccounts.
    **/
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
    **/
    skip?: number
    distinct?: Enumerable<GameAccountScalarFieldEnum>
  }


  /**
   * GameAccount create
   */
  export type GameAccountCreateArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * The data needed to create a GameAccount.
    **/
    data: XOR<GameAccountUncheckedCreateInput, GameAccountCreateInput>
  }


  /**
   * GameAccount update
   */
  export type GameAccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * The data needed to update a GameAccount.
    **/
    data: XOR<GameAccountUncheckedUpdateInput, GameAccountUpdateInput>
    /**
     * Choose, which GameAccount to update.
    **/
    where: GameAccountWhereUniqueInput
  }


  /**
   * GameAccount updateMany
   */
  export type GameAccountUpdateManyArgs = {
    data: XOR<GameAccountUncheckedUpdateManyInput, GameAccountUpdateManyMutationInput>
    where?: GameAccountWhereInput
  }


  /**
   * GameAccount upsert
   */
  export type GameAccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * The filter to search for the GameAccount to update in case it exists.
    **/
    where: GameAccountWhereUniqueInput
    /**
     * In case the GameAccount found by the `where` argument doesn't exist, create a new GameAccount with this data.
    **/
    create: XOR<GameAccountUncheckedCreateInput, GameAccountCreateInput>
    /**
     * In case the GameAccount was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<GameAccountUncheckedUpdateInput, GameAccountUpdateInput>
  }


  /**
   * GameAccount delete
   */
  export type GameAccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
    /**
     * Filter which GameAccount to delete.
    **/
    where: GameAccountWhereUniqueInput
  }


  /**
   * GameAccount deleteMany
   */
  export type GameAccountDeleteManyArgs = {
    where?: GameAccountWhereInput
  }


  /**
   * GameAccount without action
   */
  export type GameAccountArgs = {
    /**
     * Select specific fields to fetch from the GameAccount
    **/
    select?: GameAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GameAccountInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    compoundId: 'compoundId',
    userId: 'userId',
    providerType: 'providerType',
    providerId: 'providerId',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    accessTokenExpires: 'accessTokenExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    placement: 'placement',
    tournamentId: 'tournamentId',
    points: 'points'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expires: 'expires',
    sessionToken: 'sessionToken',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tournamentApplicationId: 'tournamentApplicationId',
    tournamentParticipationTeamId: 'tournamentParticipationTeamId',
    tournamentParticipationTournamentId: 'tournamentParticipationTournamentId',
    tournamentMatchStateId: 'tournamentMatchStateId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationRequestScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationRequestScalarFieldEnum = (typeof VerificationRequestScalarFieldEnum)[keyof typeof VerificationRequestScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    closed: 'closed',
    started: 'started',
    groupSize: 'groupSize',
    teamSize: 'teamSize',
    rounds: 'rounds',
    startsAt: 'startsAt',
    registrationClosesAt: 'registrationClosesAt',
    imageId: 'imageId',
    teamId: 'teamId',
    gameId: 'gameId'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    userId: 'userId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    userId: 'userId',
    imageId: 'imageId'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const TournamentApplicationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    tournamentId: 'tournamentId',
    teamId: 'teamId'
  };

  export type TournamentApplicationScalarFieldEnum = (typeof TournamentApplicationScalarFieldEnum)[keyof typeof TournamentApplicationScalarFieldEnum]


  export const TournamentGridElementScalarFieldEnum: {
    id: 'id',
    round: 'round',
    group: 'group',
    tournamentId: 'tournamentId',
    matchId: 'matchId',
    teamId: 'teamId'
  };

  export type TournamentGridElementScalarFieldEnum = (typeof TournamentGridElementScalarFieldEnum)[keyof typeof TournamentGridElementScalarFieldEnum]


  export const TournamentParticipationScalarFieldEnum: {
    placement: 'placement',
    matchId: 'matchId',
    tournamentId: 'tournamentId',
    teamId: 'teamId'
  };

  export type TournamentParticipationScalarFieldEnum = (typeof TournamentParticipationScalarFieldEnum)[keyof typeof TournamentParticipationScalarFieldEnum]


  export const TeamMembershipScalarFieldEnum: {
    role: 'role',
    invitedAt: 'invitedAt',
    joinedAt: 'joinedAt',
    userId: 'userId',
    teamId: 'teamId'
  };

  export type TeamMembershipScalarFieldEnum = (typeof TeamMembershipScalarFieldEnum)[keyof typeof TeamMembershipScalarFieldEnum]


  export const TeamInvitationScalarFieldEnum: {
    invitedAt: 'invitedAt',
    userId: 'userId',
    teamId: 'teamId'
  };

  export type TeamInvitationScalarFieldEnum = (typeof TeamInvitationScalarFieldEnum)[keyof typeof TeamInvitationScalarFieldEnum]


  export const TournamentMatchStateScalarFieldEnum: {
    id: 'id',
    state: 'state',
    createdAt: 'createdAt',
    accepted: 'accepted',
    matchId: 'matchId'
  };

  export type TournamentMatchStateScalarFieldEnum = (typeof TournamentMatchStateScalarFieldEnum)[keyof typeof TournamentMatchStateScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    imageId: 'imageId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TournamentMatchScalarFieldEnum: {
    id: 'id',
    joinUntil: 'joinUntil',
    createRoomUntil: 'createRoomUntil',
    state: 'state',
    roomCodeId: 'roomCodeId',
    tournamentId: 'tournamentId'
  };

  export type TournamentMatchScalarFieldEnum = (typeof TournamentMatchScalarFieldEnum)[keyof typeof TournamentMatchScalarFieldEnum]


  export const TournamentMatchReportScalarFieldEnum: {
    type: 'type',
    description: 'description',
    matchId: 'matchId',
    reporterId: 'reporterId'
  };

  export type TournamentMatchReportScalarFieldEnum = (typeof TournamentMatchReportScalarFieldEnum)[keyof typeof TournamentMatchReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    read: 'read',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const RoomCodeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    gameId: 'gameId'
  };

  export type RoomCodeScalarFieldEnum = (typeof RoomCodeScalarFieldEnum)[keyof typeof RoomCodeScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    path: 'path',
    width: 'width',
    height: 'height',
    caption: 'caption',
    tournamentMatchReportMatchId: 'tournamentMatchReportMatchId',
    tournamentMatchReportReporterId: 'tournamentMatchReportReporterId'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const GameAccountScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    userId: 'userId'
  };

  export type GameAccountScalarFieldEnum = (typeof GameAccountScalarFieldEnum)[keyof typeof GameAccountScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: IntFilter | number
    compoundId?: StringFilter | string
    userId?: IntFilter | number
    providerType?: StringFilter | string
    providerId?: StringFilter | string
    providerAccountId?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    accessToken?: StringNullableFilter | string | null
    accessTokenExpires?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AccountOrderByInput = {
    id?: SortOrder
    compoundId?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    accessTokenExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountWhereUniqueInput = {
    id?: number
    compoundId?: string
  }

  export type RewardWhereInput = {
    AND?: Enumerable<RewardWhereInput>
    OR?: Enumerable<RewardWhereInput>
    NOT?: Enumerable<RewardWhereInput>
    id?: IntFilter | number
    placement?: IntFilter | number
    tournamentId?: StringFilter | string
    tournament?: XOR<TournamentWhereInput, TournamentRelationFilter>
    points?: IntFilter | number
  }

  export type RewardOrderByInput = {
    id?: SortOrder
    placement?: SortOrder
    tournamentId?: SortOrder
    points?: SortOrder
  }

  export type RewardWhereUniqueInput = {
    id?: number
    tournamentId_placement?: RewardTournamentIdPlacementCompoundUniqueInput
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    expires?: DateTimeFilter | Date | string
    sessionToken?: StringFilter | string
    accessToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SessionOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    sessionToken?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionWhereUniqueInput = {
    id?: number
    sessionToken?: string
    accessToken?: string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    memberships?: TeamMembershipListRelationFilter
    notifications?: NotificationListRelationFilter
    gameAccounts?: GameAccountListRelationFilter
    Admin?: AdminListRelationFilter
    News?: NewsListRelationFilter
    TournamentApplication?: XOR<TournamentApplicationWhereInput, TournamentApplicationRelationFilter> | null
    tournamentApplicationId?: IntNullableFilter | number | null
    TournamentParticipation?: XOR<TournamentParticipationWhereInput, TournamentParticipationRelationFilter> | null
    tournamentParticipationTeamId?: StringNullableFilter | string | null
    tournamentParticipationTournamentId?: StringNullableFilter | string | null
    TeamInvitation?: TeamInvitationListRelationFilter
    TournamentMatchState?: XOR<TournamentMatchStateWhereInput, TournamentMatchStateRelationFilter> | null
    tournamentMatchStateId?: IntNullableFilter | number | null
    TournamentMatchReport?: TournamentMatchReportListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tournamentApplicationId?: SortOrder
    tournamentParticipationTeamId?: SortOrder
    tournamentParticipationTournamentId?: SortOrder
    tournamentMatchStateId?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type VerificationRequestWhereInput = {
    AND?: Enumerable<VerificationRequestWhereInput>
    OR?: Enumerable<VerificationRequestWhereInput>
    NOT?: Enumerable<VerificationRequestWhereInput>
    id?: IntFilter | number
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VerificationRequestOrderByInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationRequestWhereUniqueInput = {
    id?: number
    token?: string
  }

  export type TournamentWhereInput = {
    AND?: Enumerable<TournamentWhereInput>
    OR?: Enumerable<TournamentWhereInput>
    NOT?: Enumerable<TournamentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    closed?: BoolFilter | boolean
    started?: BoolFilter | boolean
    organizer?: XOR<TeamWhereInput, TeamRelationFilter>
    game?: XOR<GameWhereInput, GameRelationFilter>
    icon?: XOR<ImageWhereInput, ImageRelationFilter> | null
    groupSize?: IntFilter | number
    teamSize?: IntFilter | number
    rounds?: IntFilter | number
    startsAt?: DateTimeFilter | Date | string
    registrationClosesAt?: DateTimeFilter | Date | string
    participants?: TournamentParticipationListRelationFilter
    applicants?: TournamentApplicationListRelationFilter
    rewards?: RewardListRelationFilter
    imageId?: IntNullableFilter | number | null
    teamId?: StringFilter | string
    gameId?: StringFilter | string
    TournamentGridElement?: TournamentGridElementListRelationFilter
    TournamentMatch?: TournamentMatchListRelationFilter
  }

  export type TournamentOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    closed?: SortOrder
    started?: SortOrder
    groupSize?: SortOrder
    teamSize?: SortOrder
    rounds?: SortOrder
    startsAt?: SortOrder
    registrationClosesAt?: SortOrder
    imageId?: SortOrder
    teamId?: SortOrder
    gameId?: SortOrder
  }

  export type TournamentWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    userId?: IntFilter | number
    user?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type AdminOrderByInput = {
    userId?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    userId?: number
  }

  export type NewsWhereInput = {
    AND?: Enumerable<NewsWhereInput>
    OR?: Enumerable<NewsWhereInput>
    NOT?: Enumerable<NewsWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    author?: XOR<UserWhereInput, UserRelationFilter>
    cover?: XOR<ImageWhereInput, ImageRelationFilter> | null
    userId?: IntFilter | number
    imageId?: IntNullableFilter | number | null
  }

  export type NewsOrderByInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    imageId?: SortOrder
  }

  export type NewsWhereUniqueInput = {
    id?: number
  }

  export type TournamentApplicationWhereInput = {
    AND?: Enumerable<TournamentApplicationWhereInput>
    OR?: Enumerable<TournamentApplicationWhereInput>
    NOT?: Enumerable<TournamentApplicationWhereInput>
    id?: IntFilter | number
    tournament?: XOR<TournamentWhereInput, TournamentRelationFilter>
    team?: XOR<TeamWhereInput, TeamRelationFilter>
    players?: UserListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    tournamentId?: StringFilter | string
    teamId?: StringFilter | string
  }

  export type TournamentApplicationOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
  }

  export type TournamentApplicationWhereUniqueInput = {
    id?: number
    teamId_tournamentId?: TournamentApplicationTeamIdTournamentIdCompoundUniqueInput
  }

  export type TournamentGridElementWhereInput = {
    AND?: Enumerable<TournamentGridElementWhereInput>
    OR?: Enumerable<TournamentGridElementWhereInput>
    NOT?: Enumerable<TournamentGridElementWhereInput>
    id?: IntFilter | number
    tournament?: XOR<TournamentWhereInput, TournamentRelationFilter>
    participant?: XOR<TournamentParticipationWhereInput, TournamentParticipationRelationFilter>
    round?: IntFilter | number
    group?: IntFilter | number
    match?: XOR<TournamentMatchWhereInput, TournamentMatchRelationFilter> | null
    tournamentId?: StringFilter | string
    matchId?: IntNullableFilter | number | null
    teamId?: StringFilter | string
  }

  export type TournamentGridElementOrderByInput = {
    id?: SortOrder
    round?: SortOrder
    group?: SortOrder
    tournamentId?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
  }

  export type TournamentGridElementWhereUniqueInput = {
    id?: number
    teamId_matchId?: TournamentGridElementTeamIdMatchIdCompoundUniqueInput
    tournamentId_teamId_group_round?: TournamentGridElementTournamentIdTeamIdGroupRoundCompoundUniqueInput
  }

  export type TournamentParticipationWhereInput = {
    AND?: Enumerable<TournamentParticipationWhereInput>
    OR?: Enumerable<TournamentParticipationWhereInput>
    NOT?: Enumerable<TournamentParticipationWhereInput>
    team?: XOR<TeamWhereInput, TeamRelationFilter>
    tournament?: XOR<TournamentWhereInput, TournamentRelationFilter>
    players?: UserListRelationFilter
    match?: XOR<TournamentMatchWhereInput, TournamentMatchRelationFilter> | null
    placement?: IntNullableFilter | number | null
    matchId?: IntNullableFilter | number | null
    tournamentId?: StringFilter | string
    teamId?: StringFilter | string
    TournamentGridElement?: TournamentGridElementListRelationFilter
  }

  export type TournamentParticipationOrderByInput = {
    placement?: SortOrder
    matchId?: SortOrder
    tournamentId?: SortOrder
    teamId?: SortOrder
  }

  export type TournamentParticipationWhereUniqueInput = {
    teamId_tournamentId?: TournamentParticipationTeamIdTournamentIdCompoundUniqueInput
  }

  export type TeamMembershipWhereInput = {
    AND?: Enumerable<TeamMembershipWhereInput>
    OR?: Enumerable<TeamMembershipWhereInput>
    NOT?: Enumerable<TeamMembershipWhereInput>
    user?: XOR<UserWhereInput, UserRelationFilter>
    team?: XOR<TeamWhereInput, TeamRelationFilter>
    role?: EnumTeamRoleTypeFilter | TeamRoleType
    invitedAt?: DateTimeFilter | Date | string
    joinedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    teamId?: StringFilter | string
  }

  export type TeamMembershipOrderByInput = {
    role?: SortOrder
    invitedAt?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
  }

  export type TeamMembershipWhereUniqueInput = {
    userId_teamId?: TeamMembershipUserIdTeamIdCompoundUniqueInput
  }

  export type TeamInvitationWhereInput = {
    AND?: Enumerable<TeamInvitationWhereInput>
    OR?: Enumerable<TeamInvitationWhereInput>
    NOT?: Enumerable<TeamInvitationWhereInput>
    user?: XOR<UserWhereInput, UserRelationFilter>
    team?: XOR<TeamWhereInput, TeamRelationFilter>
    invitedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    teamId?: StringFilter | string
  }

  export type TeamInvitationOrderByInput = {
    invitedAt?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
  }

  export type TeamInvitationWhereUniqueInput = {
    userId_teamId?: TeamInvitationUserIdTeamIdCompoundUniqueInput
  }

  export type TournamentMatchStateWhereInput = {
    AND?: Enumerable<TournamentMatchStateWhereInput>
    OR?: Enumerable<TournamentMatchStateWhereInput>
    NOT?: Enumerable<TournamentMatchStateWhereInput>
    id?: IntFilter | number
    state?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    acceptedBy?: UserListRelationFilter
    match?: XOR<TournamentMatchWhereInput, TournamentMatchRelationFilter>
    accepted?: BoolFilter | boolean
    matchId?: IntFilter | number
  }

  export type TournamentMatchStateOrderByInput = {
    id?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    accepted?: SortOrder
    matchId?: SortOrder
  }

  export type TournamentMatchStateWhereUniqueInput = {
    id?: number
    state_matchId?: TournamentMatchStateStateMatchIdCompoundUniqueInput
  }

  export type TeamWhereInput = {
    AND?: Enumerable<TeamWhereInput>
    OR?: Enumerable<TeamWhereInput>
    NOT?: Enumerable<TeamWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    icon?: XOR<ImageWhereInput, ImageRelationFilter> | null
    members?: TeamMembershipListRelationFilter
    Tournament?: TournamentListRelationFilter
    TournamentApplication?: TournamentApplicationListRelationFilter
    TournamentParticipation?: TournamentParticipationListRelationFilter
    TeamInvitation?: TeamInvitationListRelationFilter
    imageId?: IntNullableFilter | number | null
  }

  export type TeamOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    imageId?: SortOrder
  }

  export type TeamWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type TournamentMatchWhereInput = {
    AND?: Enumerable<TournamentMatchWhereInput>
    OR?: Enumerable<TournamentMatchWhereInput>
    NOT?: Enumerable<TournamentMatchWhereInput>
    id?: IntFilter | number
    tournament?: XOR<TournamentWhereInput, TournamentRelationFilter>
    roomCode?: XOR<RoomCodeWhereInput, RoomCodeRelationFilter>
    participants?: TournamentParticipationListRelationFilter
    joinUntil?: DateTimeNullableFilter | Date | string | null
    createRoomUntil?: DateTimeFilter | Date | string
    state?: EnumMatchStateTypeFilter | MatchStateType
    roomCodeId?: IntFilter | number
    tournamentId?: StringFilter | string
    TournamentGridElement?: TournamentGridElementListRelationFilter
    TournamentMatchState?: TournamentMatchStateListRelationFilter
    TournamentMatchReport?: TournamentMatchReportListRelationFilter
  }

  export type TournamentMatchOrderByInput = {
    id?: SortOrder
    joinUntil?: SortOrder
    createRoomUntil?: SortOrder
    state?: SortOrder
    roomCodeId?: SortOrder
    tournamentId?: SortOrder
  }

  export type TournamentMatchWhereUniqueInput = {
    id?: number
  }

  export type TournamentMatchReportWhereInput = {
    AND?: Enumerable<TournamentMatchReportWhereInput>
    OR?: Enumerable<TournamentMatchReportWhereInput>
    NOT?: Enumerable<TournamentMatchReportWhereInput>
    reporter?: XOR<UserWhereInput, UserRelationFilter>
    match?: XOR<TournamentMatchWhereInput, TournamentMatchRelationFilter>
    type?: EnumReportTypeFilter | ReportType
    description?: StringFilter | string
    attachments?: ImageListRelationFilter
    matchId?: IntFilter | number
    reporterId?: IntFilter | number
  }

  export type TournamentMatchReportOrderByInput = {
    type?: SortOrder
    description?: SortOrder
    matchId?: SortOrder
    reporterId?: SortOrder
  }

  export type TournamentMatchReportWhereUniqueInput = {
    matchId_reporterId?: TournamentMatchReportMatchIdReporterIdCompoundUniqueInput
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: IntFilter | number
    type?: EnumNotificationTypeNullableFilter | NotificationType | null
    title?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    read?: BoolFilter | boolean
    user?: XOR<UserWhereInput, UserRelationFilter>
    userId?: IntFilter | number
  }

  export type NotificationOrderByInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    read?: SortOrder
    userId?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    id?: number
  }

  export type RoomCodeWhereInput = {
    AND?: Enumerable<RoomCodeWhereInput>
    OR?: Enumerable<RoomCodeWhereInput>
    NOT?: Enumerable<RoomCodeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    password?: StringNullableFilter | string | null
    game?: XOR<GameWhereInput, GameRelationFilter>
    gameId?: StringFilter | string
    TournamentMatch?: TournamentMatchListRelationFilter
  }

  export type RoomCodeOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    gameId?: SortOrder
  }

  export type RoomCodeWhereUniqueInput = {
    id?: number
  }

  export type ImageWhereInput = {
    AND?: Enumerable<ImageWhereInput>
    OR?: Enumerable<ImageWhereInput>
    NOT?: Enumerable<ImageWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    caption?: StringNullableFilter | string | null
    Tournament?: TournamentListRelationFilter
    News?: NewsListRelationFilter
    Team?: TeamListRelationFilter
    TournamentMatchReport?: XOR<TournamentMatchReportWhereInput, TournamentMatchReportRelationFilter> | null
    tournamentMatchReportMatchId?: IntNullableFilter | number | null
    tournamentMatchReportReporterId?: IntNullableFilter | number | null
  }

  export type ImageOrderByInput = {
    id?: SortOrder
    path?: SortOrder
    width?: SortOrder
    height?: SortOrder
    caption?: SortOrder
    tournamentMatchReportMatchId?: SortOrder
    tournamentMatchReportReporterId?: SortOrder
  }

  export type ImageWhereUniqueInput = {
    id?: number
  }

  export type GameWhereInput = {
    AND?: Enumerable<GameWhereInput>
    OR?: Enumerable<GameWhereInput>
    NOT?: Enumerable<GameWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    Tournament?: TournamentListRelationFilter
    RoomCode?: RoomCodeListRelationFilter
    GameAccount?: GameAccountListRelationFilter
  }

  export type GameOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GameWhereUniqueInput = {
    id?: string
  }

  export type GameAccountWhereInput = {
    AND?: Enumerable<GameAccountWhereInput>
    OR?: Enumerable<GameAccountWhereInput>
    NOT?: Enumerable<GameAccountWhereInput>
    id?: StringFilter | string
    game?: XOR<GameWhereInput, GameRelationFilter>
    user?: XOR<UserWhereInput, UserRelationFilter>
    gameId?: StringFilter | string
    userId?: IntFilter | number
  }

  export type GameAccountOrderByInput = {
    id?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
  }

  export type GameAccountWhereUniqueInput = {
    id?: string
  }

  export type AccountCreateInput = {
    compoundId: string
    userId: number
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    compoundId: string
    userId: number
    providerType: string
    providerId: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    accessTokenExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    compoundId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    compoundId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateManyMutationInput = {
    compoundId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    compoundId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardCreateInput = {
    placement: number
    points: number
    tournament: TournamentCreateOneWithoutRewardsInput
  }

  export type RewardUncheckedCreateInput = {
    id?: number
    placement: number
    tournamentId: string
    points: number
  }

  export type RewardUpdateInput = {
    placement?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    tournament?: TournamentUpdateOneRequiredWithoutRewardsInput
  }

  export type RewardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placement?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type RewardUpdateManyMutationInput = {
    placement?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type RewardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placement?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateInput = {
    userId: number
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: number
    expires: Date | string
    sessionToken: string
    accessToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VerificationRequestCreateInput = {
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestUncheckedCreateInput = {
    id?: number
    identifier: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationRequestUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentCreateInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateInput = {
    user: UserCreateOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    userId: number
  }

  export type AdminUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAdminInput
  }

  export type AdminUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUpdateManyMutationInput = {

  }

  export type AdminUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NewsCreateInput = {
    title: string
    content: InputJsonValue
    createdAt?: Date | string
    author: UserCreateOneWithoutNewsInput
    cover?: ImageCreateOneWithoutNewsInput
  }

  export type NewsUncheckedCreateInput = {
    id?: number
    title: string
    content: InputJsonValue
    createdAt?: Date | string
    userId: number
    imageId?: number | null
  }

  export type NewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutNewsInput
    cover?: ImageUpdateOneWithoutNewsInput
  }

  export type NewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentApplicationCreateInput = {
    createdAt?: Date | string
    tournament: TournamentCreateOneWithoutApplicantsInput
    team: TeamCreateOneWithoutTournamentApplicationInput
    players?: UserCreateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    tournamentId: string
    teamId: string
    players?: UserUncheckedCreateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneRequiredWithoutApplicantsInput
    team?: TeamUpdateOneRequiredWithoutTournamentApplicationInput
    players?: UserUpdateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentApplicationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentGridElementCreateInput = {
    round: number
    group: number
    tournament: TournamentCreateOneWithoutTournamentGridElementInput
    participant: TournamentParticipationCreateOneWithoutTournamentGridElementInput
    match?: TournamentMatchCreateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedCreateInput = {
    id?: number
    round: number
    group: number
    tournamentId: string
    matchId?: number | null
    teamId: string
  }

  export type TournamentGridElementUpdateInput = {
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    tournament?: TournamentUpdateOneRequiredWithoutTournamentGridElementInput
    participant?: TournamentParticipationUpdateOneRequiredWithoutTournamentGridElementInput
    match?: TournamentMatchUpdateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentGridElementUpdateManyMutationInput = {
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentGridElementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentParticipationCreateInput = {
    placement?: number | null
    team: TeamCreateOneWithoutTournamentParticipationInput
    tournament: TournamentCreateOneWithoutParticipantsInput
    players?: UserCreateManyWithoutTournamentParticipationInput
    match?: TournamentMatchCreateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedCreateInput = {
    placement?: number | null
    matchId?: number | null
    tournamentId: string
    teamId: string
    players?: UserUncheckedCreateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationUpdateInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutTournamentParticipationInput
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsInput
    players?: UserUpdateManyWithoutTournamentParticipationInput
    match?: TournamentMatchUpdateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUpdateManyMutationInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentParticipationUncheckedUpdateManyInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMembershipCreateInput = {
    role: TeamRoleType
    invitedAt: Date | string
    joinedAt?: Date | string
    user: UserCreateOneWithoutMembershipsInput
    team: TeamCreateOneWithoutMembersInput
  }

  export type TeamMembershipUncheckedCreateInput = {
    role: TeamRoleType
    invitedAt: Date | string
    joinedAt?: Date | string
    userId: number
    teamId: string
  }

  export type TeamMembershipUpdateInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsInput
    team?: TeamUpdateOneRequiredWithoutMembersInput
  }

  export type TeamMembershipUncheckedUpdateInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMembershipUpdateManyMutationInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMembershipUncheckedUpdateManyInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInvitationCreateInput = {
    invitedAt?: Date | string
    user: UserCreateOneWithoutTeamInvitationInput
    team: TeamCreateOneWithoutTeamInvitationInput
  }

  export type TeamInvitationUncheckedCreateInput = {
    invitedAt?: Date | string
    userId: number
    teamId: string
  }

  export type TeamInvitationUpdateInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamInvitationInput
    team?: TeamUpdateOneRequiredWithoutTeamInvitationInput
  }

  export type TeamInvitationUncheckedUpdateInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInvitationUpdateManyMutationInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUncheckedUpdateManyInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentMatchStateCreateInput = {
    state: InputJsonValue
    createdAt?: Date | string
    accepted: boolean
    acceptedBy?: UserCreateManyWithoutTournamentMatchStateInput
    match: TournamentMatchCreateOneWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedCreateInput = {
    id?: number
    state: InputJsonValue
    createdAt?: Date | string
    accepted: boolean
    matchId: number
    acceptedBy?: UserUncheckedCreateManyWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUpdateInput = {
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    acceptedBy?: UserUpdateManyWithoutTournamentMatchStateInput
    match?: TournamentMatchUpdateOneRequiredWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    matchId?: IntFieldUpdateOperationsInput | number
    acceptedBy?: UserUncheckedUpdateManyWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUpdateManyMutationInput = {
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentMatchStateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    matchId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamCreateInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    icon?: ImageCreateOneWithoutTeamInput
    members?: TeamMembershipCreateManyWithoutTeamInput
    Tournament?: TournamentCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    imageId?: number | null
    members?: TeamMembershipUncheckedCreateManyWithoutTeamInput
    Tournament?: TournamentUncheckedCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: ImageUpdateOneWithoutTeamInput
    members?: TeamMembershipUpdateManyWithoutTeamInput
    Tournament?: TournamentUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamInput
    Tournament?: TournamentUncheckedUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchCreateInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournament: TournamentCreateOneWithoutTournamentMatchInput
    roomCode: RoomCodeCreateOneWithoutTournamentMatchInput
    participants?: TournamentParticipationCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCodeId: number
    tournamentId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchUpdateInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournament?: TournamentUpdateOneRequiredWithoutTournamentMatchInput
    roomCode?: RoomCodeUpdateOneRequiredWithoutTournamentMatchInput
    participants?: TournamentParticipationUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUpdateManyMutationInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
  }

  export type TournamentMatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentMatchReportCreateInput = {
    type: ReportType
    description: string
    reporter: UserCreateOneWithoutTournamentMatchReportInput
    match: TournamentMatchCreateOneWithoutTournamentMatchReportInput
    attachments?: ImageCreateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedCreateInput = {
    type: ReportType
    description: string
    matchId: number
    reporterId: number
    attachments?: ImageUncheckedCreateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUpdateInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    reporter?: UserUpdateOneRequiredWithoutTournamentMatchReportInput
    match?: TournamentMatchUpdateOneRequiredWithoutTournamentMatchReportInput
    attachments?: ImageUpdateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedUpdateInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    matchId?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    attachments?: ImageUncheckedUpdateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUpdateManyMutationInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentMatchReportUncheckedUpdateManyInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    matchId?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    type?: NotificationType | null
    title: string
    description: string
    createdAt?: Date | string
    read: boolean
    user: UserCreateOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    type?: NotificationType | null
    title: string
    description: string
    createdAt?: Date | string
    read: boolean
    userId: number
  }

  export type NotificationUpdateInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationsInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateManyMutationInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomCodeCreateInput = {
    name: string
    password?: string | null
    game: GameCreateOneWithoutRoomCodeInput
    TournamentMatch?: TournamentMatchCreateManyWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedCreateInput = {
    id?: number
    name: string
    password?: string | null
    gameId: string
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutRoomCodeInput
  }

  export type RoomCodeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    game?: GameUpdateOneRequiredWithoutRoomCodeInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutRoomCodeInput
  }

  export type RoomCodeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    path: string
    width: number
    height: number
    caption?: string | null
    Tournament?: TournamentCreateManyWithoutIconInput
    News?: NewsCreateManyWithoutCoverInput
    Team?: TeamCreateManyWithoutIconInput
    TournamentMatchReport?: TournamentMatchReportCreateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    path: string
    width: number
    height: number
    caption?: string | null
    tournamentMatchReportMatchId?: number | null
    tournamentMatchReportReporterId?: number | null
    Tournament?: TournamentUncheckedCreateManyWithoutIconInput
    News?: NewsUncheckedCreateManyWithoutCoverInput
    Team?: TeamUncheckedCreateManyWithoutIconInput
  }

  export type ImageUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Tournament?: TournamentUpdateManyWithoutIconInput
    News?: NewsUpdateManyWithoutCoverInput
    Team?: TeamUpdateManyWithoutIconInput
    TournamentMatchReport?: TournamentMatchReportUpdateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchReportMatchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentMatchReportReporterId?: NullableIntFieldUpdateOperationsInput | number | null
    Tournament?: TournamentUncheckedUpdateManyWithoutIconInput
    News?: NewsUncheckedUpdateManyWithoutCoverInput
    Team?: TeamUncheckedUpdateManyWithoutIconInput
  }

  export type ImageUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchReportMatchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentMatchReportReporterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameCreateInput = {
    id: string
    name: string
    Tournament?: TournamentCreateManyWithoutGameInput
    RoomCode?: RoomCodeCreateManyWithoutGameInput
    GameAccount?: GameAccountCreateManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id: string
    name: string
    Tournament?: TournamentUncheckedCreateManyWithoutGameInput
    RoomCode?: RoomCodeUncheckedCreateManyWithoutGameInput
    GameAccount?: GameAccountUncheckedCreateManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUpdateManyWithoutGameInput
    RoomCode?: RoomCodeUpdateManyWithoutGameInput
    GameAccount?: GameAccountUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUncheckedUpdateManyWithoutGameInput
    RoomCode?: RoomCodeUncheckedUpdateManyWithoutGameInput
    GameAccount?: GameAccountUncheckedUpdateManyWithoutGameInput
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GameAccountCreateInput = {
    id: string
    game: GameCreateOneWithoutGameAccountInput
    user: UserCreateOneWithoutGameAccountsInput
  }

  export type GameAccountUncheckedCreateInput = {
    id: string
    gameId: string
    userId: number
  }

  export type GameAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneRequiredWithoutGameAccountInput
    user?: UserUpdateOneRequiredWithoutGameAccountsInput
  }

  export type GameAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GameAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type GameAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type TournamentRelationFilter = {
    is?: TournamentWhereInput
    isNot?: TournamentWhereInput
  }

  export type RewardTournamentIdPlacementCompoundUniqueInput = {
    tournamentId: string
    placement: number
  }

  export type TeamMembershipListRelationFilter = {
    every?: TeamMembershipWhereInput
    some?: TeamMembershipWhereInput
    none?: TeamMembershipWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type GameAccountListRelationFilter = {
    every?: GameAccountWhereInput
    some?: GameAccountWhereInput
    none?: GameAccountWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type NewsListRelationFilter = {
    every?: NewsWhereInput
    some?: NewsWhereInput
    none?: NewsWhereInput
  }

  export type TournamentApplicationRelationFilter = {
    is?: TournamentApplicationWhereInput | null
    isNot?: TournamentApplicationWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type TournamentParticipationRelationFilter = {
    is?: TournamentParticipationWhereInput
    isNot?: TournamentParticipationWhereInput
  }

  export type TeamInvitationListRelationFilter = {
    every?: TeamInvitationWhereInput
    some?: TeamInvitationWhereInput
    none?: TeamInvitationWhereInput
  }

  export type TournamentMatchStateRelationFilter = {
    is?: TournamentMatchStateWhereInput | null
    isNot?: TournamentMatchStateWhereInput | null
  }

  export type TournamentMatchReportListRelationFilter = {
    every?: TournamentMatchReportWhereInput
    some?: TournamentMatchReportWhereInput
    none?: TournamentMatchReportWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type ImageRelationFilter = {
    is?: ImageWhereInput | null
    isNot?: ImageWhereInput | null
  }

  export type TournamentParticipationListRelationFilter = {
    every?: TournamentParticipationWhereInput
    some?: TournamentParticipationWhereInput
    none?: TournamentParticipationWhereInput
  }

  export type TournamentApplicationListRelationFilter = {
    every?: TournamentApplicationWhereInput
    some?: TournamentApplicationWhereInput
    none?: TournamentApplicationWhereInput
  }

  export type RewardListRelationFilter = {
    every?: RewardWhereInput
    some?: RewardWhereInput
    none?: RewardWhereInput
  }

  export type TournamentGridElementListRelationFilter = {
    every?: TournamentGridElementWhereInput
    some?: TournamentGridElementWhereInput
    none?: TournamentGridElementWhereInput
  }

  export type TournamentMatchListRelationFilter = {
    every?: TournamentMatchWhereInput
    some?: TournamentMatchWhereInput
    none?: TournamentMatchWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type JsonFilter = {
    equals?: InputJsonValue
    not?: InputJsonValue
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TournamentApplicationTeamIdTournamentIdCompoundUniqueInput = {
    teamId: string
    tournamentId: string
  }

  export type TournamentMatchRelationFilter = {
    is?: TournamentMatchWhereInput | null
    isNot?: TournamentMatchWhereInput | null
  }

  export type TournamentGridElementTeamIdMatchIdCompoundUniqueInput = {
    teamId: string
    matchId: number
  }

  export type TournamentGridElementTournamentIdTeamIdGroupRoundCompoundUniqueInput = {
    tournamentId: string
    teamId: string
    group: number
    round: number
  }

  export type TournamentParticipationTeamIdTournamentIdCompoundUniqueInput = {
    teamId: string
    tournamentId: string
  }

  export type EnumTeamRoleTypeFilter = {
    equals?: TeamRoleType
    in?: Enumerable<TeamRoleType>
    notIn?: Enumerable<TeamRoleType>
    not?: NestedEnumTeamRoleTypeFilter | TeamRoleType
  }

  export type TeamMembershipUserIdTeamIdCompoundUniqueInput = {
    userId: number
    teamId: string
  }

  export type TeamInvitationUserIdTeamIdCompoundUniqueInput = {
    userId: number
    teamId: string
  }

  export type TournamentMatchStateStateMatchIdCompoundUniqueInput = {
    state: InputJsonValue
    matchId: number
  }

  export type TournamentListRelationFilter = {
    every?: TournamentWhereInput
    some?: TournamentWhereInput
    none?: TournamentWhereInput
  }

  export type RoomCodeRelationFilter = {
    is?: RoomCodeWhereInput
    isNot?: RoomCodeWhereInput
  }

  export type EnumMatchStateTypeFilter = {
    equals?: MatchStateType
    in?: Enumerable<MatchStateType>
    notIn?: Enumerable<MatchStateType>
    not?: NestedEnumMatchStateTypeFilter | MatchStateType
  }

  export type TournamentMatchStateListRelationFilter = {
    every?: TournamentMatchStateWhereInput
    some?: TournamentMatchStateWhereInput
    none?: TournamentMatchStateWhereInput
  }

  export type EnumReportTypeFilter = {
    equals?: ReportType
    in?: Enumerable<ReportType>
    notIn?: Enumerable<ReportType>
    not?: NestedEnumReportTypeFilter | ReportType
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type TournamentMatchReportMatchIdReporterIdCompoundUniqueInput = {
    matchId: number
    reporterId: number
  }

  export type EnumNotificationTypeNullableFilter = {
    equals?: NotificationType | null
    in?: Enumerable<NotificationType> | null
    notIn?: Enumerable<NotificationType> | null
    not?: NestedEnumNotificationTypeNullableFilter | NotificationType | null
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TournamentMatchReportRelationFilter = {
    is?: TournamentMatchReportWhereInput | null
    isNot?: TournamentMatchReportWhereInput | null
  }

  export type RoomCodeListRelationFilter = {
    every?: RoomCodeWhereInput
    some?: RoomCodeWhereInput
    none?: RoomCodeWhereInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TournamentCreateOneWithoutRewardsInput = {
    create?: XOR<TournamentUncheckedCreateWithoutRewardsInput, TournamentCreateWithoutRewardsInput>
    connect?: TournamentWhereUniqueInput
    connectOrCreate?: TournamentCreateOrConnectWithoutrewardsInput
  }

  export type TournamentUpdateOneRequiredWithoutRewardsInput = {
    create?: XOR<TournamentUncheckedCreateWithoutRewardsInput, TournamentCreateWithoutRewardsInput>
    connect?: TournamentWhereUniqueInput
    update?: XOR<TournamentUncheckedUpdateWithoutRewardsInput, TournamentUpdateWithoutRewardsInput>
    upsert?: TournamentUpsertWithoutRewardsInput
    connectOrCreate?: TournamentCreateOrConnectWithoutrewardsInput
  }

  export type TeamMembershipCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutUserInput>, Enumerable<TeamMembershipCreateWithoutUserInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutuserInput>
  }

  export type NotificationCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationUncheckedCreateWithoutUserInput>, Enumerable<NotificationCreateWithoutUserInput>>
    connect?: Enumerable<NotificationWhereUniqueInput>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutuserInput>
  }

  export type GameAccountCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutUserInput>, Enumerable<GameAccountCreateWithoutUserInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutuserInput>
  }

  export type AdminCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminUncheckedCreateWithoutUserInput>, Enumerable<AdminCreateWithoutUserInput>>
    connect?: Enumerable<AdminWhereUniqueInput>
    connectOrCreate?: Enumerable<AdminCreateOrConnectWithoutuserInput>
  }

  export type NewsCreateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutAuthorInput>, Enumerable<NewsCreateWithoutAuthorInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutauthorInput>
  }

  export type TournamentApplicationCreateOneWithoutPlayersInput = {
    create?: XOR<TournamentApplicationUncheckedCreateWithoutPlayersInput, TournamentApplicationCreateWithoutPlayersInput>
    connect?: TournamentApplicationWhereUniqueInput
    connectOrCreate?: TournamentApplicationCreateOrConnectWithoutplayersInput
  }

  export type TournamentParticipationCreateOneWithoutPlayersInput = {
    create?: XOR<TournamentParticipationUncheckedCreateWithoutPlayersInput, TournamentParticipationCreateWithoutPlayersInput>
    connect?: TournamentParticipationWhereUniqueInput
    connectOrCreate?: TournamentParticipationCreateOrConnectWithoutplayersInput
  }

  export type TeamInvitationCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutUserInput>, Enumerable<TeamInvitationCreateWithoutUserInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutuserInput>
  }

  export type TournamentMatchStateCreateOneWithoutAcceptedByInput = {
    create?: XOR<TournamentMatchStateUncheckedCreateWithoutAcceptedByInput, TournamentMatchStateCreateWithoutAcceptedByInput>
    connect?: TournamentMatchStateWhereUniqueInput
    connectOrCreate?: TournamentMatchStateCreateOrConnectWithoutacceptedByInput
  }

  export type TournamentMatchReportCreateManyWithoutReporterInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutReporterInput>, Enumerable<TournamentMatchReportCreateWithoutReporterInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutreporterInput>
  }

  export type TeamMembershipUncheckedCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutUserInput>, Enumerable<TeamMembershipCreateWithoutUserInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutuserInput>
  }

  export type NotificationUncheckedCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationUncheckedCreateWithoutUserInput>, Enumerable<NotificationCreateWithoutUserInput>>
    connect?: Enumerable<NotificationWhereUniqueInput>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutuserInput>
  }

  export type GameAccountUncheckedCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutUserInput>, Enumerable<GameAccountCreateWithoutUserInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutuserInput>
  }

  export type AdminUncheckedCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminUncheckedCreateWithoutUserInput>, Enumerable<AdminCreateWithoutUserInput>>
    connect?: Enumerable<AdminWhereUniqueInput>
    connectOrCreate?: Enumerable<AdminCreateOrConnectWithoutuserInput>
  }

  export type NewsUncheckedCreateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutAuthorInput>, Enumerable<NewsCreateWithoutAuthorInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutauthorInput>
  }

  export type TeamInvitationUncheckedCreateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutUserInput>, Enumerable<TeamInvitationCreateWithoutUserInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutuserInput>
  }

  export type TournamentMatchReportUncheckedCreateManyWithoutReporterInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutReporterInput>, Enumerable<TournamentMatchReportCreateWithoutReporterInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutreporterInput>
  }

  export type TeamMembershipUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutUserInput>, Enumerable<TeamMembershipCreateWithoutUserInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    set?: Enumerable<TeamMembershipWhereUniqueInput>
    disconnect?: Enumerable<TeamMembershipWhereUniqueInput>
    delete?: Enumerable<TeamMembershipWhereUniqueInput>
    update?: Enumerable<TeamMembershipUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamMembershipUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamMembershipScalarWhereInput>
    upsert?: Enumerable<TeamMembershipUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutuserInput>
  }

  export type NotificationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationUncheckedCreateWithoutUserInput>, Enumerable<NotificationCreateWithoutUserInput>>
    connect?: Enumerable<NotificationWhereUniqueInput>
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutuserInput>
  }

  export type GameAccountUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutUserInput>, Enumerable<GameAccountCreateWithoutUserInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    set?: Enumerable<GameAccountWhereUniqueInput>
    disconnect?: Enumerable<GameAccountWhereUniqueInput>
    delete?: Enumerable<GameAccountWhereUniqueInput>
    update?: Enumerable<GameAccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<GameAccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<GameAccountScalarWhereInput>
    upsert?: Enumerable<GameAccountUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutuserInput>
  }

  export type AdminUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminUncheckedCreateWithoutUserInput>, Enumerable<AdminCreateWithoutUserInput>>
    connect?: Enumerable<AdminWhereUniqueInput>
    set?: Enumerable<AdminWhereUniqueInput>
    disconnect?: Enumerable<AdminWhereUniqueInput>
    delete?: Enumerable<AdminWhereUniqueInput>
    update?: Enumerable<AdminUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdminUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdminScalarWhereInput>
    connectOrCreate?: Enumerable<AdminCreateOrConnectWithoutuserInput>
  }

  export type NewsUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutAuthorInput>, Enumerable<NewsCreateWithoutAuthorInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    set?: Enumerable<NewsWhereUniqueInput>
    disconnect?: Enumerable<NewsWhereUniqueInput>
    delete?: Enumerable<NewsWhereUniqueInput>
    update?: Enumerable<NewsUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<NewsUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<NewsScalarWhereInput>
    upsert?: Enumerable<NewsUpsertWithWhereUniqueWithoutAuthorInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutauthorInput>
  }

  export type TournamentApplicationUpdateOneWithoutPlayersInput = {
    create?: XOR<TournamentApplicationUncheckedCreateWithoutPlayersInput, TournamentApplicationCreateWithoutPlayersInput>
    connect?: TournamentApplicationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TournamentApplicationUncheckedUpdateWithoutPlayersInput, TournamentApplicationUpdateWithoutPlayersInput>
    upsert?: TournamentApplicationUpsertWithoutPlayersInput
    connectOrCreate?: TournamentApplicationCreateOrConnectWithoutplayersInput
  }

  export type TournamentParticipationUpdateOneWithoutPlayersInput = {
    create?: XOR<TournamentParticipationUncheckedCreateWithoutPlayersInput, TournamentParticipationCreateWithoutPlayersInput>
    connect?: TournamentParticipationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TournamentParticipationUncheckedUpdateWithoutPlayersInput, TournamentParticipationUpdateWithoutPlayersInput>
    upsert?: TournamentParticipationUpsertWithoutPlayersInput
    connectOrCreate?: TournamentParticipationCreateOrConnectWithoutplayersInput
  }

  export type TeamInvitationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutUserInput>, Enumerable<TeamInvitationCreateWithoutUserInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    set?: Enumerable<TeamInvitationWhereUniqueInput>
    disconnect?: Enumerable<TeamInvitationWhereUniqueInput>
    delete?: Enumerable<TeamInvitationWhereUniqueInput>
    update?: Enumerable<TeamInvitationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamInvitationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamInvitationScalarWhereInput>
    upsert?: Enumerable<TeamInvitationUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutuserInput>
  }

  export type TournamentMatchStateUpdateOneWithoutAcceptedByInput = {
    create?: XOR<TournamentMatchStateUncheckedCreateWithoutAcceptedByInput, TournamentMatchStateCreateWithoutAcceptedByInput>
    connect?: TournamentMatchStateWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TournamentMatchStateUncheckedUpdateWithoutAcceptedByInput, TournamentMatchStateUpdateWithoutAcceptedByInput>
    upsert?: TournamentMatchStateUpsertWithoutAcceptedByInput
    connectOrCreate?: TournamentMatchStateCreateOrConnectWithoutacceptedByInput
  }

  export type TournamentMatchReportUpdateManyWithoutReporterInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutReporterInput>, Enumerable<TournamentMatchReportCreateWithoutReporterInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    set?: Enumerable<TournamentMatchReportWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    delete?: Enumerable<TournamentMatchReportWhereUniqueInput>
    update?: Enumerable<TournamentMatchReportUpdateWithWhereUniqueWithoutReporterInput>
    updateMany?: Enumerable<TournamentMatchReportUpdateManyWithWhereWithoutReporterInput>
    deleteMany?: Enumerable<TournamentMatchReportScalarWhereInput>
    upsert?: Enumerable<TournamentMatchReportUpsertWithWhereUniqueWithoutReporterInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutreporterInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeamMembershipUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutUserInput>, Enumerable<TeamMembershipCreateWithoutUserInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    set?: Enumerable<TeamMembershipWhereUniqueInput>
    disconnect?: Enumerable<TeamMembershipWhereUniqueInput>
    delete?: Enumerable<TeamMembershipWhereUniqueInput>
    update?: Enumerable<TeamMembershipUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamMembershipUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamMembershipScalarWhereInput>
    upsert?: Enumerable<TeamMembershipUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutuserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationUncheckedCreateWithoutUserInput>, Enumerable<NotificationCreateWithoutUserInput>>
    connect?: Enumerable<NotificationWhereUniqueInput>
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutuserInput>
  }

  export type GameAccountUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutUserInput>, Enumerable<GameAccountCreateWithoutUserInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    set?: Enumerable<GameAccountWhereUniqueInput>
    disconnect?: Enumerable<GameAccountWhereUniqueInput>
    delete?: Enumerable<GameAccountWhereUniqueInput>
    update?: Enumerable<GameAccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<GameAccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<GameAccountScalarWhereInput>
    upsert?: Enumerable<GameAccountUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutuserInput>
  }

  export type AdminUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminUncheckedCreateWithoutUserInput>, Enumerable<AdminCreateWithoutUserInput>>
    connect?: Enumerable<AdminWhereUniqueInput>
    set?: Enumerable<AdminWhereUniqueInput>
    disconnect?: Enumerable<AdminWhereUniqueInput>
    delete?: Enumerable<AdminWhereUniqueInput>
    update?: Enumerable<AdminUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdminUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdminScalarWhereInput>
    connectOrCreate?: Enumerable<AdminCreateOrConnectWithoutuserInput>
  }

  export type NewsUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutAuthorInput>, Enumerable<NewsCreateWithoutAuthorInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    set?: Enumerable<NewsWhereUniqueInput>
    disconnect?: Enumerable<NewsWhereUniqueInput>
    delete?: Enumerable<NewsWhereUniqueInput>
    update?: Enumerable<NewsUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<NewsUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<NewsScalarWhereInput>
    upsert?: Enumerable<NewsUpsertWithWhereUniqueWithoutAuthorInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutauthorInput>
  }

  export type TeamInvitationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutUserInput>, Enumerable<TeamInvitationCreateWithoutUserInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    set?: Enumerable<TeamInvitationWhereUniqueInput>
    disconnect?: Enumerable<TeamInvitationWhereUniqueInput>
    delete?: Enumerable<TeamInvitationWhereUniqueInput>
    update?: Enumerable<TeamInvitationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TeamInvitationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TeamInvitationScalarWhereInput>
    upsert?: Enumerable<TeamInvitationUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutuserInput>
  }

  export type TournamentMatchReportUncheckedUpdateManyWithoutReporterInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutReporterInput>, Enumerable<TournamentMatchReportCreateWithoutReporterInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    set?: Enumerable<TournamentMatchReportWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    delete?: Enumerable<TournamentMatchReportWhereUniqueInput>
    update?: Enumerable<TournamentMatchReportUpdateWithWhereUniqueWithoutReporterInput>
    updateMany?: Enumerable<TournamentMatchReportUpdateManyWithWhereWithoutReporterInput>
    deleteMany?: Enumerable<TournamentMatchReportScalarWhereInput>
    upsert?: Enumerable<TournamentMatchReportUpsertWithWhereUniqueWithoutReporterInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutreporterInput>
  }

  export type TeamCreateOneWithoutTournamentInput = {
    create?: XOR<TeamUncheckedCreateWithoutTournamentInput, TeamCreateWithoutTournamentInput>
    connect?: TeamWhereUniqueInput
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentInput
  }

  export type GameCreateOneWithoutTournamentInput = {
    create?: XOR<GameUncheckedCreateWithoutTournamentInput, GameCreateWithoutTournamentInput>
    connect?: GameWhereUniqueInput
    connectOrCreate?: GameCreateOrConnectWithoutTournamentInput
  }

  export type ImageCreateOneWithoutTournamentInput = {
    create?: XOR<ImageUncheckedCreateWithoutTournamentInput, ImageCreateWithoutTournamentInput>
    connect?: ImageWhereUniqueInput
    connectOrCreate?: ImageCreateOrConnectWithoutTournamentInput
  }

  export type TournamentParticipationCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentParticipationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithouttournamentInput>
  }

  export type TournamentApplicationCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentApplicationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithouttournamentInput>
  }

  export type RewardCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<RewardUncheckedCreateWithoutTournamentInput>, Enumerable<RewardCreateWithoutTournamentInput>>
    connect?: Enumerable<RewardWhereUniqueInput>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithouttournamentInput>
  }

  export type TournamentGridElementCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentGridElementCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithouttournamentInput>
  }

  export type TournamentMatchCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentMatchCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithouttournamentInput>
  }

  export type TournamentParticipationUncheckedCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentParticipationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithouttournamentInput>
  }

  export type TournamentApplicationUncheckedCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentApplicationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithouttournamentInput>
  }

  export type RewardUncheckedCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<RewardUncheckedCreateWithoutTournamentInput>, Enumerable<RewardCreateWithoutTournamentInput>>
    connect?: Enumerable<RewardWhereUniqueInput>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithouttournamentInput>
  }

  export type TournamentGridElementUncheckedCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentGridElementCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithouttournamentInput>
  }

  export type TournamentMatchUncheckedCreateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentMatchCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithouttournamentInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TeamUpdateOneRequiredWithoutTournamentInput = {
    create?: XOR<TeamUncheckedCreateWithoutTournamentInput, TeamCreateWithoutTournamentInput>
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUncheckedUpdateWithoutTournamentInput, TeamUpdateWithoutTournamentInput>
    upsert?: TeamUpsertWithoutTournamentInput
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentInput
  }

  export type GameUpdateOneRequiredWithoutTournamentInput = {
    create?: XOR<GameUncheckedCreateWithoutTournamentInput, GameCreateWithoutTournamentInput>
    connect?: GameWhereUniqueInput
    update?: XOR<GameUncheckedUpdateWithoutTournamentInput, GameUpdateWithoutTournamentInput>
    upsert?: GameUpsertWithoutTournamentInput
    connectOrCreate?: GameCreateOrConnectWithoutTournamentInput
  }

  export type ImageUpdateOneWithoutTournamentInput = {
    create?: XOR<ImageUncheckedCreateWithoutTournamentInput, ImageCreateWithoutTournamentInput>
    connect?: ImageWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ImageUncheckedUpdateWithoutTournamentInput, ImageUpdateWithoutTournamentInput>
    upsert?: ImageUpsertWithoutTournamentInput
    connectOrCreate?: ImageCreateOrConnectWithoutTournamentInput
  }

  export type TournamentParticipationUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentParticipationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    set?: Enumerable<TournamentParticipationWhereUniqueInput>
    disconnect?: Enumerable<TournamentParticipationWhereUniqueInput>
    delete?: Enumerable<TournamentParticipationWhereUniqueInput>
    update?: Enumerable<TournamentParticipationUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentParticipationUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentParticipationScalarWhereInput>
    upsert?: Enumerable<TournamentParticipationUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithouttournamentInput>
  }

  export type TournamentApplicationUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentApplicationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    set?: Enumerable<TournamentApplicationWhereUniqueInput>
    disconnect?: Enumerable<TournamentApplicationWhereUniqueInput>
    delete?: Enumerable<TournamentApplicationWhereUniqueInput>
    update?: Enumerable<TournamentApplicationUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentApplicationUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentApplicationScalarWhereInput>
    upsert?: Enumerable<TournamentApplicationUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithouttournamentInput>
  }

  export type RewardUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<RewardUncheckedCreateWithoutTournamentInput>, Enumerable<RewardCreateWithoutTournamentInput>>
    connect?: Enumerable<RewardWhereUniqueInput>
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithouttournamentInput>
  }

  export type TournamentGridElementUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentGridElementCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    set?: Enumerable<TournamentGridElementWhereUniqueInput>
    disconnect?: Enumerable<TournamentGridElementWhereUniqueInput>
    delete?: Enumerable<TournamentGridElementWhereUniqueInput>
    update?: Enumerable<TournamentGridElementUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentGridElementUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentGridElementScalarWhereInput>
    upsert?: Enumerable<TournamentGridElementUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithouttournamentInput>
  }

  export type TournamentMatchUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentMatchCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    set?: Enumerable<TournamentMatchWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchWhereUniqueInput>
    delete?: Enumerable<TournamentMatchWhereUniqueInput>
    update?: Enumerable<TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentMatchUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentMatchScalarWhereInput>
    upsert?: Enumerable<TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithouttournamentInput>
  }

  export type TournamentParticipationUncheckedUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentParticipationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    set?: Enumerable<TournamentParticipationWhereUniqueInput>
    disconnect?: Enumerable<TournamentParticipationWhereUniqueInput>
    delete?: Enumerable<TournamentParticipationWhereUniqueInput>
    update?: Enumerable<TournamentParticipationUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentParticipationUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentParticipationScalarWhereInput>
    upsert?: Enumerable<TournamentParticipationUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithouttournamentInput>
  }

  export type TournamentApplicationUncheckedUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentApplicationCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    set?: Enumerable<TournamentApplicationWhereUniqueInput>
    disconnect?: Enumerable<TournamentApplicationWhereUniqueInput>
    delete?: Enumerable<TournamentApplicationWhereUniqueInput>
    update?: Enumerable<TournamentApplicationUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentApplicationUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentApplicationScalarWhereInput>
    upsert?: Enumerable<TournamentApplicationUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithouttournamentInput>
  }

  export type RewardUncheckedUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<RewardUncheckedCreateWithoutTournamentInput>, Enumerable<RewardCreateWithoutTournamentInput>>
    connect?: Enumerable<RewardWhereUniqueInput>
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithouttournamentInput>
  }

  export type TournamentGridElementUncheckedUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentGridElementCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    set?: Enumerable<TournamentGridElementWhereUniqueInput>
    disconnect?: Enumerable<TournamentGridElementWhereUniqueInput>
    delete?: Enumerable<TournamentGridElementWhereUniqueInput>
    update?: Enumerable<TournamentGridElementUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentGridElementUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentGridElementScalarWhereInput>
    upsert?: Enumerable<TournamentGridElementUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithouttournamentInput>
  }

  export type TournamentMatchUncheckedUpdateManyWithoutTournamentInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutTournamentInput>, Enumerable<TournamentMatchCreateWithoutTournamentInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    set?: Enumerable<TournamentMatchWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchWhereUniqueInput>
    delete?: Enumerable<TournamentMatchWhereUniqueInput>
    update?: Enumerable<TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput>
    updateMany?: Enumerable<TournamentMatchUpdateManyWithWhereWithoutTournamentInput>
    deleteMany?: Enumerable<TournamentMatchScalarWhereInput>
    upsert?: Enumerable<TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithouttournamentInput>
  }

  export type UserCreateOneWithoutAdminInput = {
    create?: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
  }

  export type UserUpdateOneRequiredWithoutAdminInput = {
    create?: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutAdminInput, UserUpdateWithoutAdminInput>
    upsert?: UserUpsertWithoutAdminInput
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
  }

  export type UserCreateOneWithoutNewsInput = {
    create?: XOR<UserUncheckedCreateWithoutNewsInput, UserCreateWithoutNewsInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutNewsInput
  }

  export type ImageCreateOneWithoutNewsInput = {
    create?: XOR<ImageUncheckedCreateWithoutNewsInput, ImageCreateWithoutNewsInput>
    connect?: ImageWhereUniqueInput
    connectOrCreate?: ImageCreateOrConnectWithoutNewsInput
  }

  export type UserUpdateOneRequiredWithoutNewsInput = {
    create?: XOR<UserUncheckedCreateWithoutNewsInput, UserCreateWithoutNewsInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutNewsInput, UserUpdateWithoutNewsInput>
    upsert?: UserUpsertWithoutNewsInput
    connectOrCreate?: UserCreateOrConnectWithoutNewsInput
  }

  export type ImageUpdateOneWithoutNewsInput = {
    create?: XOR<ImageUncheckedCreateWithoutNewsInput, ImageCreateWithoutNewsInput>
    connect?: ImageWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ImageUncheckedUpdateWithoutNewsInput, ImageUpdateWithoutNewsInput>
    upsert?: ImageUpsertWithoutNewsInput
    connectOrCreate?: ImageCreateOrConnectWithoutNewsInput
  }

  export type TournamentCreateOneWithoutApplicantsInput = {
    create?: XOR<TournamentUncheckedCreateWithoutApplicantsInput, TournamentCreateWithoutApplicantsInput>
    connect?: TournamentWhereUniqueInput
    connectOrCreate?: TournamentCreateOrConnectWithoutapplicantsInput
  }

  export type TeamCreateOneWithoutTournamentApplicationInput = {
    create?: XOR<TeamUncheckedCreateWithoutTournamentApplicationInput, TeamCreateWithoutTournamentApplicationInput>
    connect?: TeamWhereUniqueInput
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentApplicationInput
  }

  export type UserCreateManyWithoutTournamentApplicationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentApplicationInput>, Enumerable<UserCreateWithoutTournamentApplicationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentApplicationInput>
  }

  export type UserUncheckedCreateManyWithoutTournamentApplicationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentApplicationInput>, Enumerable<UserCreateWithoutTournamentApplicationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentApplicationInput>
  }

  export type TournamentUpdateOneRequiredWithoutApplicantsInput = {
    create?: XOR<TournamentUncheckedCreateWithoutApplicantsInput, TournamentCreateWithoutApplicantsInput>
    connect?: TournamentWhereUniqueInput
    update?: XOR<TournamentUncheckedUpdateWithoutApplicantsInput, TournamentUpdateWithoutApplicantsInput>
    upsert?: TournamentUpsertWithoutApplicantsInput
    connectOrCreate?: TournamentCreateOrConnectWithoutapplicantsInput
  }

  export type TeamUpdateOneRequiredWithoutTournamentApplicationInput = {
    create?: XOR<TeamUncheckedCreateWithoutTournamentApplicationInput, TeamCreateWithoutTournamentApplicationInput>
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUncheckedUpdateWithoutTournamentApplicationInput, TeamUpdateWithoutTournamentApplicationInput>
    upsert?: TeamUpsertWithoutTournamentApplicationInput
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentApplicationInput
  }

  export type UserUpdateManyWithoutTournamentApplicationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentApplicationInput>, Enumerable<UserCreateWithoutTournamentApplicationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTournamentApplicationInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTournamentApplicationInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTournamentApplicationInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentApplicationInput>
  }

  export type UserUncheckedUpdateManyWithoutTournamentApplicationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentApplicationInput>, Enumerable<UserCreateWithoutTournamentApplicationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTournamentApplicationInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTournamentApplicationInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTournamentApplicationInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentApplicationInput>
  }

  export type TournamentCreateOneWithoutTournamentGridElementInput = {
    create?: XOR<TournamentUncheckedCreateWithoutTournamentGridElementInput, TournamentCreateWithoutTournamentGridElementInput>
    connect?: TournamentWhereUniqueInput
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentGridElementInput
  }

  export type TournamentParticipationCreateOneWithoutTournamentGridElementInput = {
    create?: XOR<TournamentParticipationUncheckedCreateWithoutTournamentGridElementInput, TournamentParticipationCreateWithoutTournamentGridElementInput>
    connect?: TournamentParticipationWhereUniqueInput
    connectOrCreate?: TournamentParticipationCreateOrConnectWithoutTournamentGridElementInput
  }

  export type TournamentMatchCreateOneWithoutTournamentGridElementInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutTournamentGridElementInput, TournamentMatchCreateWithoutTournamentGridElementInput>
    connect?: TournamentMatchWhereUniqueInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentGridElementInput
  }

  export type TournamentUpdateOneRequiredWithoutTournamentGridElementInput = {
    create?: XOR<TournamentUncheckedCreateWithoutTournamentGridElementInput, TournamentCreateWithoutTournamentGridElementInput>
    connect?: TournamentWhereUniqueInput
    update?: XOR<TournamentUncheckedUpdateWithoutTournamentGridElementInput, TournamentUpdateWithoutTournamentGridElementInput>
    upsert?: TournamentUpsertWithoutTournamentGridElementInput
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentGridElementInput
  }

  export type TournamentParticipationUpdateOneRequiredWithoutTournamentGridElementInput = {
    create?: XOR<TournamentParticipationUncheckedCreateWithoutTournamentGridElementInput, TournamentParticipationCreateWithoutTournamentGridElementInput>
    connect?: TournamentParticipationWhereUniqueInput
    update?: XOR<TournamentParticipationUncheckedUpdateWithoutTournamentGridElementInput, TournamentParticipationUpdateWithoutTournamentGridElementInput>
    upsert?: TournamentParticipationUpsertWithoutTournamentGridElementInput
    connectOrCreate?: TournamentParticipationCreateOrConnectWithoutTournamentGridElementInput
  }

  export type TournamentMatchUpdateOneWithoutTournamentGridElementInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutTournamentGridElementInput, TournamentMatchCreateWithoutTournamentGridElementInput>
    connect?: TournamentMatchWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TournamentMatchUncheckedUpdateWithoutTournamentGridElementInput, TournamentMatchUpdateWithoutTournamentGridElementInput>
    upsert?: TournamentMatchUpsertWithoutTournamentGridElementInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentGridElementInput
  }

  export type TeamCreateOneWithoutTournamentParticipationInput = {
    create?: XOR<TeamUncheckedCreateWithoutTournamentParticipationInput, TeamCreateWithoutTournamentParticipationInput>
    connect?: TeamWhereUniqueInput
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentParticipationInput
  }

  export type TournamentCreateOneWithoutParticipantsInput = {
    create?: XOR<TournamentUncheckedCreateWithoutParticipantsInput, TournamentCreateWithoutParticipantsInput>
    connect?: TournamentWhereUniqueInput
    connectOrCreate?: TournamentCreateOrConnectWithoutparticipantsInput
  }

  export type UserCreateManyWithoutTournamentParticipationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentParticipationInput>, Enumerable<UserCreateWithoutTournamentParticipationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentParticipationInput>
  }

  export type TournamentMatchCreateOneWithoutParticipantsInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutParticipantsInput, TournamentMatchCreateWithoutParticipantsInput>
    connect?: TournamentMatchWhereUniqueInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutparticipantsInput
  }

  export type TournamentGridElementCreateManyWithoutParticipantInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutParticipantInput>, Enumerable<TournamentGridElementCreateWithoutParticipantInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutparticipantInput>
  }

  export type UserUncheckedCreateManyWithoutTournamentParticipationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentParticipationInput>, Enumerable<UserCreateWithoutTournamentParticipationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentParticipationInput>
  }

  export type TournamentGridElementUncheckedCreateManyWithoutParticipantInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutParticipantInput>, Enumerable<TournamentGridElementCreateWithoutParticipantInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutparticipantInput>
  }

  export type TeamUpdateOneRequiredWithoutTournamentParticipationInput = {
    create?: XOR<TeamUncheckedCreateWithoutTournamentParticipationInput, TeamCreateWithoutTournamentParticipationInput>
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUncheckedUpdateWithoutTournamentParticipationInput, TeamUpdateWithoutTournamentParticipationInput>
    upsert?: TeamUpsertWithoutTournamentParticipationInput
    connectOrCreate?: TeamCreateOrConnectWithoutTournamentParticipationInput
  }

  export type TournamentUpdateOneRequiredWithoutParticipantsInput = {
    create?: XOR<TournamentUncheckedCreateWithoutParticipantsInput, TournamentCreateWithoutParticipantsInput>
    connect?: TournamentWhereUniqueInput
    update?: XOR<TournamentUncheckedUpdateWithoutParticipantsInput, TournamentUpdateWithoutParticipantsInput>
    upsert?: TournamentUpsertWithoutParticipantsInput
    connectOrCreate?: TournamentCreateOrConnectWithoutparticipantsInput
  }

  export type UserUpdateManyWithoutTournamentParticipationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentParticipationInput>, Enumerable<UserCreateWithoutTournamentParticipationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTournamentParticipationInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTournamentParticipationInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTournamentParticipationInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentParticipationInput>
  }

  export type TournamentMatchUpdateOneWithoutParticipantsInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutParticipantsInput, TournamentMatchCreateWithoutParticipantsInput>
    connect?: TournamentMatchWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TournamentMatchUncheckedUpdateWithoutParticipantsInput, TournamentMatchUpdateWithoutParticipantsInput>
    upsert?: TournamentMatchUpsertWithoutParticipantsInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutparticipantsInput
  }

  export type TournamentGridElementUpdateManyWithoutParticipantInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutParticipantInput>, Enumerable<TournamentGridElementCreateWithoutParticipantInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    set?: Enumerable<TournamentGridElementWhereUniqueInput>
    disconnect?: Enumerable<TournamentGridElementWhereUniqueInput>
    delete?: Enumerable<TournamentGridElementWhereUniqueInput>
    update?: Enumerable<TournamentGridElementUpdateWithWhereUniqueWithoutParticipantInput>
    updateMany?: Enumerable<TournamentGridElementUpdateManyWithWhereWithoutParticipantInput>
    deleteMany?: Enumerable<TournamentGridElementScalarWhereInput>
    upsert?: Enumerable<TournamentGridElementUpsertWithWhereUniqueWithoutParticipantInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutparticipantInput>
  }

  export type UserUncheckedUpdateManyWithoutTournamentParticipationInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentParticipationInput>, Enumerable<UserCreateWithoutTournamentParticipationInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTournamentParticipationInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTournamentParticipationInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTournamentParticipationInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentParticipationInput>
  }

  export type TournamentGridElementUncheckedUpdateManyWithoutParticipantInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutParticipantInput>, Enumerable<TournamentGridElementCreateWithoutParticipantInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    set?: Enumerable<TournamentGridElementWhereUniqueInput>
    disconnect?: Enumerable<TournamentGridElementWhereUniqueInput>
    delete?: Enumerable<TournamentGridElementWhereUniqueInput>
    update?: Enumerable<TournamentGridElementUpdateWithWhereUniqueWithoutParticipantInput>
    updateMany?: Enumerable<TournamentGridElementUpdateManyWithWhereWithoutParticipantInput>
    deleteMany?: Enumerable<TournamentGridElementScalarWhereInput>
    upsert?: Enumerable<TournamentGridElementUpsertWithWhereUniqueWithoutParticipantInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutparticipantInput>
  }

  export type UserCreateOneWithoutMembershipsInput = {
    create?: XOR<UserUncheckedCreateWithoutMembershipsInput, UserCreateWithoutMembershipsInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutmembershipsInput
  }

  export type TeamCreateOneWithoutMembersInput = {
    create?: XOR<TeamUncheckedCreateWithoutMembersInput, TeamCreateWithoutMembersInput>
    connect?: TeamWhereUniqueInput
    connectOrCreate?: TeamCreateOrConnectWithoutmembersInput
  }

  export type EnumTeamRoleTypeFieldUpdateOperationsInput = {
    set?: TeamRoleType
  }

  export type UserUpdateOneRequiredWithoutMembershipsInput = {
    create?: XOR<UserUncheckedCreateWithoutMembershipsInput, UserCreateWithoutMembershipsInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>
    upsert?: UserUpsertWithoutMembershipsInput
    connectOrCreate?: UserCreateOrConnectWithoutmembershipsInput
  }

  export type TeamUpdateOneRequiredWithoutMembersInput = {
    create?: XOR<TeamUncheckedCreateWithoutMembersInput, TeamCreateWithoutMembersInput>
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUncheckedUpdateWithoutMembersInput, TeamUpdateWithoutMembersInput>
    upsert?: TeamUpsertWithoutMembersInput
    connectOrCreate?: TeamCreateOrConnectWithoutmembersInput
  }

  export type UserCreateOneWithoutTeamInvitationInput = {
    create?: XOR<UserUncheckedCreateWithoutTeamInvitationInput, UserCreateWithoutTeamInvitationInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutTeamInvitationInput
  }

  export type TeamCreateOneWithoutTeamInvitationInput = {
    create?: XOR<TeamUncheckedCreateWithoutTeamInvitationInput, TeamCreateWithoutTeamInvitationInput>
    connect?: TeamWhereUniqueInput
    connectOrCreate?: TeamCreateOrConnectWithoutTeamInvitationInput
  }

  export type UserUpdateOneRequiredWithoutTeamInvitationInput = {
    create?: XOR<UserUncheckedCreateWithoutTeamInvitationInput, UserCreateWithoutTeamInvitationInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutTeamInvitationInput, UserUpdateWithoutTeamInvitationInput>
    upsert?: UserUpsertWithoutTeamInvitationInput
    connectOrCreate?: UserCreateOrConnectWithoutTeamInvitationInput
  }

  export type TeamUpdateOneRequiredWithoutTeamInvitationInput = {
    create?: XOR<TeamUncheckedCreateWithoutTeamInvitationInput, TeamCreateWithoutTeamInvitationInput>
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUncheckedUpdateWithoutTeamInvitationInput, TeamUpdateWithoutTeamInvitationInput>
    upsert?: TeamUpsertWithoutTeamInvitationInput
    connectOrCreate?: TeamCreateOrConnectWithoutTeamInvitationInput
  }

  export type UserCreateManyWithoutTournamentMatchStateInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentMatchStateInput>, Enumerable<UserCreateWithoutTournamentMatchStateInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentMatchStateInput>
  }

  export type TournamentMatchCreateOneWithoutTournamentMatchStateInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchStateInput, TournamentMatchCreateWithoutTournamentMatchStateInput>
    connect?: TournamentMatchWhereUniqueInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentMatchStateInput
  }

  export type UserUncheckedCreateManyWithoutTournamentMatchStateInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentMatchStateInput>, Enumerable<UserCreateWithoutTournamentMatchStateInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentMatchStateInput>
  }

  export type UserUpdateManyWithoutTournamentMatchStateInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentMatchStateInput>, Enumerable<UserCreateWithoutTournamentMatchStateInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTournamentMatchStateInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTournamentMatchStateInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTournamentMatchStateInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentMatchStateInput>
  }

  export type TournamentMatchUpdateOneRequiredWithoutTournamentMatchStateInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchStateInput, TournamentMatchCreateWithoutTournamentMatchStateInput>
    connect?: TournamentMatchWhereUniqueInput
    update?: XOR<TournamentMatchUncheckedUpdateWithoutTournamentMatchStateInput, TournamentMatchUpdateWithoutTournamentMatchStateInput>
    upsert?: TournamentMatchUpsertWithoutTournamentMatchStateInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentMatchStateInput
  }

  export type UserUncheckedUpdateManyWithoutTournamentMatchStateInput = {
    create?: XOR<Enumerable<UserUncheckedCreateWithoutTournamentMatchStateInput>, Enumerable<UserCreateWithoutTournamentMatchStateInput>>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTournamentMatchStateInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTournamentMatchStateInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTournamentMatchStateInput>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTournamentMatchStateInput>
  }

  export type ImageCreateOneWithoutTeamInput = {
    create?: XOR<ImageUncheckedCreateWithoutTeamInput, ImageCreateWithoutTeamInput>
    connect?: ImageWhereUniqueInput
    connectOrCreate?: ImageCreateOrConnectWithoutTeamInput
  }

  export type TeamMembershipCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutTeamInput>, Enumerable<TeamMembershipCreateWithoutTeamInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutteamInput>
  }

  export type TournamentCreateManyWithoutOrganizerInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutOrganizerInput>, Enumerable<TournamentCreateWithoutOrganizerInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutorganizerInput>
  }

  export type TournamentApplicationCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentApplicationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithoutteamInput>
  }

  export type TournamentParticipationCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentParticipationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutteamInput>
  }

  export type TeamInvitationCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutTeamInput>, Enumerable<TeamInvitationCreateWithoutTeamInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutteamInput>
  }

  export type TeamMembershipUncheckedCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutTeamInput>, Enumerable<TeamMembershipCreateWithoutTeamInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutteamInput>
  }

  export type TournamentUncheckedCreateManyWithoutOrganizerInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutOrganizerInput>, Enumerable<TournamentCreateWithoutOrganizerInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutorganizerInput>
  }

  export type TournamentApplicationUncheckedCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentApplicationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithoutteamInput>
  }

  export type TournamentParticipationUncheckedCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentParticipationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutteamInput>
  }

  export type TeamInvitationUncheckedCreateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutTeamInput>, Enumerable<TeamInvitationCreateWithoutTeamInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutteamInput>
  }

  export type ImageUpdateOneWithoutTeamInput = {
    create?: XOR<ImageUncheckedCreateWithoutTeamInput, ImageCreateWithoutTeamInput>
    connect?: ImageWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ImageUncheckedUpdateWithoutTeamInput, ImageUpdateWithoutTeamInput>
    upsert?: ImageUpsertWithoutTeamInput
    connectOrCreate?: ImageCreateOrConnectWithoutTeamInput
  }

  export type TeamMembershipUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutTeamInput>, Enumerable<TeamMembershipCreateWithoutTeamInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    set?: Enumerable<TeamMembershipWhereUniqueInput>
    disconnect?: Enumerable<TeamMembershipWhereUniqueInput>
    delete?: Enumerable<TeamMembershipWhereUniqueInput>
    update?: Enumerable<TeamMembershipUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamMembershipUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamMembershipScalarWhereInput>
    upsert?: Enumerable<TeamMembershipUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutteamInput>
  }

  export type TournamentUpdateManyWithoutOrganizerInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutOrganizerInput>, Enumerable<TournamentCreateWithoutOrganizerInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    set?: Enumerable<TournamentWhereUniqueInput>
    disconnect?: Enumerable<TournamentWhereUniqueInput>
    delete?: Enumerable<TournamentWhereUniqueInput>
    update?: Enumerable<TournamentUpdateWithWhereUniqueWithoutOrganizerInput>
    updateMany?: Enumerable<TournamentUpdateManyWithWhereWithoutOrganizerInput>
    deleteMany?: Enumerable<TournamentScalarWhereInput>
    upsert?: Enumerable<TournamentUpsertWithWhereUniqueWithoutOrganizerInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutorganizerInput>
  }

  export type TournamentApplicationUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentApplicationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    set?: Enumerable<TournamentApplicationWhereUniqueInput>
    disconnect?: Enumerable<TournamentApplicationWhereUniqueInput>
    delete?: Enumerable<TournamentApplicationWhereUniqueInput>
    update?: Enumerable<TournamentApplicationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TournamentApplicationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TournamentApplicationScalarWhereInput>
    upsert?: Enumerable<TournamentApplicationUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithoutteamInput>
  }

  export type TournamentParticipationUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentParticipationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    set?: Enumerable<TournamentParticipationWhereUniqueInput>
    disconnect?: Enumerable<TournamentParticipationWhereUniqueInput>
    delete?: Enumerable<TournamentParticipationWhereUniqueInput>
    update?: Enumerable<TournamentParticipationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TournamentParticipationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TournamentParticipationScalarWhereInput>
    upsert?: Enumerable<TournamentParticipationUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutteamInput>
  }

  export type TeamInvitationUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutTeamInput>, Enumerable<TeamInvitationCreateWithoutTeamInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    set?: Enumerable<TeamInvitationWhereUniqueInput>
    disconnect?: Enumerable<TeamInvitationWhereUniqueInput>
    delete?: Enumerable<TeamInvitationWhereUniqueInput>
    update?: Enumerable<TeamInvitationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamInvitationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamInvitationScalarWhereInput>
    upsert?: Enumerable<TeamInvitationUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutteamInput>
  }

  export type TeamMembershipUncheckedUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamMembershipUncheckedCreateWithoutTeamInput>, Enumerable<TeamMembershipCreateWithoutTeamInput>>
    connect?: Enumerable<TeamMembershipWhereUniqueInput>
    set?: Enumerable<TeamMembershipWhereUniqueInput>
    disconnect?: Enumerable<TeamMembershipWhereUniqueInput>
    delete?: Enumerable<TeamMembershipWhereUniqueInput>
    update?: Enumerable<TeamMembershipUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamMembershipUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamMembershipScalarWhereInput>
    upsert?: Enumerable<TeamMembershipUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TeamMembershipCreateOrConnectWithoutteamInput>
  }

  export type TournamentUncheckedUpdateManyWithoutOrganizerInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutOrganizerInput>, Enumerable<TournamentCreateWithoutOrganizerInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    set?: Enumerable<TournamentWhereUniqueInput>
    disconnect?: Enumerable<TournamentWhereUniqueInput>
    delete?: Enumerable<TournamentWhereUniqueInput>
    update?: Enumerable<TournamentUpdateWithWhereUniqueWithoutOrganizerInput>
    updateMany?: Enumerable<TournamentUpdateManyWithWhereWithoutOrganizerInput>
    deleteMany?: Enumerable<TournamentScalarWhereInput>
    upsert?: Enumerable<TournamentUpsertWithWhereUniqueWithoutOrganizerInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutorganizerInput>
  }

  export type TournamentApplicationUncheckedUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentApplicationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentApplicationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentApplicationWhereUniqueInput>
    set?: Enumerable<TournamentApplicationWhereUniqueInput>
    disconnect?: Enumerable<TournamentApplicationWhereUniqueInput>
    delete?: Enumerable<TournamentApplicationWhereUniqueInput>
    update?: Enumerable<TournamentApplicationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TournamentApplicationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TournamentApplicationScalarWhereInput>
    upsert?: Enumerable<TournamentApplicationUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TournamentApplicationCreateOrConnectWithoutteamInput>
  }

  export type TournamentParticipationUncheckedUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutTeamInput>, Enumerable<TournamentParticipationCreateWithoutTeamInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    set?: Enumerable<TournamentParticipationWhereUniqueInput>
    disconnect?: Enumerable<TournamentParticipationWhereUniqueInput>
    delete?: Enumerable<TournamentParticipationWhereUniqueInput>
    update?: Enumerable<TournamentParticipationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TournamentParticipationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TournamentParticipationScalarWhereInput>
    upsert?: Enumerable<TournamentParticipationUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutteamInput>
  }

  export type TeamInvitationUncheckedUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<TeamInvitationUncheckedCreateWithoutTeamInput>, Enumerable<TeamInvitationCreateWithoutTeamInput>>
    connect?: Enumerable<TeamInvitationWhereUniqueInput>
    set?: Enumerable<TeamInvitationWhereUniqueInput>
    disconnect?: Enumerable<TeamInvitationWhereUniqueInput>
    delete?: Enumerable<TeamInvitationWhereUniqueInput>
    update?: Enumerable<TeamInvitationUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<TeamInvitationUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<TeamInvitationScalarWhereInput>
    upsert?: Enumerable<TeamInvitationUpsertWithWhereUniqueWithoutTeamInput>
    connectOrCreate?: Enumerable<TeamInvitationCreateOrConnectWithoutteamInput>
  }

  export type TournamentCreateOneWithoutTournamentMatchInput = {
    create?: XOR<TournamentUncheckedCreateWithoutTournamentMatchInput, TournamentCreateWithoutTournamentMatchInput>
    connect?: TournamentWhereUniqueInput
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentMatchInput
  }

  export type RoomCodeCreateOneWithoutTournamentMatchInput = {
    create?: XOR<RoomCodeUncheckedCreateWithoutTournamentMatchInput, RoomCodeCreateWithoutTournamentMatchInput>
    connect?: RoomCodeWhereUniqueInput
    connectOrCreate?: RoomCodeCreateOrConnectWithoutTournamentMatchInput
  }

  export type TournamentParticipationCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutMatchInput>, Enumerable<TournamentParticipationCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutmatchInput>
  }

  export type TournamentGridElementCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutMatchInput>, Enumerable<TournamentGridElementCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchStateCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchStateUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchStateCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchStateWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchStateCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchReportCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchReportCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutmatchInput>
  }

  export type TournamentParticipationUncheckedCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutMatchInput>, Enumerable<TournamentParticipationCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutmatchInput>
  }

  export type TournamentGridElementUncheckedCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutMatchInput>, Enumerable<TournamentGridElementCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchStateUncheckedCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchStateUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchStateCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchStateWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchStateCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchReportUncheckedCreateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchReportCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutmatchInput>
  }

  export type EnumMatchStateTypeFieldUpdateOperationsInput = {
    set?: MatchStateType
  }

  export type TournamentUpdateOneRequiredWithoutTournamentMatchInput = {
    create?: XOR<TournamentUncheckedCreateWithoutTournamentMatchInput, TournamentCreateWithoutTournamentMatchInput>
    connect?: TournamentWhereUniqueInput
    update?: XOR<TournamentUncheckedUpdateWithoutTournamentMatchInput, TournamentUpdateWithoutTournamentMatchInput>
    upsert?: TournamentUpsertWithoutTournamentMatchInput
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentMatchInput
  }

  export type RoomCodeUpdateOneRequiredWithoutTournamentMatchInput = {
    create?: XOR<RoomCodeUncheckedCreateWithoutTournamentMatchInput, RoomCodeCreateWithoutTournamentMatchInput>
    connect?: RoomCodeWhereUniqueInput
    update?: XOR<RoomCodeUncheckedUpdateWithoutTournamentMatchInput, RoomCodeUpdateWithoutTournamentMatchInput>
    upsert?: RoomCodeUpsertWithoutTournamentMatchInput
    connectOrCreate?: RoomCodeCreateOrConnectWithoutTournamentMatchInput
  }

  export type TournamentParticipationUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutMatchInput>, Enumerable<TournamentParticipationCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    set?: Enumerable<TournamentParticipationWhereUniqueInput>
    disconnect?: Enumerable<TournamentParticipationWhereUniqueInput>
    delete?: Enumerable<TournamentParticipationWhereUniqueInput>
    update?: Enumerable<TournamentParticipationUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentParticipationUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentParticipationScalarWhereInput>
    upsert?: Enumerable<TournamentParticipationUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutmatchInput>
  }

  export type TournamentGridElementUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutMatchInput>, Enumerable<TournamentGridElementCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    set?: Enumerable<TournamentGridElementWhereUniqueInput>
    disconnect?: Enumerable<TournamentGridElementWhereUniqueInput>
    delete?: Enumerable<TournamentGridElementWhereUniqueInput>
    update?: Enumerable<TournamentGridElementUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentGridElementUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentGridElementScalarWhereInput>
    upsert?: Enumerable<TournamentGridElementUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchStateUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchStateUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchStateCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchStateWhereUniqueInput>
    set?: Enumerable<TournamentMatchStateWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchStateWhereUniqueInput>
    delete?: Enumerable<TournamentMatchStateWhereUniqueInput>
    update?: Enumerable<TournamentMatchStateUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentMatchStateUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentMatchStateScalarWhereInput>
    upsert?: Enumerable<TournamentMatchStateUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentMatchStateCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchReportUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchReportCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    set?: Enumerable<TournamentMatchReportWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    delete?: Enumerable<TournamentMatchReportWhereUniqueInput>
    update?: Enumerable<TournamentMatchReportUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentMatchReportUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentMatchReportScalarWhereInput>
    upsert?: Enumerable<TournamentMatchReportUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutmatchInput>
  }

  export type TournamentParticipationUncheckedUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentParticipationUncheckedCreateWithoutMatchInput>, Enumerable<TournamentParticipationCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentParticipationWhereUniqueInput>
    set?: Enumerable<TournamentParticipationWhereUniqueInput>
    disconnect?: Enumerable<TournamentParticipationWhereUniqueInput>
    delete?: Enumerable<TournamentParticipationWhereUniqueInput>
    update?: Enumerable<TournamentParticipationUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentParticipationUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentParticipationScalarWhereInput>
    upsert?: Enumerable<TournamentParticipationUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentParticipationCreateOrConnectWithoutmatchInput>
  }

  export type TournamentGridElementUncheckedUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentGridElementUncheckedCreateWithoutMatchInput>, Enumerable<TournamentGridElementCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentGridElementWhereUniqueInput>
    set?: Enumerable<TournamentGridElementWhereUniqueInput>
    disconnect?: Enumerable<TournamentGridElementWhereUniqueInput>
    delete?: Enumerable<TournamentGridElementWhereUniqueInput>
    update?: Enumerable<TournamentGridElementUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentGridElementUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentGridElementScalarWhereInput>
    upsert?: Enumerable<TournamentGridElementUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentGridElementCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchStateUncheckedUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchStateUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchStateCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchStateWhereUniqueInput>
    set?: Enumerable<TournamentMatchStateWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchStateWhereUniqueInput>
    delete?: Enumerable<TournamentMatchStateWhereUniqueInput>
    update?: Enumerable<TournamentMatchStateUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentMatchStateUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentMatchStateScalarWhereInput>
    upsert?: Enumerable<TournamentMatchStateUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentMatchStateCreateOrConnectWithoutmatchInput>
  }

  export type TournamentMatchReportUncheckedUpdateManyWithoutMatchInput = {
    create?: XOR<Enumerable<TournamentMatchReportUncheckedCreateWithoutMatchInput>, Enumerable<TournamentMatchReportCreateWithoutMatchInput>>
    connect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    set?: Enumerable<TournamentMatchReportWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchReportWhereUniqueInput>
    delete?: Enumerable<TournamentMatchReportWhereUniqueInput>
    update?: Enumerable<TournamentMatchReportUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<TournamentMatchReportUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<TournamentMatchReportScalarWhereInput>
    upsert?: Enumerable<TournamentMatchReportUpsertWithWhereUniqueWithoutMatchInput>
    connectOrCreate?: Enumerable<TournamentMatchReportCreateOrConnectWithoutmatchInput>
  }

  export type UserCreateOneWithoutTournamentMatchReportInput = {
    create?: XOR<UserUncheckedCreateWithoutTournamentMatchReportInput, UserCreateWithoutTournamentMatchReportInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutTournamentMatchReportInput
  }

  export type TournamentMatchCreateOneWithoutTournamentMatchReportInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchReportInput, TournamentMatchCreateWithoutTournamentMatchReportInput>
    connect?: TournamentMatchWhereUniqueInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentMatchReportInput
  }

  export type ImageCreateManyWithoutTournamentMatchReportInput = {
    create?: XOR<Enumerable<ImageUncheckedCreateWithoutTournamentMatchReportInput>, Enumerable<ImageCreateWithoutTournamentMatchReportInput>>
    connect?: Enumerable<ImageWhereUniqueInput>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutTournamentMatchReportInput>
  }

  export type ImageUncheckedCreateManyWithoutTournamentMatchReportInput = {
    create?: XOR<Enumerable<ImageUncheckedCreateWithoutTournamentMatchReportInput>, Enumerable<ImageCreateWithoutTournamentMatchReportInput>>
    connect?: Enumerable<ImageWhereUniqueInput>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutTournamentMatchReportInput>
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: ReportType
  }

  export type UserUpdateOneRequiredWithoutTournamentMatchReportInput = {
    create?: XOR<UserUncheckedCreateWithoutTournamentMatchReportInput, UserCreateWithoutTournamentMatchReportInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutTournamentMatchReportInput, UserUpdateWithoutTournamentMatchReportInput>
    upsert?: UserUpsertWithoutTournamentMatchReportInput
    connectOrCreate?: UserCreateOrConnectWithoutTournamentMatchReportInput
  }

  export type TournamentMatchUpdateOneRequiredWithoutTournamentMatchReportInput = {
    create?: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchReportInput, TournamentMatchCreateWithoutTournamentMatchReportInput>
    connect?: TournamentMatchWhereUniqueInput
    update?: XOR<TournamentMatchUncheckedUpdateWithoutTournamentMatchReportInput, TournamentMatchUpdateWithoutTournamentMatchReportInput>
    upsert?: TournamentMatchUpsertWithoutTournamentMatchReportInput
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentMatchReportInput
  }

  export type ImageUpdateManyWithoutTournamentMatchReportInput = {
    create?: XOR<Enumerable<ImageUncheckedCreateWithoutTournamentMatchReportInput>, Enumerable<ImageCreateWithoutTournamentMatchReportInput>>
    connect?: Enumerable<ImageWhereUniqueInput>
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutTournamentMatchReportInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutTournamentMatchReportInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutTournamentMatchReportInput>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutTournamentMatchReportInput>
  }

  export type ImageUncheckedUpdateManyWithoutTournamentMatchReportInput = {
    create?: XOR<Enumerable<ImageUncheckedCreateWithoutTournamentMatchReportInput>, Enumerable<ImageCreateWithoutTournamentMatchReportInput>>
    connect?: Enumerable<ImageWhereUniqueInput>
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutTournamentMatchReportInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutTournamentMatchReportInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutTournamentMatchReportInput>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutTournamentMatchReportInput>
  }

  export type UserCreateOneWithoutNotificationsInput = {
    create?: XOR<UserUncheckedCreateWithoutNotificationsInput, UserCreateWithoutNotificationsInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutnotificationsInput
  }

  export type NullableEnumNotificationTypeFieldUpdateOperationsInput = {
    set?: NotificationType | null
  }

  export type UserUpdateOneRequiredWithoutNotificationsInput = {
    create?: XOR<UserUncheckedCreateWithoutNotificationsInput, UserCreateWithoutNotificationsInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>
    upsert?: UserUpsertWithoutNotificationsInput
    connectOrCreate?: UserCreateOrConnectWithoutnotificationsInput
  }

  export type GameCreateOneWithoutRoomCodeInput = {
    create?: XOR<GameUncheckedCreateWithoutRoomCodeInput, GameCreateWithoutRoomCodeInput>
    connect?: GameWhereUniqueInput
    connectOrCreate?: GameCreateOrConnectWithoutRoomCodeInput
  }

  export type TournamentMatchCreateManyWithoutRoomCodeInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutRoomCodeInput>, Enumerable<TournamentMatchCreateWithoutRoomCodeInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithoutroomCodeInput>
  }

  export type TournamentMatchUncheckedCreateManyWithoutRoomCodeInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutRoomCodeInput>, Enumerable<TournamentMatchCreateWithoutRoomCodeInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithoutroomCodeInput>
  }

  export type GameUpdateOneRequiredWithoutRoomCodeInput = {
    create?: XOR<GameUncheckedCreateWithoutRoomCodeInput, GameCreateWithoutRoomCodeInput>
    connect?: GameWhereUniqueInput
    update?: XOR<GameUncheckedUpdateWithoutRoomCodeInput, GameUpdateWithoutRoomCodeInput>
    upsert?: GameUpsertWithoutRoomCodeInput
    connectOrCreate?: GameCreateOrConnectWithoutRoomCodeInput
  }

  export type TournamentMatchUpdateManyWithoutRoomCodeInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutRoomCodeInput>, Enumerable<TournamentMatchCreateWithoutRoomCodeInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    set?: Enumerable<TournamentMatchWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchWhereUniqueInput>
    delete?: Enumerable<TournamentMatchWhereUniqueInput>
    update?: Enumerable<TournamentMatchUpdateWithWhereUniqueWithoutRoomCodeInput>
    updateMany?: Enumerable<TournamentMatchUpdateManyWithWhereWithoutRoomCodeInput>
    deleteMany?: Enumerable<TournamentMatchScalarWhereInput>
    upsert?: Enumerable<TournamentMatchUpsertWithWhereUniqueWithoutRoomCodeInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithoutroomCodeInput>
  }

  export type TournamentMatchUncheckedUpdateManyWithoutRoomCodeInput = {
    create?: XOR<Enumerable<TournamentMatchUncheckedCreateWithoutRoomCodeInput>, Enumerable<TournamentMatchCreateWithoutRoomCodeInput>>
    connect?: Enumerable<TournamentMatchWhereUniqueInput>
    set?: Enumerable<TournamentMatchWhereUniqueInput>
    disconnect?: Enumerable<TournamentMatchWhereUniqueInput>
    delete?: Enumerable<TournamentMatchWhereUniqueInput>
    update?: Enumerable<TournamentMatchUpdateWithWhereUniqueWithoutRoomCodeInput>
    updateMany?: Enumerable<TournamentMatchUpdateManyWithWhereWithoutRoomCodeInput>
    deleteMany?: Enumerable<TournamentMatchScalarWhereInput>
    upsert?: Enumerable<TournamentMatchUpsertWithWhereUniqueWithoutRoomCodeInput>
    connectOrCreate?: Enumerable<TournamentMatchCreateOrConnectWithoutroomCodeInput>
  }

  export type TournamentCreateManyWithoutIconInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutIconInput>, Enumerable<TournamentCreateWithoutIconInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithouticonInput>
  }

  export type NewsCreateManyWithoutCoverInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutCoverInput>, Enumerable<NewsCreateWithoutCoverInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutcoverInput>
  }

  export type TeamCreateManyWithoutIconInput = {
    create?: XOR<Enumerable<TeamUncheckedCreateWithoutIconInput>, Enumerable<TeamCreateWithoutIconInput>>
    connect?: Enumerable<TeamWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithouticonInput>
  }

  export type TournamentMatchReportCreateOneWithoutAttachmentsInput = {
    create?: XOR<TournamentMatchReportUncheckedCreateWithoutAttachmentsInput, TournamentMatchReportCreateWithoutAttachmentsInput>
    connect?: TournamentMatchReportWhereUniqueInput
    connectOrCreate?: TournamentMatchReportCreateOrConnectWithoutattachmentsInput
  }

  export type TournamentUncheckedCreateManyWithoutIconInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutIconInput>, Enumerable<TournamentCreateWithoutIconInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithouticonInput>
  }

  export type NewsUncheckedCreateManyWithoutCoverInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutCoverInput>, Enumerable<NewsCreateWithoutCoverInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutcoverInput>
  }

  export type TeamUncheckedCreateManyWithoutIconInput = {
    create?: XOR<Enumerable<TeamUncheckedCreateWithoutIconInput>, Enumerable<TeamCreateWithoutIconInput>>
    connect?: Enumerable<TeamWhereUniqueInput>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithouticonInput>
  }

  export type TournamentUpdateManyWithoutIconInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutIconInput>, Enumerable<TournamentCreateWithoutIconInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    set?: Enumerable<TournamentWhereUniqueInput>
    disconnect?: Enumerable<TournamentWhereUniqueInput>
    delete?: Enumerable<TournamentWhereUniqueInput>
    update?: Enumerable<TournamentUpdateWithWhereUniqueWithoutIconInput>
    updateMany?: Enumerable<TournamentUpdateManyWithWhereWithoutIconInput>
    deleteMany?: Enumerable<TournamentScalarWhereInput>
    upsert?: Enumerable<TournamentUpsertWithWhereUniqueWithoutIconInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithouticonInput>
  }

  export type NewsUpdateManyWithoutCoverInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutCoverInput>, Enumerable<NewsCreateWithoutCoverInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    set?: Enumerable<NewsWhereUniqueInput>
    disconnect?: Enumerable<NewsWhereUniqueInput>
    delete?: Enumerable<NewsWhereUniqueInput>
    update?: Enumerable<NewsUpdateWithWhereUniqueWithoutCoverInput>
    updateMany?: Enumerable<NewsUpdateManyWithWhereWithoutCoverInput>
    deleteMany?: Enumerable<NewsScalarWhereInput>
    upsert?: Enumerable<NewsUpsertWithWhereUniqueWithoutCoverInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutcoverInput>
  }

  export type TeamUpdateManyWithoutIconInput = {
    create?: XOR<Enumerable<TeamUncheckedCreateWithoutIconInput>, Enumerable<TeamCreateWithoutIconInput>>
    connect?: Enumerable<TeamWhereUniqueInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutIconInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutIconInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutIconInput>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithouticonInput>
  }

  export type TournamentMatchReportUpdateOneWithoutAttachmentsInput = {
    create?: XOR<TournamentMatchReportUncheckedCreateWithoutAttachmentsInput, TournamentMatchReportCreateWithoutAttachmentsInput>
    connect?: TournamentMatchReportWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TournamentMatchReportUncheckedUpdateWithoutAttachmentsInput, TournamentMatchReportUpdateWithoutAttachmentsInput>
    upsert?: TournamentMatchReportUpsertWithoutAttachmentsInput
    connectOrCreate?: TournamentMatchReportCreateOrConnectWithoutattachmentsInput
  }

  export type TournamentUncheckedUpdateManyWithoutIconInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutIconInput>, Enumerable<TournamentCreateWithoutIconInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    set?: Enumerable<TournamentWhereUniqueInput>
    disconnect?: Enumerable<TournamentWhereUniqueInput>
    delete?: Enumerable<TournamentWhereUniqueInput>
    update?: Enumerable<TournamentUpdateWithWhereUniqueWithoutIconInput>
    updateMany?: Enumerable<TournamentUpdateManyWithWhereWithoutIconInput>
    deleteMany?: Enumerable<TournamentScalarWhereInput>
    upsert?: Enumerable<TournamentUpsertWithWhereUniqueWithoutIconInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithouticonInput>
  }

  export type NewsUncheckedUpdateManyWithoutCoverInput = {
    create?: XOR<Enumerable<NewsUncheckedCreateWithoutCoverInput>, Enumerable<NewsCreateWithoutCoverInput>>
    connect?: Enumerable<NewsWhereUniqueInput>
    set?: Enumerable<NewsWhereUniqueInput>
    disconnect?: Enumerable<NewsWhereUniqueInput>
    delete?: Enumerable<NewsWhereUniqueInput>
    update?: Enumerable<NewsUpdateWithWhereUniqueWithoutCoverInput>
    updateMany?: Enumerable<NewsUpdateManyWithWhereWithoutCoverInput>
    deleteMany?: Enumerable<NewsScalarWhereInput>
    upsert?: Enumerable<NewsUpsertWithWhereUniqueWithoutCoverInput>
    connectOrCreate?: Enumerable<NewsCreateOrConnectWithoutcoverInput>
  }

  export type TeamUncheckedUpdateManyWithoutIconInput = {
    create?: XOR<Enumerable<TeamUncheckedCreateWithoutIconInput>, Enumerable<TeamCreateWithoutIconInput>>
    connect?: Enumerable<TeamWhereUniqueInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutIconInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutIconInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutIconInput>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithouticonInput>
  }

  export type TournamentCreateManyWithoutGameInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutGameInput>, Enumerable<TournamentCreateWithoutGameInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutgameInput>
  }

  export type RoomCodeCreateManyWithoutGameInput = {
    create?: XOR<Enumerable<RoomCodeUncheckedCreateWithoutGameInput>, Enumerable<RoomCodeCreateWithoutGameInput>>
    connect?: Enumerable<RoomCodeWhereUniqueInput>
    connectOrCreate?: Enumerable<RoomCodeCreateOrConnectWithoutgameInput>
  }

  export type GameAccountCreateManyWithoutGameInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutGameInput>, Enumerable<GameAccountCreateWithoutGameInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutgameInput>
  }

  export type TournamentUncheckedCreateManyWithoutGameInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutGameInput>, Enumerable<TournamentCreateWithoutGameInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutgameInput>
  }

  export type RoomCodeUncheckedCreateManyWithoutGameInput = {
    create?: XOR<Enumerable<RoomCodeUncheckedCreateWithoutGameInput>, Enumerable<RoomCodeCreateWithoutGameInput>>
    connect?: Enumerable<RoomCodeWhereUniqueInput>
    connectOrCreate?: Enumerable<RoomCodeCreateOrConnectWithoutgameInput>
  }

  export type GameAccountUncheckedCreateManyWithoutGameInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutGameInput>, Enumerable<GameAccountCreateWithoutGameInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutgameInput>
  }

  export type TournamentUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutGameInput>, Enumerable<TournamentCreateWithoutGameInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    set?: Enumerable<TournamentWhereUniqueInput>
    disconnect?: Enumerable<TournamentWhereUniqueInput>
    delete?: Enumerable<TournamentWhereUniqueInput>
    update?: Enumerable<TournamentUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<TournamentUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<TournamentScalarWhereInput>
    upsert?: Enumerable<TournamentUpsertWithWhereUniqueWithoutGameInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutgameInput>
  }

  export type RoomCodeUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<RoomCodeUncheckedCreateWithoutGameInput>, Enumerable<RoomCodeCreateWithoutGameInput>>
    connect?: Enumerable<RoomCodeWhereUniqueInput>
    set?: Enumerable<RoomCodeWhereUniqueInput>
    disconnect?: Enumerable<RoomCodeWhereUniqueInput>
    delete?: Enumerable<RoomCodeWhereUniqueInput>
    update?: Enumerable<RoomCodeUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<RoomCodeUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<RoomCodeScalarWhereInput>
    upsert?: Enumerable<RoomCodeUpsertWithWhereUniqueWithoutGameInput>
    connectOrCreate?: Enumerable<RoomCodeCreateOrConnectWithoutgameInput>
  }

  export type GameAccountUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutGameInput>, Enumerable<GameAccountCreateWithoutGameInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    set?: Enumerable<GameAccountWhereUniqueInput>
    disconnect?: Enumerable<GameAccountWhereUniqueInput>
    delete?: Enumerable<GameAccountWhereUniqueInput>
    update?: Enumerable<GameAccountUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<GameAccountUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<GameAccountScalarWhereInput>
    upsert?: Enumerable<GameAccountUpsertWithWhereUniqueWithoutGameInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutgameInput>
  }

  export type TournamentUncheckedUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<TournamentUncheckedCreateWithoutGameInput>, Enumerable<TournamentCreateWithoutGameInput>>
    connect?: Enumerable<TournamentWhereUniqueInput>
    set?: Enumerable<TournamentWhereUniqueInput>
    disconnect?: Enumerable<TournamentWhereUniqueInput>
    delete?: Enumerable<TournamentWhereUniqueInput>
    update?: Enumerable<TournamentUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<TournamentUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<TournamentScalarWhereInput>
    upsert?: Enumerable<TournamentUpsertWithWhereUniqueWithoutGameInput>
    connectOrCreate?: Enumerable<TournamentCreateOrConnectWithoutgameInput>
  }

  export type RoomCodeUncheckedUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<RoomCodeUncheckedCreateWithoutGameInput>, Enumerable<RoomCodeCreateWithoutGameInput>>
    connect?: Enumerable<RoomCodeWhereUniqueInput>
    set?: Enumerable<RoomCodeWhereUniqueInput>
    disconnect?: Enumerable<RoomCodeWhereUniqueInput>
    delete?: Enumerable<RoomCodeWhereUniqueInput>
    update?: Enumerable<RoomCodeUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<RoomCodeUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<RoomCodeScalarWhereInput>
    upsert?: Enumerable<RoomCodeUpsertWithWhereUniqueWithoutGameInput>
    connectOrCreate?: Enumerable<RoomCodeCreateOrConnectWithoutgameInput>
  }

  export type GameAccountUncheckedUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<GameAccountUncheckedCreateWithoutGameInput>, Enumerable<GameAccountCreateWithoutGameInput>>
    connect?: Enumerable<GameAccountWhereUniqueInput>
    set?: Enumerable<GameAccountWhereUniqueInput>
    disconnect?: Enumerable<GameAccountWhereUniqueInput>
    delete?: Enumerable<GameAccountWhereUniqueInput>
    update?: Enumerable<GameAccountUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<GameAccountUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<GameAccountScalarWhereInput>
    upsert?: Enumerable<GameAccountUpsertWithWhereUniqueWithoutGameInput>
    connectOrCreate?: Enumerable<GameAccountCreateOrConnectWithoutgameInput>
  }

  export type GameCreateOneWithoutGameAccountInput = {
    create?: XOR<GameUncheckedCreateWithoutGameAccountInput, GameCreateWithoutGameAccountInput>
    connect?: GameWhereUniqueInput
    connectOrCreate?: GameCreateOrConnectWithoutGameAccountInput
  }

  export type UserCreateOneWithoutGameAccountsInput = {
    create?: XOR<UserUncheckedCreateWithoutGameAccountsInput, UserCreateWithoutGameAccountsInput>
    connect?: UserWhereUniqueInput
    connectOrCreate?: UserCreateOrConnectWithoutgameAccountsInput
  }

  export type GameUpdateOneRequiredWithoutGameAccountInput = {
    create?: XOR<GameUncheckedCreateWithoutGameAccountInput, GameCreateWithoutGameAccountInput>
    connect?: GameWhereUniqueInput
    update?: XOR<GameUncheckedUpdateWithoutGameAccountInput, GameUpdateWithoutGameAccountInput>
    upsert?: GameUpsertWithoutGameAccountInput
    connectOrCreate?: GameCreateOrConnectWithoutGameAccountInput
  }

  export type UserUpdateOneRequiredWithoutGameAccountsInput = {
    create?: XOR<UserUncheckedCreateWithoutGameAccountsInput, UserCreateWithoutGameAccountsInput>
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutGameAccountsInput, UserUpdateWithoutGameAccountsInput>
    upsert?: UserUpsertWithoutGameAccountsInput
    connectOrCreate?: UserCreateOrConnectWithoutgameAccountsInput
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumTeamRoleTypeFilter = {
    equals?: TeamRoleType
    in?: Enumerable<TeamRoleType>
    notIn?: Enumerable<TeamRoleType>
    not?: NestedEnumTeamRoleTypeFilter | TeamRoleType
  }

  export type NestedEnumMatchStateTypeFilter = {
    equals?: MatchStateType
    in?: Enumerable<MatchStateType>
    notIn?: Enumerable<MatchStateType>
    not?: NestedEnumMatchStateTypeFilter | MatchStateType
  }

  export type NestedEnumReportTypeFilter = {
    equals?: ReportType
    in?: Enumerable<ReportType>
    notIn?: Enumerable<ReportType>
    not?: NestedEnumReportTypeFilter | ReportType
  }

  export type NestedEnumNotificationTypeNullableFilter = {
    equals?: NotificationType | null
    in?: Enumerable<NotificationType> | null
    notIn?: Enumerable<NotificationType> | null
    not?: NestedEnumNotificationTypeNullableFilter | NotificationType | null
  }

  export type TournamentCreateWithoutRewardsInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutRewardsInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutrewardsInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutRewardsInput, TournamentCreateWithoutRewardsInput>
  }

  export type TournamentUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUpsertWithoutRewardsInput = {
    update: XOR<TournamentUncheckedUpdateWithoutRewardsInput, TournamentUpdateWithoutRewardsInput>
    create: XOR<TournamentUncheckedCreateWithoutRewardsInput, TournamentCreateWithoutRewardsInput>
  }

  export type TeamMembershipCreateWithoutUserInput = {
    role: TeamRoleType
    invitedAt: Date | string
    joinedAt?: Date | string
    team: TeamCreateOneWithoutMembersInput
  }

  export type TeamMembershipUncheckedCreateWithoutUserInput = {
    role: TeamRoleType
    invitedAt: Date | string
    joinedAt?: Date | string
    teamId: string
  }

  export type TeamMembershipCreateOrConnectWithoutuserInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipUncheckedCreateWithoutUserInput, TeamMembershipCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    type?: NotificationType | null
    title: string
    description: string
    createdAt?: Date | string
    read: boolean
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type?: NotificationType | null
    title: string
    description: string
    createdAt?: Date | string
    read: boolean
  }

  export type NotificationCreateOrConnectWithoutuserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationUncheckedCreateWithoutUserInput, NotificationCreateWithoutUserInput>
  }

  export type GameAccountCreateWithoutUserInput = {
    id: string
    game: GameCreateOneWithoutGameAccountInput
  }

  export type GameAccountUncheckedCreateWithoutUserInput = {
    id: string
    gameId: string
  }

  export type GameAccountCreateOrConnectWithoutuserInput = {
    where: GameAccountWhereUniqueInput
    create: XOR<GameAccountUncheckedCreateWithoutUserInput, GameAccountCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {

  }

  export type AdminUncheckedCreateWithoutUserInput = {

  }

  export type AdminCreateOrConnectWithoutuserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminUncheckedCreateWithoutUserInput, AdminCreateWithoutUserInput>
  }

  export type NewsCreateWithoutAuthorInput = {
    title: string
    content: InputJsonValue
    createdAt?: Date | string
    cover?: ImageCreateOneWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    content: InputJsonValue
    createdAt?: Date | string
    imageId?: number | null
  }

  export type NewsCreateOrConnectWithoutauthorInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsUncheckedCreateWithoutAuthorInput, NewsCreateWithoutAuthorInput>
  }

  export type TournamentApplicationCreateWithoutPlayersInput = {
    createdAt?: Date | string
    tournament: TournamentCreateOneWithoutApplicantsInput
    team: TeamCreateOneWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedCreateWithoutPlayersInput = {
    id?: number
    createdAt?: Date | string
    tournamentId: string
    teamId: string
  }

  export type TournamentApplicationCreateOrConnectWithoutplayersInput = {
    where: TournamentApplicationWhereUniqueInput
    create: XOR<TournamentApplicationUncheckedCreateWithoutPlayersInput, TournamentApplicationCreateWithoutPlayersInput>
  }

  export type TournamentParticipationCreateWithoutPlayersInput = {
    placement?: number | null
    team: TeamCreateOneWithoutTournamentParticipationInput
    tournament: TournamentCreateOneWithoutParticipantsInput
    match?: TournamentMatchCreateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedCreateWithoutPlayersInput = {
    placement?: number | null
    matchId?: number | null
    tournamentId: string
    teamId: string
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationCreateOrConnectWithoutplayersInput = {
    where: TournamentParticipationWhereUniqueInput
    create: XOR<TournamentParticipationUncheckedCreateWithoutPlayersInput, TournamentParticipationCreateWithoutPlayersInput>
  }

  export type TeamInvitationCreateWithoutUserInput = {
    invitedAt?: Date | string
    team: TeamCreateOneWithoutTeamInvitationInput
  }

  export type TeamInvitationUncheckedCreateWithoutUserInput = {
    invitedAt?: Date | string
    teamId: string
  }

  export type TeamInvitationCreateOrConnectWithoutuserInput = {
    where: TeamInvitationWhereUniqueInput
    create: XOR<TeamInvitationUncheckedCreateWithoutUserInput, TeamInvitationCreateWithoutUserInput>
  }

  export type TournamentMatchStateCreateWithoutAcceptedByInput = {
    state: InputJsonValue
    createdAt?: Date | string
    accepted: boolean
    match: TournamentMatchCreateOneWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedCreateWithoutAcceptedByInput = {
    id?: number
    state: InputJsonValue
    createdAt?: Date | string
    accepted: boolean
    matchId: number
  }

  export type TournamentMatchStateCreateOrConnectWithoutacceptedByInput = {
    where: TournamentMatchStateWhereUniqueInput
    create: XOR<TournamentMatchStateUncheckedCreateWithoutAcceptedByInput, TournamentMatchStateCreateWithoutAcceptedByInput>
  }

  export type TournamentMatchReportCreateWithoutReporterInput = {
    type: ReportType
    description: string
    match: TournamentMatchCreateOneWithoutTournamentMatchReportInput
    attachments?: ImageCreateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedCreateWithoutReporterInput = {
    type: ReportType
    description: string
    matchId: number
    attachments?: ImageUncheckedCreateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportCreateOrConnectWithoutreporterInput = {
    where: TournamentMatchReportWhereUniqueInput
    create: XOR<TournamentMatchReportUncheckedCreateWithoutReporterInput, TournamentMatchReportCreateWithoutReporterInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUncheckedUpdateWithoutUserInput, TeamMembershipUpdateWithoutUserInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutUserInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUncheckedUpdateManyWithoutMembershipsInput, TeamMembershipUpdateManyMutationInput>
  }

  export type TeamMembershipScalarWhereInput = {
    AND?: Enumerable<TeamMembershipScalarWhereInput>
    OR?: Enumerable<TeamMembershipScalarWhereInput>
    NOT?: Enumerable<TeamMembershipScalarWhereInput>
    role?: EnumTeamRoleTypeFilter | TeamRoleType
    invitedAt?: DateTimeFilter | Date | string
    joinedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    teamId?: StringFilter | string
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUncheckedUpdateWithoutUserInput, TeamMembershipUpdateWithoutUserInput>
    create: XOR<TeamMembershipUncheckedCreateWithoutUserInput, TeamMembershipCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUncheckedUpdateWithoutUserInput, NotificationUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUncheckedUpdateManyWithoutNotificationsInput, NotificationUpdateManyMutationInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    id?: IntFilter | number
    type?: EnumNotificationTypeNullableFilter | NotificationType | null
    title?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    read?: BoolFilter | boolean
    userId?: IntFilter | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUncheckedUpdateWithoutUserInput, NotificationUpdateWithoutUserInput>
    create: XOR<NotificationUncheckedCreateWithoutUserInput, NotificationCreateWithoutUserInput>
  }

  export type GameAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: GameAccountWhereUniqueInput
    data: XOR<GameAccountUncheckedUpdateWithoutUserInput, GameAccountUpdateWithoutUserInput>
  }

  export type GameAccountUpdateManyWithWhereWithoutUserInput = {
    where: GameAccountScalarWhereInput
    data: XOR<GameAccountUncheckedUpdateManyWithoutGameAccountsInput, GameAccountUpdateManyMutationInput>
  }

  export type GameAccountScalarWhereInput = {
    AND?: Enumerable<GameAccountScalarWhereInput>
    OR?: Enumerable<GameAccountScalarWhereInput>
    NOT?: Enumerable<GameAccountScalarWhereInput>
    id?: StringFilter | string
    gameId?: StringFilter | string
    userId?: IntFilter | number
  }

  export type GameAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: GameAccountWhereUniqueInput
    update: XOR<GameAccountUncheckedUpdateWithoutUserInput, GameAccountUpdateWithoutUserInput>
    create: XOR<GameAccountUncheckedCreateWithoutUserInput, GameAccountCreateWithoutUserInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUncheckedUpdateWithoutUserInput, AdminUpdateWithoutUserInput>
  }

  export type AdminUpdateManyWithWhereWithoutUserInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUncheckedUpdateManyWithoutAdminInput, AdminUpdateManyMutationInput>
  }

  export type AdminScalarWhereInput = {
    AND?: Enumerable<AdminScalarWhereInput>
    OR?: Enumerable<AdminScalarWhereInput>
    NOT?: Enumerable<AdminScalarWhereInput>
    userId?: IntFilter | number
  }

  export type NewsUpdateWithWhereUniqueWithoutAuthorInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUncheckedUpdateWithoutAuthorInput, NewsUpdateWithoutAuthorInput>
  }

  export type NewsUpdateManyWithWhereWithoutAuthorInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUncheckedUpdateManyWithoutNewsInput, NewsUpdateManyMutationInput>
  }

  export type NewsScalarWhereInput = {
    AND?: Enumerable<NewsScalarWhereInput>
    OR?: Enumerable<NewsScalarWhereInput>
    NOT?: Enumerable<NewsScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    imageId?: IntNullableFilter | number | null
  }

  export type NewsUpsertWithWhereUniqueWithoutAuthorInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUncheckedUpdateWithoutAuthorInput, NewsUpdateWithoutAuthorInput>
    create: XOR<NewsUncheckedCreateWithoutAuthorInput, NewsCreateWithoutAuthorInput>
  }

  export type TournamentApplicationUpdateWithoutPlayersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneRequiredWithoutApplicantsInput
    team?: TeamUpdateOneRequiredWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentApplicationUpsertWithoutPlayersInput = {
    update: XOR<TournamentApplicationUncheckedUpdateWithoutPlayersInput, TournamentApplicationUpdateWithoutPlayersInput>
    create: XOR<TournamentApplicationUncheckedCreateWithoutPlayersInput, TournamentApplicationCreateWithoutPlayersInput>
  }

  export type TournamentParticipationUpdateWithoutPlayersInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutTournamentParticipationInput
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsInput
    match?: TournamentMatchUpdateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateWithoutPlayersInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUpsertWithoutPlayersInput = {
    update: XOR<TournamentParticipationUncheckedUpdateWithoutPlayersInput, TournamentParticipationUpdateWithoutPlayersInput>
    create: XOR<TournamentParticipationUncheckedCreateWithoutPlayersInput, TournamentParticipationCreateWithoutPlayersInput>
  }

  export type TeamInvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamInvitationWhereUniqueInput
    data: XOR<TeamInvitationUncheckedUpdateWithoutUserInput, TeamInvitationUpdateWithoutUserInput>
  }

  export type TeamInvitationUpdateManyWithWhereWithoutUserInput = {
    where: TeamInvitationScalarWhereInput
    data: XOR<TeamInvitationUncheckedUpdateManyWithoutTeamInvitationInput, TeamInvitationUpdateManyMutationInput>
  }

  export type TeamInvitationScalarWhereInput = {
    AND?: Enumerable<TeamInvitationScalarWhereInput>
    OR?: Enumerable<TeamInvitationScalarWhereInput>
    NOT?: Enumerable<TeamInvitationScalarWhereInput>
    invitedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    teamId?: StringFilter | string
  }

  export type TeamInvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamInvitationWhereUniqueInput
    update: XOR<TeamInvitationUncheckedUpdateWithoutUserInput, TeamInvitationUpdateWithoutUserInput>
    create: XOR<TeamInvitationUncheckedCreateWithoutUserInput, TeamInvitationCreateWithoutUserInput>
  }

  export type TournamentMatchStateUpdateWithoutAcceptedByInput = {
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    match?: TournamentMatchUpdateOneRequiredWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedUpdateWithoutAcceptedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    matchId?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentMatchStateUpsertWithoutAcceptedByInput = {
    update: XOR<TournamentMatchStateUncheckedUpdateWithoutAcceptedByInput, TournamentMatchStateUpdateWithoutAcceptedByInput>
    create: XOR<TournamentMatchStateUncheckedCreateWithoutAcceptedByInput, TournamentMatchStateCreateWithoutAcceptedByInput>
  }

  export type TournamentMatchReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: TournamentMatchReportWhereUniqueInput
    data: XOR<TournamentMatchReportUncheckedUpdateWithoutReporterInput, TournamentMatchReportUpdateWithoutReporterInput>
  }

  export type TournamentMatchReportUpdateManyWithWhereWithoutReporterInput = {
    where: TournamentMatchReportScalarWhereInput
    data: XOR<TournamentMatchReportUncheckedUpdateManyWithoutTournamentMatchReportInput, TournamentMatchReportUpdateManyMutationInput>
  }

  export type TournamentMatchReportScalarWhereInput = {
    AND?: Enumerable<TournamentMatchReportScalarWhereInput>
    OR?: Enumerable<TournamentMatchReportScalarWhereInput>
    NOT?: Enumerable<TournamentMatchReportScalarWhereInput>
    type?: EnumReportTypeFilter | ReportType
    description?: StringFilter | string
    matchId?: IntFilter | number
    reporterId?: IntFilter | number
  }

  export type TournamentMatchReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: TournamentMatchReportWhereUniqueInput
    update: XOR<TournamentMatchReportUncheckedUpdateWithoutReporterInput, TournamentMatchReportUpdateWithoutReporterInput>
    create: XOR<TournamentMatchReportUncheckedCreateWithoutReporterInput, TournamentMatchReportCreateWithoutReporterInput>
  }

  export type TeamCreateWithoutTournamentInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    icon?: ImageCreateOneWithoutTeamInput
    members?: TeamMembershipCreateManyWithoutTeamInput
    TournamentApplication?: TournamentApplicationCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTournamentInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    imageId?: number | null
    members?: TeamMembershipUncheckedCreateManyWithoutTeamInput
    TournamentApplication?: TournamentApplicationUncheckedCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTournamentInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamUncheckedCreateWithoutTournamentInput, TeamCreateWithoutTournamentInput>
  }

  export type GameCreateWithoutTournamentInput = {
    id: string
    name: string
    RoomCode?: RoomCodeCreateManyWithoutGameInput
    GameAccount?: GameAccountCreateManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutTournamentInput = {
    id: string
    name: string
    RoomCode?: RoomCodeUncheckedCreateManyWithoutGameInput
    GameAccount?: GameAccountUncheckedCreateManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTournamentInput = {
    where: GameWhereUniqueInput
    create: XOR<GameUncheckedCreateWithoutTournamentInput, GameCreateWithoutTournamentInput>
  }

  export type ImageCreateWithoutTournamentInput = {
    path: string
    width: number
    height: number
    caption?: string | null
    News?: NewsCreateManyWithoutCoverInput
    Team?: TeamCreateManyWithoutIconInput
    TournamentMatchReport?: TournamentMatchReportCreateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedCreateWithoutTournamentInput = {
    id?: number
    path: string
    width: number
    height: number
    caption?: string | null
    tournamentMatchReportMatchId?: number | null
    tournamentMatchReportReporterId?: number | null
    News?: NewsUncheckedCreateManyWithoutCoverInput
    Team?: TeamUncheckedCreateManyWithoutIconInput
  }

  export type ImageCreateOrConnectWithoutTournamentInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageUncheckedCreateWithoutTournamentInput, ImageCreateWithoutTournamentInput>
  }

  export type TournamentParticipationCreateWithoutTournamentInput = {
    placement?: number | null
    team: TeamCreateOneWithoutTournamentParticipationInput
    players?: UserCreateManyWithoutTournamentParticipationInput
    match?: TournamentMatchCreateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedCreateWithoutTournamentInput = {
    placement?: number | null
    matchId?: number | null
    teamId: string
    players?: UserUncheckedCreateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationCreateOrConnectWithouttournamentInput = {
    where: TournamentParticipationWhereUniqueInput
    create: XOR<TournamentParticipationUncheckedCreateWithoutTournamentInput, TournamentParticipationCreateWithoutTournamentInput>
  }

  export type TournamentApplicationCreateWithoutTournamentInput = {
    createdAt?: Date | string
    team: TeamCreateOneWithoutTournamentApplicationInput
    players?: UserCreateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedCreateWithoutTournamentInput = {
    id?: number
    createdAt?: Date | string
    teamId: string
    players?: UserUncheckedCreateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationCreateOrConnectWithouttournamentInput = {
    where: TournamentApplicationWhereUniqueInput
    create: XOR<TournamentApplicationUncheckedCreateWithoutTournamentInput, TournamentApplicationCreateWithoutTournamentInput>
  }

  export type RewardCreateWithoutTournamentInput = {
    placement: number
    points: number
  }

  export type RewardUncheckedCreateWithoutTournamentInput = {
    id?: number
    placement: number
    points: number
  }

  export type RewardCreateOrConnectWithouttournamentInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardUncheckedCreateWithoutTournamentInput, RewardCreateWithoutTournamentInput>
  }

  export type TournamentGridElementCreateWithoutTournamentInput = {
    round: number
    group: number
    participant: TournamentParticipationCreateOneWithoutTournamentGridElementInput
    match?: TournamentMatchCreateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedCreateWithoutTournamentInput = {
    id?: number
    round: number
    group: number
    matchId?: number | null
    teamId: string
  }

  export type TournamentGridElementCreateOrConnectWithouttournamentInput = {
    where: TournamentGridElementWhereUniqueInput
    create: XOR<TournamentGridElementUncheckedCreateWithoutTournamentInput, TournamentGridElementCreateWithoutTournamentInput>
  }

  export type TournamentMatchCreateWithoutTournamentInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCode: RoomCodeCreateOneWithoutTournamentMatchInput
    participants?: TournamentParticipationCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateWithoutTournamentInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCodeId: number
    participants?: TournamentParticipationUncheckedCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchCreateOrConnectWithouttournamentInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentInput, TournamentMatchCreateWithoutTournamentInput>
  }

  export type TeamUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: ImageUpdateOneWithoutTeamInput
    members?: TeamMembershipUpdateManyWithoutTeamInput
    TournamentApplication?: TournamentApplicationUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamInput
    TournamentApplication?: TournamentApplicationUncheckedUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUpsertWithoutTournamentInput = {
    update: XOR<TeamUncheckedUpdateWithoutTournamentInput, TeamUpdateWithoutTournamentInput>
    create: XOR<TeamUncheckedCreateWithoutTournamentInput, TeamCreateWithoutTournamentInput>
  }

  export type GameUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RoomCode?: RoomCodeUpdateManyWithoutGameInput
    GameAccount?: GameAccountUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RoomCode?: RoomCodeUncheckedUpdateManyWithoutGameInput
    GameAccount?: GameAccountUncheckedUpdateManyWithoutGameInput
  }

  export type GameUpsertWithoutTournamentInput = {
    update: XOR<GameUncheckedUpdateWithoutTournamentInput, GameUpdateWithoutTournamentInput>
    create: XOR<GameUncheckedCreateWithoutTournamentInput, GameCreateWithoutTournamentInput>
  }

  export type ImageUpdateWithoutTournamentInput = {
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    News?: NewsUpdateManyWithoutCoverInput
    Team?: TeamUpdateManyWithoutIconInput
    TournamentMatchReport?: TournamentMatchReportUpdateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchReportMatchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentMatchReportReporterId?: NullableIntFieldUpdateOperationsInput | number | null
    News?: NewsUncheckedUpdateManyWithoutCoverInput
    Team?: TeamUncheckedUpdateManyWithoutIconInput
  }

  export type ImageUpsertWithoutTournamentInput = {
    update: XOR<ImageUncheckedUpdateWithoutTournamentInput, ImageUpdateWithoutTournamentInput>
    create: XOR<ImageUncheckedCreateWithoutTournamentInput, ImageCreateWithoutTournamentInput>
  }

  export type TournamentParticipationUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentParticipationWhereUniqueInput
    data: XOR<TournamentParticipationUncheckedUpdateWithoutTournamentInput, TournamentParticipationUpdateWithoutTournamentInput>
  }

  export type TournamentParticipationUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentParticipationScalarWhereInput
    data: XOR<TournamentParticipationUncheckedUpdateManyWithoutParticipantsInput, TournamentParticipationUpdateManyMutationInput>
  }

  export type TournamentParticipationScalarWhereInput = {
    AND?: Enumerable<TournamentParticipationScalarWhereInput>
    OR?: Enumerable<TournamentParticipationScalarWhereInput>
    NOT?: Enumerable<TournamentParticipationScalarWhereInput>
    placement?: IntNullableFilter | number | null
    matchId?: IntNullableFilter | number | null
    tournamentId?: StringFilter | string
    teamId?: StringFilter | string
  }

  export type TournamentParticipationUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentParticipationWhereUniqueInput
    update: XOR<TournamentParticipationUncheckedUpdateWithoutTournamentInput, TournamentParticipationUpdateWithoutTournamentInput>
    create: XOR<TournamentParticipationUncheckedCreateWithoutTournamentInput, TournamentParticipationCreateWithoutTournamentInput>
  }

  export type TournamentApplicationUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentApplicationWhereUniqueInput
    data: XOR<TournamentApplicationUncheckedUpdateWithoutTournamentInput, TournamentApplicationUpdateWithoutTournamentInput>
  }

  export type TournamentApplicationUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentApplicationScalarWhereInput
    data: XOR<TournamentApplicationUncheckedUpdateManyWithoutApplicantsInput, TournamentApplicationUpdateManyMutationInput>
  }

  export type TournamentApplicationScalarWhereInput = {
    AND?: Enumerable<TournamentApplicationScalarWhereInput>
    OR?: Enumerable<TournamentApplicationScalarWhereInput>
    NOT?: Enumerable<TournamentApplicationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    tournamentId?: StringFilter | string
    teamId?: StringFilter | string
  }

  export type TournamentApplicationUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentApplicationWhereUniqueInput
    update: XOR<TournamentApplicationUncheckedUpdateWithoutTournamentInput, TournamentApplicationUpdateWithoutTournamentInput>
    create: XOR<TournamentApplicationUncheckedCreateWithoutTournamentInput, TournamentApplicationCreateWithoutTournamentInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutTournamentInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUncheckedUpdateWithoutTournamentInput, RewardUpdateWithoutTournamentInput>
  }

  export type RewardUpdateManyWithWhereWithoutTournamentInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUncheckedUpdateManyWithoutRewardsInput, RewardUpdateManyMutationInput>
  }

  export type RewardScalarWhereInput = {
    AND?: Enumerable<RewardScalarWhereInput>
    OR?: Enumerable<RewardScalarWhereInput>
    NOT?: Enumerable<RewardScalarWhereInput>
    id?: IntFilter | number
    placement?: IntFilter | number
    tournamentId?: StringFilter | string
    points?: IntFilter | number
  }

  export type RewardUpsertWithWhereUniqueWithoutTournamentInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUncheckedUpdateWithoutTournamentInput, RewardUpdateWithoutTournamentInput>
    create: XOR<RewardUncheckedCreateWithoutTournamentInput, RewardCreateWithoutTournamentInput>
  }

  export type TournamentGridElementUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentGridElementWhereUniqueInput
    data: XOR<TournamentGridElementUncheckedUpdateWithoutTournamentInput, TournamentGridElementUpdateWithoutTournamentInput>
  }

  export type TournamentGridElementUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentGridElementScalarWhereInput
    data: XOR<TournamentGridElementUncheckedUpdateManyWithoutTournamentGridElementInput, TournamentGridElementUpdateManyMutationInput>
  }

  export type TournamentGridElementScalarWhereInput = {
    AND?: Enumerable<TournamentGridElementScalarWhereInput>
    OR?: Enumerable<TournamentGridElementScalarWhereInput>
    NOT?: Enumerable<TournamentGridElementScalarWhereInput>
    id?: IntFilter | number
    round?: IntFilter | number
    group?: IntFilter | number
    tournamentId?: StringFilter | string
    matchId?: IntNullableFilter | number | null
    teamId?: StringFilter | string
  }

  export type TournamentGridElementUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentGridElementWhereUniqueInput
    update: XOR<TournamentGridElementUncheckedUpdateWithoutTournamentInput, TournamentGridElementUpdateWithoutTournamentInput>
    create: XOR<TournamentGridElementUncheckedCreateWithoutTournamentInput, TournamentGridElementCreateWithoutTournamentInput>
  }

  export type TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentMatchWhereUniqueInput
    data: XOR<TournamentMatchUncheckedUpdateWithoutTournamentInput, TournamentMatchUpdateWithoutTournamentInput>
  }

  export type TournamentMatchUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentMatchScalarWhereInput
    data: XOR<TournamentMatchUncheckedUpdateManyWithoutTournamentMatchInput, TournamentMatchUpdateManyMutationInput>
  }

  export type TournamentMatchScalarWhereInput = {
    AND?: Enumerable<TournamentMatchScalarWhereInput>
    OR?: Enumerable<TournamentMatchScalarWhereInput>
    NOT?: Enumerable<TournamentMatchScalarWhereInput>
    id?: IntFilter | number
    joinUntil?: DateTimeNullableFilter | Date | string | null
    createRoomUntil?: DateTimeFilter | Date | string
    state?: EnumMatchStateTypeFilter | MatchStateType
    roomCodeId?: IntFilter | number
    tournamentId?: StringFilter | string
  }

  export type TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentMatchWhereUniqueInput
    update: XOR<TournamentMatchUncheckedUpdateWithoutTournamentInput, TournamentMatchUpdateWithoutTournamentInput>
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentInput, TournamentMatchCreateWithoutTournamentInput>
  }

  export type UserCreateWithoutAdminInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUncheckedUpdateWithoutAdminInput, UserUpdateWithoutAdminInput>
    create: XOR<UserUncheckedCreateWithoutAdminInput, UserCreateWithoutAdminInput>
  }

  export type UserCreateWithoutNewsInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutNewsInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutNewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutNewsInput, UserCreateWithoutNewsInput>
  }

  export type ImageCreateWithoutNewsInput = {
    path: string
    width: number
    height: number
    caption?: string | null
    Tournament?: TournamentCreateManyWithoutIconInput
    Team?: TeamCreateManyWithoutIconInput
    TournamentMatchReport?: TournamentMatchReportCreateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedCreateWithoutNewsInput = {
    id?: number
    path: string
    width: number
    height: number
    caption?: string | null
    tournamentMatchReportMatchId?: number | null
    tournamentMatchReportReporterId?: number | null
    Tournament?: TournamentUncheckedCreateManyWithoutIconInput
    Team?: TeamUncheckedCreateManyWithoutIconInput
  }

  export type ImageCreateOrConnectWithoutNewsInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageUncheckedCreateWithoutNewsInput, ImageCreateWithoutNewsInput>
  }

  export type UserUpdateWithoutNewsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpsertWithoutNewsInput = {
    update: XOR<UserUncheckedUpdateWithoutNewsInput, UserUpdateWithoutNewsInput>
    create: XOR<UserUncheckedCreateWithoutNewsInput, UserCreateWithoutNewsInput>
  }

  export type ImageUpdateWithoutNewsInput = {
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Tournament?: TournamentUpdateManyWithoutIconInput
    Team?: TeamUpdateManyWithoutIconInput
    TournamentMatchReport?: TournamentMatchReportUpdateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedUpdateWithoutNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchReportMatchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentMatchReportReporterId?: NullableIntFieldUpdateOperationsInput | number | null
    Tournament?: TournamentUncheckedUpdateManyWithoutIconInput
    Team?: TeamUncheckedUpdateManyWithoutIconInput
  }

  export type ImageUpsertWithoutNewsInput = {
    update: XOR<ImageUncheckedUpdateWithoutNewsInput, ImageUpdateWithoutNewsInput>
    create: XOR<ImageUncheckedCreateWithoutNewsInput, ImageCreateWithoutNewsInput>
  }

  export type TournamentCreateWithoutApplicantsInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutApplicantsInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutapplicantsInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutApplicantsInput, TournamentCreateWithoutApplicantsInput>
  }

  export type TeamCreateWithoutTournamentApplicationInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    icon?: ImageCreateOneWithoutTeamInput
    members?: TeamMembershipCreateManyWithoutTeamInput
    Tournament?: TournamentCreateManyWithoutOrganizerInput
    TournamentParticipation?: TournamentParticipationCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTournamentApplicationInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    imageId?: number | null
    members?: TeamMembershipUncheckedCreateManyWithoutTeamInput
    Tournament?: TournamentUncheckedCreateManyWithoutOrganizerInput
    TournamentParticipation?: TournamentParticipationUncheckedCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTournamentApplicationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamUncheckedCreateWithoutTournamentApplicationInput, TeamCreateWithoutTournamentApplicationInput>
  }

  export type UserCreateWithoutTournamentApplicationInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutTournamentApplicationInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutTournamentApplicationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTournamentApplicationInput, UserCreateWithoutTournamentApplicationInput>
  }

  export type TournamentUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUpsertWithoutApplicantsInput = {
    update: XOR<TournamentUncheckedUpdateWithoutApplicantsInput, TournamentUpdateWithoutApplicantsInput>
    create: XOR<TournamentUncheckedCreateWithoutApplicantsInput, TournamentCreateWithoutApplicantsInput>
  }

  export type TeamUpdateWithoutTournamentApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: ImageUpdateOneWithoutTeamInput
    members?: TeamMembershipUpdateManyWithoutTeamInput
    Tournament?: TournamentUpdateManyWithoutOrganizerInput
    TournamentParticipation?: TournamentParticipationUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTournamentApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamInput
    Tournament?: TournamentUncheckedUpdateManyWithoutOrganizerInput
    TournamentParticipation?: TournamentParticipationUncheckedUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUpsertWithoutTournamentApplicationInput = {
    update: XOR<TeamUncheckedUpdateWithoutTournamentApplicationInput, TeamUpdateWithoutTournamentApplicationInput>
    create: XOR<TeamUncheckedCreateWithoutTournamentApplicationInput, TeamCreateWithoutTournamentApplicationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTournamentApplicationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUncheckedUpdateWithoutTournamentApplicationInput, UserUpdateWithoutTournamentApplicationInput>
  }

  export type UserUpdateManyWithWhereWithoutTournamentApplicationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUncheckedUpdateManyWithoutPlayersInput, UserUpdateManyMutationInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    tournamentApplicationId?: IntNullableFilter | number | null
    tournamentParticipationTeamId?: StringNullableFilter | string | null
    tournamentParticipationTournamentId?: StringNullableFilter | string | null
    tournamentMatchStateId?: IntNullableFilter | number | null
  }

  export type UserUpsertWithWhereUniqueWithoutTournamentApplicationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUncheckedUpdateWithoutTournamentApplicationInput, UserUpdateWithoutTournamentApplicationInput>
    create: XOR<UserUncheckedCreateWithoutTournamentApplicationInput, UserCreateWithoutTournamentApplicationInput>
  }

  export type TournamentCreateWithoutTournamentGridElementInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutTournamentGridElementInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutTournamentGridElementInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutTournamentGridElementInput, TournamentCreateWithoutTournamentGridElementInput>
  }

  export type TournamentParticipationCreateWithoutTournamentGridElementInput = {
    placement?: number | null
    team: TeamCreateOneWithoutTournamentParticipationInput
    tournament: TournamentCreateOneWithoutParticipantsInput
    players?: UserCreateManyWithoutTournamentParticipationInput
    match?: TournamentMatchCreateOneWithoutParticipantsInput
  }

  export type TournamentParticipationUncheckedCreateWithoutTournamentGridElementInput = {
    placement?: number | null
    matchId?: number | null
    tournamentId: string
    teamId: string
    players?: UserUncheckedCreateManyWithoutTournamentParticipationInput
  }

  export type TournamentParticipationCreateOrConnectWithoutTournamentGridElementInput = {
    where: TournamentParticipationWhereUniqueInput
    create: XOR<TournamentParticipationUncheckedCreateWithoutTournamentGridElementInput, TournamentParticipationCreateWithoutTournamentGridElementInput>
  }

  export type TournamentMatchCreateWithoutTournamentGridElementInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournament: TournamentCreateOneWithoutTournamentMatchInput
    roomCode: RoomCodeCreateOneWithoutTournamentMatchInput
    participants?: TournamentParticipationCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateWithoutTournamentGridElementInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCodeId: number
    tournamentId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchCreateOrConnectWithoutTournamentGridElementInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentGridElementInput, TournamentMatchCreateWithoutTournamentGridElementInput>
  }

  export type TournamentUpdateWithoutTournamentGridElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutTournamentGridElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUpsertWithoutTournamentGridElementInput = {
    update: XOR<TournamentUncheckedUpdateWithoutTournamentGridElementInput, TournamentUpdateWithoutTournamentGridElementInput>
    create: XOR<TournamentUncheckedCreateWithoutTournamentGridElementInput, TournamentCreateWithoutTournamentGridElementInput>
  }

  export type TournamentParticipationUpdateWithoutTournamentGridElementInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutTournamentParticipationInput
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsInput
    players?: UserUpdateManyWithoutTournamentParticipationInput
    match?: TournamentMatchUpdateOneWithoutParticipantsInput
  }

  export type TournamentParticipationUncheckedUpdateWithoutTournamentGridElementInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentParticipationInput
  }

  export type TournamentParticipationUpsertWithoutTournamentGridElementInput = {
    update: XOR<TournamentParticipationUncheckedUpdateWithoutTournamentGridElementInput, TournamentParticipationUpdateWithoutTournamentGridElementInput>
    create: XOR<TournamentParticipationUncheckedCreateWithoutTournamentGridElementInput, TournamentParticipationCreateWithoutTournamentGridElementInput>
  }

  export type TournamentMatchUpdateWithoutTournamentGridElementInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournament?: TournamentUpdateOneRequiredWithoutTournamentMatchInput
    roomCode?: RoomCodeUpdateOneRequiredWithoutTournamentMatchInput
    participants?: TournamentParticipationUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateWithoutTournamentGridElementInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUpsertWithoutTournamentGridElementInput = {
    update: XOR<TournamentMatchUncheckedUpdateWithoutTournamentGridElementInput, TournamentMatchUpdateWithoutTournamentGridElementInput>
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentGridElementInput, TournamentMatchCreateWithoutTournamentGridElementInput>
  }

  export type TeamCreateWithoutTournamentParticipationInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    icon?: ImageCreateOneWithoutTeamInput
    members?: TeamMembershipCreateManyWithoutTeamInput
    Tournament?: TournamentCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTournamentParticipationInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    imageId?: number | null
    members?: TeamMembershipUncheckedCreateManyWithoutTeamInput
    Tournament?: TournamentUncheckedCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTournamentParticipationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamUncheckedCreateWithoutTournamentParticipationInput, TeamCreateWithoutTournamentParticipationInput>
  }

  export type TournamentCreateWithoutParticipantsInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutParticipantsInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    gameId: string
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutparticipantsInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutParticipantsInput, TournamentCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTournamentParticipationInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutTournamentParticipationInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutTournamentParticipationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTournamentParticipationInput, UserCreateWithoutTournamentParticipationInput>
  }

  export type TournamentMatchCreateWithoutParticipantsInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournament: TournamentCreateOneWithoutTournamentMatchInput
    roomCode: RoomCodeCreateOneWithoutTournamentMatchInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateWithoutParticipantsInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCodeId: number
    tournamentId: string
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchCreateOrConnectWithoutparticipantsInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchUncheckedCreateWithoutParticipantsInput, TournamentMatchCreateWithoutParticipantsInput>
  }

  export type TournamentGridElementCreateWithoutParticipantInput = {
    round: number
    group: number
    tournament: TournamentCreateOneWithoutTournamentGridElementInput
    match?: TournamentMatchCreateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedCreateWithoutParticipantInput = {
    id?: number
    round: number
    group: number
    matchId?: number | null
  }

  export type TournamentGridElementCreateOrConnectWithoutparticipantInput = {
    where: TournamentGridElementWhereUniqueInput
    create: XOR<TournamentGridElementUncheckedCreateWithoutParticipantInput, TournamentGridElementCreateWithoutParticipantInput>
  }

  export type TeamUpdateWithoutTournamentParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: ImageUpdateOneWithoutTeamInput
    members?: TeamMembershipUpdateManyWithoutTeamInput
    Tournament?: TournamentUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTournamentParticipationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamInput
    Tournament?: TournamentUncheckedUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUpsertWithoutTournamentParticipationInput = {
    update: XOR<TeamUncheckedUpdateWithoutTournamentParticipationInput, TeamUpdateWithoutTournamentParticipationInput>
    create: XOR<TeamUncheckedCreateWithoutTournamentParticipationInput, TeamCreateWithoutTournamentParticipationInput>
  }

  export type TournamentUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUpsertWithoutParticipantsInput = {
    update: XOR<TournamentUncheckedUpdateWithoutParticipantsInput, TournamentUpdateWithoutParticipantsInput>
    create: XOR<TournamentUncheckedCreateWithoutParticipantsInput, TournamentCreateWithoutParticipantsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTournamentParticipationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUncheckedUpdateWithoutTournamentParticipationInput, UserUpdateWithoutTournamentParticipationInput>
  }

  export type UserUpdateManyWithWhereWithoutTournamentParticipationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUncheckedUpdateManyWithoutPlayersInput, UserUpdateManyMutationInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTournamentParticipationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUncheckedUpdateWithoutTournamentParticipationInput, UserUpdateWithoutTournamentParticipationInput>
    create: XOR<UserUncheckedCreateWithoutTournamentParticipationInput, UserCreateWithoutTournamentParticipationInput>
  }

  export type TournamentMatchUpdateWithoutParticipantsInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournament?: TournamentUpdateOneRequiredWithoutTournamentMatchInput
    roomCode?: RoomCodeUpdateOneRequiredWithoutTournamentMatchInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUpsertWithoutParticipantsInput = {
    update: XOR<TournamentMatchUncheckedUpdateWithoutParticipantsInput, TournamentMatchUpdateWithoutParticipantsInput>
    create: XOR<TournamentMatchUncheckedCreateWithoutParticipantsInput, TournamentMatchCreateWithoutParticipantsInput>
  }

  export type TournamentGridElementUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TournamentGridElementWhereUniqueInput
    data: XOR<TournamentGridElementUncheckedUpdateWithoutParticipantInput, TournamentGridElementUpdateWithoutParticipantInput>
  }

  export type TournamentGridElementUpdateManyWithWhereWithoutParticipantInput = {
    where: TournamentGridElementScalarWhereInput
    data: XOR<TournamentGridElementUncheckedUpdateManyWithoutTournamentGridElementInput, TournamentGridElementUpdateManyMutationInput>
  }

  export type TournamentGridElementUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TournamentGridElementWhereUniqueInput
    update: XOR<TournamentGridElementUncheckedUpdateWithoutParticipantInput, TournamentGridElementUpdateWithoutParticipantInput>
    create: XOR<TournamentGridElementUncheckedCreateWithoutParticipantInput, TournamentGridElementCreateWithoutParticipantInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutmembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutMembershipsInput, UserCreateWithoutMembershipsInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    icon?: ImageCreateOneWithoutTeamInput
    Tournament?: TournamentCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    imageId?: number | null
    Tournament?: TournamentUncheckedCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutmembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamUncheckedCreateWithoutMembersInput, TeamCreateWithoutMembersInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUncheckedUpdateWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>
    create: XOR<UserUncheckedCreateWithoutMembershipsInput, UserCreateWithoutMembershipsInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: ImageUpdateOneWithoutTeamInput
    Tournament?: TournamentUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    Tournament?: TournamentUncheckedUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUncheckedUpdateWithoutMembersInput, TeamUpdateWithoutMembersInput>
    create: XOR<TeamUncheckedCreateWithoutMembersInput, TeamCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamInvitationInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutTeamInvitationInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutTeamInvitationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTeamInvitationInput, UserCreateWithoutTeamInvitationInput>
  }

  export type TeamCreateWithoutTeamInvitationInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    icon?: ImageCreateOneWithoutTeamInput
    members?: TeamMembershipCreateManyWithoutTeamInput
    Tournament?: TournamentCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamInvitationInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    imageId?: number | null
    members?: TeamMembershipUncheckedCreateManyWithoutTeamInput
    Tournament?: TournamentUncheckedCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamInvitationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamUncheckedCreateWithoutTeamInvitationInput, TeamCreateWithoutTeamInvitationInput>
  }

  export type UserUpdateWithoutTeamInvitationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutTeamInvitationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpsertWithoutTeamInvitationInput = {
    update: XOR<UserUncheckedUpdateWithoutTeamInvitationInput, UserUpdateWithoutTeamInvitationInput>
    create: XOR<UserUncheckedCreateWithoutTeamInvitationInput, UserCreateWithoutTeamInvitationInput>
  }

  export type TeamUpdateWithoutTeamInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: ImageUpdateOneWithoutTeamInput
    members?: TeamMembershipUpdateManyWithoutTeamInput
    Tournament?: TournamentUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutTeamInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamInput
    Tournament?: TournamentUncheckedUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUpsertWithoutTeamInvitationInput = {
    update: XOR<TeamUncheckedUpdateWithoutTeamInvitationInput, TeamUpdateWithoutTeamInvitationInput>
    create: XOR<TeamUncheckedCreateWithoutTeamInvitationInput, TeamCreateWithoutTeamInvitationInput>
  }

  export type UserCreateWithoutTournamentMatchStateInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutTournamentMatchStateInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutTournamentMatchStateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTournamentMatchStateInput, UserCreateWithoutTournamentMatchStateInput>
  }

  export type TournamentMatchCreateWithoutTournamentMatchStateInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournament: TournamentCreateOneWithoutTournamentMatchInput
    roomCode: RoomCodeCreateOneWithoutTournamentMatchInput
    participants?: TournamentParticipationCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateWithoutTournamentMatchStateInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCodeId: number
    tournamentId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchCreateOrConnectWithoutTournamentMatchStateInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchStateInput, TournamentMatchCreateWithoutTournamentMatchStateInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTournamentMatchStateInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUncheckedUpdateWithoutTournamentMatchStateInput, UserUpdateWithoutTournamentMatchStateInput>
  }

  export type UserUpdateManyWithWhereWithoutTournamentMatchStateInput = {
    where: UserScalarWhereInput
    data: XOR<UserUncheckedUpdateManyWithoutAcceptedByInput, UserUpdateManyMutationInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTournamentMatchStateInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUncheckedUpdateWithoutTournamentMatchStateInput, UserUpdateWithoutTournamentMatchStateInput>
    create: XOR<UserUncheckedCreateWithoutTournamentMatchStateInput, UserCreateWithoutTournamentMatchStateInput>
  }

  export type TournamentMatchUpdateWithoutTournamentMatchStateInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournament?: TournamentUpdateOneRequiredWithoutTournamentMatchInput
    roomCode?: RoomCodeUpdateOneRequiredWithoutTournamentMatchInput
    participants?: TournamentParticipationUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateWithoutTournamentMatchStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUpsertWithoutTournamentMatchStateInput = {
    update: XOR<TournamentMatchUncheckedUpdateWithoutTournamentMatchStateInput, TournamentMatchUpdateWithoutTournamentMatchStateInput>
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchStateInput, TournamentMatchCreateWithoutTournamentMatchStateInput>
  }

  export type ImageCreateWithoutTeamInput = {
    path: string
    width: number
    height: number
    caption?: string | null
    Tournament?: TournamentCreateManyWithoutIconInput
    News?: NewsCreateManyWithoutCoverInput
    TournamentMatchReport?: TournamentMatchReportCreateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedCreateWithoutTeamInput = {
    id?: number
    path: string
    width: number
    height: number
    caption?: string | null
    tournamentMatchReportMatchId?: number | null
    tournamentMatchReportReporterId?: number | null
    Tournament?: TournamentUncheckedCreateManyWithoutIconInput
    News?: NewsUncheckedCreateManyWithoutCoverInput
  }

  export type ImageCreateOrConnectWithoutTeamInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageUncheckedCreateWithoutTeamInput, ImageCreateWithoutTeamInput>
  }

  export type TeamMembershipCreateWithoutTeamInput = {
    role: TeamRoleType
    invitedAt: Date | string
    joinedAt?: Date | string
    user: UserCreateOneWithoutMembershipsInput
  }

  export type TeamMembershipUncheckedCreateWithoutTeamInput = {
    role: TeamRoleType
    invitedAt: Date | string
    joinedAt?: Date | string
    userId: number
  }

  export type TeamMembershipCreateOrConnectWithoutteamInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipUncheckedCreateWithoutTeamInput, TeamMembershipCreateWithoutTeamInput>
  }

  export type TournamentCreateWithoutOrganizerInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutOrganizerInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutorganizerInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutOrganizerInput, TournamentCreateWithoutOrganizerInput>
  }

  export type TournamentApplicationCreateWithoutTeamInput = {
    createdAt?: Date | string
    tournament: TournamentCreateOneWithoutApplicantsInput
    players?: UserCreateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedCreateWithoutTeamInput = {
    id?: number
    createdAt?: Date | string
    tournamentId: string
    players?: UserUncheckedCreateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationCreateOrConnectWithoutteamInput = {
    where: TournamentApplicationWhereUniqueInput
    create: XOR<TournamentApplicationUncheckedCreateWithoutTeamInput, TournamentApplicationCreateWithoutTeamInput>
  }

  export type TournamentParticipationCreateWithoutTeamInput = {
    placement?: number | null
    tournament: TournamentCreateOneWithoutParticipantsInput
    players?: UserCreateManyWithoutTournamentParticipationInput
    match?: TournamentMatchCreateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedCreateWithoutTeamInput = {
    placement?: number | null
    matchId?: number | null
    tournamentId: string
    players?: UserUncheckedCreateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationCreateOrConnectWithoutteamInput = {
    where: TournamentParticipationWhereUniqueInput
    create: XOR<TournamentParticipationUncheckedCreateWithoutTeamInput, TournamentParticipationCreateWithoutTeamInput>
  }

  export type TeamInvitationCreateWithoutTeamInput = {
    invitedAt?: Date | string
    user: UserCreateOneWithoutTeamInvitationInput
  }

  export type TeamInvitationUncheckedCreateWithoutTeamInput = {
    invitedAt?: Date | string
    userId: number
  }

  export type TeamInvitationCreateOrConnectWithoutteamInput = {
    where: TeamInvitationWhereUniqueInput
    create: XOR<TeamInvitationUncheckedCreateWithoutTeamInput, TeamInvitationCreateWithoutTeamInput>
  }

  export type ImageUpdateWithoutTeamInput = {
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Tournament?: TournamentUpdateManyWithoutIconInput
    News?: NewsUpdateManyWithoutCoverInput
    TournamentMatchReport?: TournamentMatchReportUpdateOneWithoutAttachmentsInput
  }

  export type ImageUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchReportMatchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentMatchReportReporterId?: NullableIntFieldUpdateOperationsInput | number | null
    Tournament?: TournamentUncheckedUpdateManyWithoutIconInput
    News?: NewsUncheckedUpdateManyWithoutCoverInput
  }

  export type ImageUpsertWithoutTeamInput = {
    update: XOR<ImageUncheckedUpdateWithoutTeamInput, ImageUpdateWithoutTeamInput>
    create: XOR<ImageUncheckedCreateWithoutTeamInput, ImageCreateWithoutTeamInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUncheckedUpdateWithoutTeamInput, TeamMembershipUpdateWithoutTeamInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUncheckedUpdateManyWithoutMembersInput, TeamMembershipUpdateManyMutationInput>
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUncheckedUpdateWithoutTeamInput, TeamMembershipUpdateWithoutTeamInput>
    create: XOR<TeamMembershipUncheckedCreateWithoutTeamInput, TeamMembershipCreateWithoutTeamInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutOrganizerInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUncheckedUpdateWithoutOrganizerInput, TournamentUpdateWithoutOrganizerInput>
  }

  export type TournamentUpdateManyWithWhereWithoutOrganizerInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUncheckedUpdateManyWithoutTournamentInput, TournamentUpdateManyMutationInput>
  }

  export type TournamentScalarWhereInput = {
    AND?: Enumerable<TournamentScalarWhereInput>
    OR?: Enumerable<TournamentScalarWhereInput>
    NOT?: Enumerable<TournamentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    closed?: BoolFilter | boolean
    started?: BoolFilter | boolean
    groupSize?: IntFilter | number
    teamSize?: IntFilter | number
    rounds?: IntFilter | number
    startsAt?: DateTimeFilter | Date | string
    registrationClosesAt?: DateTimeFilter | Date | string
    imageId?: IntNullableFilter | number | null
    teamId?: StringFilter | string
    gameId?: StringFilter | string
  }

  export type TournamentUpsertWithWhereUniqueWithoutOrganizerInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUncheckedUpdateWithoutOrganizerInput, TournamentUpdateWithoutOrganizerInput>
    create: XOR<TournamentUncheckedCreateWithoutOrganizerInput, TournamentCreateWithoutOrganizerInput>
  }

  export type TournamentApplicationUpdateWithWhereUniqueWithoutTeamInput = {
    where: TournamentApplicationWhereUniqueInput
    data: XOR<TournamentApplicationUncheckedUpdateWithoutTeamInput, TournamentApplicationUpdateWithoutTeamInput>
  }

  export type TournamentApplicationUpdateManyWithWhereWithoutTeamInput = {
    where: TournamentApplicationScalarWhereInput
    data: XOR<TournamentApplicationUncheckedUpdateManyWithoutTournamentApplicationInput, TournamentApplicationUpdateManyMutationInput>
  }

  export type TournamentApplicationUpsertWithWhereUniqueWithoutTeamInput = {
    where: TournamentApplicationWhereUniqueInput
    update: XOR<TournamentApplicationUncheckedUpdateWithoutTeamInput, TournamentApplicationUpdateWithoutTeamInput>
    create: XOR<TournamentApplicationUncheckedCreateWithoutTeamInput, TournamentApplicationCreateWithoutTeamInput>
  }

  export type TournamentParticipationUpdateWithWhereUniqueWithoutTeamInput = {
    where: TournamentParticipationWhereUniqueInput
    data: XOR<TournamentParticipationUncheckedUpdateWithoutTeamInput, TournamentParticipationUpdateWithoutTeamInput>
  }

  export type TournamentParticipationUpdateManyWithWhereWithoutTeamInput = {
    where: TournamentParticipationScalarWhereInput
    data: XOR<TournamentParticipationUncheckedUpdateManyWithoutTournamentParticipationInput, TournamentParticipationUpdateManyMutationInput>
  }

  export type TournamentParticipationUpsertWithWhereUniqueWithoutTeamInput = {
    where: TournamentParticipationWhereUniqueInput
    update: XOR<TournamentParticipationUncheckedUpdateWithoutTeamInput, TournamentParticipationUpdateWithoutTeamInput>
    create: XOR<TournamentParticipationUncheckedCreateWithoutTeamInput, TournamentParticipationCreateWithoutTeamInput>
  }

  export type TeamInvitationUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamInvitationWhereUniqueInput
    data: XOR<TeamInvitationUncheckedUpdateWithoutTeamInput, TeamInvitationUpdateWithoutTeamInput>
  }

  export type TeamInvitationUpdateManyWithWhereWithoutTeamInput = {
    where: TeamInvitationScalarWhereInput
    data: XOR<TeamInvitationUncheckedUpdateManyWithoutTeamInvitationInput, TeamInvitationUpdateManyMutationInput>
  }

  export type TeamInvitationUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamInvitationWhereUniqueInput
    update: XOR<TeamInvitationUncheckedUpdateWithoutTeamInput, TeamInvitationUpdateWithoutTeamInput>
    create: XOR<TeamInvitationUncheckedCreateWithoutTeamInput, TeamInvitationCreateWithoutTeamInput>
  }

  export type TournamentCreateWithoutTournamentMatchInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutTournamentMatchInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutTournamentMatchInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutTournamentMatchInput, TournamentCreateWithoutTournamentMatchInput>
  }

  export type RoomCodeCreateWithoutTournamentMatchInput = {
    name: string
    password?: string | null
    game: GameCreateOneWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedCreateWithoutTournamentMatchInput = {
    id?: number
    name: string
    password?: string | null
    gameId: string
  }

  export type RoomCodeCreateOrConnectWithoutTournamentMatchInput = {
    where: RoomCodeWhereUniqueInput
    create: XOR<RoomCodeUncheckedCreateWithoutTournamentMatchInput, RoomCodeCreateWithoutTournamentMatchInput>
  }

  export type TournamentParticipationCreateWithoutMatchInput = {
    placement?: number | null
    team: TeamCreateOneWithoutTournamentParticipationInput
    tournament: TournamentCreateOneWithoutParticipantsInput
    players?: UserCreateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedCreateWithoutMatchInput = {
    placement?: number | null
    tournamentId: string
    teamId: string
    players?: UserUncheckedCreateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutParticipantInput
  }

  export type TournamentParticipationCreateOrConnectWithoutmatchInput = {
    where: TournamentParticipationWhereUniqueInput
    create: XOR<TournamentParticipationUncheckedCreateWithoutMatchInput, TournamentParticipationCreateWithoutMatchInput>
  }

  export type TournamentGridElementCreateWithoutMatchInput = {
    round: number
    group: number
    tournament: TournamentCreateOneWithoutTournamentGridElementInput
    participant: TournamentParticipationCreateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedCreateWithoutMatchInput = {
    id?: number
    round: number
    group: number
    tournamentId: string
    teamId: string
  }

  export type TournamentGridElementCreateOrConnectWithoutmatchInput = {
    where: TournamentGridElementWhereUniqueInput
    create: XOR<TournamentGridElementUncheckedCreateWithoutMatchInput, TournamentGridElementCreateWithoutMatchInput>
  }

  export type TournamentMatchStateCreateWithoutMatchInput = {
    state: InputJsonValue
    createdAt?: Date | string
    accepted: boolean
    acceptedBy?: UserCreateManyWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedCreateWithoutMatchInput = {
    id?: number
    state: InputJsonValue
    createdAt?: Date | string
    accepted: boolean
    acceptedBy?: UserUncheckedCreateManyWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateCreateOrConnectWithoutmatchInput = {
    where: TournamentMatchStateWhereUniqueInput
    create: XOR<TournamentMatchStateUncheckedCreateWithoutMatchInput, TournamentMatchStateCreateWithoutMatchInput>
  }

  export type TournamentMatchReportCreateWithoutMatchInput = {
    type: ReportType
    description: string
    reporter: UserCreateOneWithoutTournamentMatchReportInput
    attachments?: ImageCreateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedCreateWithoutMatchInput = {
    type: ReportType
    description: string
    reporterId: number
    attachments?: ImageUncheckedCreateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportCreateOrConnectWithoutmatchInput = {
    where: TournamentMatchReportWhereUniqueInput
    create: XOR<TournamentMatchReportUncheckedCreateWithoutMatchInput, TournamentMatchReportCreateWithoutMatchInput>
  }

  export type TournamentUpdateWithoutTournamentMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutTournamentMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUpsertWithoutTournamentMatchInput = {
    update: XOR<TournamentUncheckedUpdateWithoutTournamentMatchInput, TournamentUpdateWithoutTournamentMatchInput>
    create: XOR<TournamentUncheckedCreateWithoutTournamentMatchInput, TournamentCreateWithoutTournamentMatchInput>
  }

  export type RoomCodeUpdateWithoutTournamentMatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    game?: GameUpdateOneRequiredWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedUpdateWithoutTournamentMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCodeUpsertWithoutTournamentMatchInput = {
    update: XOR<RoomCodeUncheckedUpdateWithoutTournamentMatchInput, RoomCodeUpdateWithoutTournamentMatchInput>
    create: XOR<RoomCodeUncheckedCreateWithoutTournamentMatchInput, RoomCodeCreateWithoutTournamentMatchInput>
  }

  export type TournamentParticipationUpdateWithWhereUniqueWithoutMatchInput = {
    where: TournamentParticipationWhereUniqueInput
    data: XOR<TournamentParticipationUncheckedUpdateWithoutMatchInput, TournamentParticipationUpdateWithoutMatchInput>
  }

  export type TournamentParticipationUpdateManyWithWhereWithoutMatchInput = {
    where: TournamentParticipationScalarWhereInput
    data: XOR<TournamentParticipationUncheckedUpdateManyWithoutParticipantsInput, TournamentParticipationUpdateManyMutationInput>
  }

  export type TournamentParticipationUpsertWithWhereUniqueWithoutMatchInput = {
    where: TournamentParticipationWhereUniqueInput
    update: XOR<TournamentParticipationUncheckedUpdateWithoutMatchInput, TournamentParticipationUpdateWithoutMatchInput>
    create: XOR<TournamentParticipationUncheckedCreateWithoutMatchInput, TournamentParticipationCreateWithoutMatchInput>
  }

  export type TournamentGridElementUpdateWithWhereUniqueWithoutMatchInput = {
    where: TournamentGridElementWhereUniqueInput
    data: XOR<TournamentGridElementUncheckedUpdateWithoutMatchInput, TournamentGridElementUpdateWithoutMatchInput>
  }

  export type TournamentGridElementUpdateManyWithWhereWithoutMatchInput = {
    where: TournamentGridElementScalarWhereInput
    data: XOR<TournamentGridElementUncheckedUpdateManyWithoutTournamentGridElementInput, TournamentGridElementUpdateManyMutationInput>
  }

  export type TournamentGridElementUpsertWithWhereUniqueWithoutMatchInput = {
    where: TournamentGridElementWhereUniqueInput
    update: XOR<TournamentGridElementUncheckedUpdateWithoutMatchInput, TournamentGridElementUpdateWithoutMatchInput>
    create: XOR<TournamentGridElementUncheckedCreateWithoutMatchInput, TournamentGridElementCreateWithoutMatchInput>
  }

  export type TournamentMatchStateUpdateWithWhereUniqueWithoutMatchInput = {
    where: TournamentMatchStateWhereUniqueInput
    data: XOR<TournamentMatchStateUncheckedUpdateWithoutMatchInput, TournamentMatchStateUpdateWithoutMatchInput>
  }

  export type TournamentMatchStateUpdateManyWithWhereWithoutMatchInput = {
    where: TournamentMatchStateScalarWhereInput
    data: XOR<TournamentMatchStateUncheckedUpdateManyWithoutTournamentMatchStateInput, TournamentMatchStateUpdateManyMutationInput>
  }

  export type TournamentMatchStateScalarWhereInput = {
    AND?: Enumerable<TournamentMatchStateScalarWhereInput>
    OR?: Enumerable<TournamentMatchStateScalarWhereInput>
    NOT?: Enumerable<TournamentMatchStateScalarWhereInput>
    id?: IntFilter | number
    state?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    accepted?: BoolFilter | boolean
    matchId?: IntFilter | number
  }

  export type TournamentMatchStateUpsertWithWhereUniqueWithoutMatchInput = {
    where: TournamentMatchStateWhereUniqueInput
    update: XOR<TournamentMatchStateUncheckedUpdateWithoutMatchInput, TournamentMatchStateUpdateWithoutMatchInput>
    create: XOR<TournamentMatchStateUncheckedCreateWithoutMatchInput, TournamentMatchStateCreateWithoutMatchInput>
  }

  export type TournamentMatchReportUpdateWithWhereUniqueWithoutMatchInput = {
    where: TournamentMatchReportWhereUniqueInput
    data: XOR<TournamentMatchReportUncheckedUpdateWithoutMatchInput, TournamentMatchReportUpdateWithoutMatchInput>
  }

  export type TournamentMatchReportUpdateManyWithWhereWithoutMatchInput = {
    where: TournamentMatchReportScalarWhereInput
    data: XOR<TournamentMatchReportUncheckedUpdateManyWithoutTournamentMatchReportInput, TournamentMatchReportUpdateManyMutationInput>
  }

  export type TournamentMatchReportUpsertWithWhereUniqueWithoutMatchInput = {
    where: TournamentMatchReportWhereUniqueInput
    update: XOR<TournamentMatchReportUncheckedUpdateWithoutMatchInput, TournamentMatchReportUpdateWithoutMatchInput>
    create: XOR<TournamentMatchReportUncheckedCreateWithoutMatchInput, TournamentMatchReportCreateWithoutMatchInput>
  }

  export type UserCreateWithoutTournamentMatchReportInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
  }

  export type UserUncheckedCreateWithoutTournamentMatchReportInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTournamentMatchReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTournamentMatchReportInput, UserCreateWithoutTournamentMatchReportInput>
  }

  export type TournamentMatchCreateWithoutTournamentMatchReportInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournament: TournamentCreateOneWithoutTournamentMatchInput
    roomCode: RoomCodeCreateOneWithoutTournamentMatchInput
    participants?: TournamentParticipationCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateWithoutTournamentMatchReportInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    roomCodeId: number
    tournamentId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchCreateOrConnectWithoutTournamentMatchReportInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchReportInput, TournamentMatchCreateWithoutTournamentMatchReportInput>
  }

  export type ImageCreateWithoutTournamentMatchReportInput = {
    path: string
    width: number
    height: number
    caption?: string | null
    Tournament?: TournamentCreateManyWithoutIconInput
    News?: NewsCreateManyWithoutCoverInput
    Team?: TeamCreateManyWithoutIconInput
  }

  export type ImageUncheckedCreateWithoutTournamentMatchReportInput = {
    id?: number
    path: string
    width: number
    height: number
    caption?: string | null
    Tournament?: TournamentUncheckedCreateManyWithoutIconInput
    News?: NewsUncheckedCreateManyWithoutCoverInput
    Team?: TeamUncheckedCreateManyWithoutIconInput
  }

  export type ImageCreateOrConnectWithoutTournamentMatchReportInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageUncheckedCreateWithoutTournamentMatchReportInput, ImageCreateWithoutTournamentMatchReportInput>
  }

  export type UserUpdateWithoutTournamentMatchReportInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
  }

  export type UserUncheckedUpdateWithoutTournamentMatchReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutTournamentMatchReportInput = {
    update: XOR<UserUncheckedUpdateWithoutTournamentMatchReportInput, UserUpdateWithoutTournamentMatchReportInput>
    create: XOR<UserUncheckedCreateWithoutTournamentMatchReportInput, UserCreateWithoutTournamentMatchReportInput>
  }

  export type TournamentMatchUpdateWithoutTournamentMatchReportInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournament?: TournamentUpdateOneRequiredWithoutTournamentMatchInput
    roomCode?: RoomCodeUpdateOneRequiredWithoutTournamentMatchInput
    participants?: TournamentParticipationUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateWithoutTournamentMatchReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUpsertWithoutTournamentMatchReportInput = {
    update: XOR<TournamentMatchUncheckedUpdateWithoutTournamentMatchReportInput, TournamentMatchUpdateWithoutTournamentMatchReportInput>
    create: XOR<TournamentMatchUncheckedCreateWithoutTournamentMatchReportInput, TournamentMatchCreateWithoutTournamentMatchReportInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutTournamentMatchReportInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUncheckedUpdateWithoutTournamentMatchReportInput, ImageUpdateWithoutTournamentMatchReportInput>
  }

  export type ImageUpdateManyWithWhereWithoutTournamentMatchReportInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUncheckedUpdateManyWithoutAttachmentsInput, ImageUpdateManyMutationInput>
  }

  export type ImageScalarWhereInput = {
    AND?: Enumerable<ImageScalarWhereInput>
    OR?: Enumerable<ImageScalarWhereInput>
    NOT?: Enumerable<ImageScalarWhereInput>
    id?: IntFilter | number
    path?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    caption?: StringNullableFilter | string | null
    tournamentMatchReportMatchId?: IntNullableFilter | number | null
    tournamentMatchReportReporterId?: IntNullableFilter | number | null
  }

  export type ImageUpsertWithWhereUniqueWithoutTournamentMatchReportInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUncheckedUpdateWithoutTournamentMatchReportInput, ImageUpdateWithoutTournamentMatchReportInput>
    create: XOR<ImageUncheckedCreateWithoutTournamentMatchReportInput, ImageCreateWithoutTournamentMatchReportInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    gameAccounts?: GameAccountCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutnotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutNotificationsInput, UserCreateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUncheckedUpdateWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>
    create: XOR<UserUncheckedCreateWithoutNotificationsInput, UserCreateWithoutNotificationsInput>
  }

  export type GameCreateWithoutRoomCodeInput = {
    id: string
    name: string
    Tournament?: TournamentCreateManyWithoutGameInput
    GameAccount?: GameAccountCreateManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutRoomCodeInput = {
    id: string
    name: string
    Tournament?: TournamentUncheckedCreateManyWithoutGameInput
    GameAccount?: GameAccountUncheckedCreateManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutRoomCodeInput = {
    where: GameWhereUniqueInput
    create: XOR<GameUncheckedCreateWithoutRoomCodeInput, GameCreateWithoutRoomCodeInput>
  }

  export type TournamentMatchCreateWithoutRoomCodeInput = {
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournament: TournamentCreateOneWithoutTournamentMatchInput
    participants?: TournamentParticipationCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedCreateWithoutRoomCodeInput = {
    id?: number
    joinUntil?: Date | string | null
    createRoomUntil: Date | string
    state: MatchStateType
    tournamentId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedCreateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutMatchInput
  }

  export type TournamentMatchCreateOrConnectWithoutroomCodeInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchUncheckedCreateWithoutRoomCodeInput, TournamentMatchCreateWithoutRoomCodeInput>
  }

  export type GameUpdateWithoutRoomCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUpdateManyWithoutGameInput
    GameAccount?: GameAccountUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutRoomCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUncheckedUpdateManyWithoutGameInput
    GameAccount?: GameAccountUncheckedUpdateManyWithoutGameInput
  }

  export type GameUpsertWithoutRoomCodeInput = {
    update: XOR<GameUncheckedUpdateWithoutRoomCodeInput, GameUpdateWithoutRoomCodeInput>
    create: XOR<GameUncheckedCreateWithoutRoomCodeInput, GameCreateWithoutRoomCodeInput>
  }

  export type TournamentMatchUpdateWithWhereUniqueWithoutRoomCodeInput = {
    where: TournamentMatchWhereUniqueInput
    data: XOR<TournamentMatchUncheckedUpdateWithoutRoomCodeInput, TournamentMatchUpdateWithoutRoomCodeInput>
  }

  export type TournamentMatchUpdateManyWithWhereWithoutRoomCodeInput = {
    where: TournamentMatchScalarWhereInput
    data: XOR<TournamentMatchUncheckedUpdateManyWithoutTournamentMatchInput, TournamentMatchUpdateManyMutationInput>
  }

  export type TournamentMatchUpsertWithWhereUniqueWithoutRoomCodeInput = {
    where: TournamentMatchWhereUniqueInput
    update: XOR<TournamentMatchUncheckedUpdateWithoutRoomCodeInput, TournamentMatchUpdateWithoutRoomCodeInput>
    create: XOR<TournamentMatchUncheckedCreateWithoutRoomCodeInput, TournamentMatchCreateWithoutRoomCodeInput>
  }

  export type TournamentCreateWithoutIconInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    game: GameCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutIconInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    teamId: string
    gameId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithouticonInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutIconInput, TournamentCreateWithoutIconInput>
  }

  export type NewsCreateWithoutCoverInput = {
    title: string
    content: InputJsonValue
    createdAt?: Date | string
    author: UserCreateOneWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutCoverInput = {
    id?: number
    title: string
    content: InputJsonValue
    createdAt?: Date | string
    userId: number
  }

  export type NewsCreateOrConnectWithoutcoverInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsUncheckedCreateWithoutCoverInput, NewsCreateWithoutCoverInput>
  }

  export type TeamCreateWithoutIconInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    members?: TeamMembershipCreateManyWithoutTeamInput
    Tournament?: TournamentCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationCreateManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutIconInput = {
    id: string
    name: string
    updatedAt?: Date | string
    createdAt?: Date | string
    members?: TeamMembershipUncheckedCreateManyWithoutTeamInput
    Tournament?: TournamentUncheckedCreateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedCreateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedCreateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithouticonInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamUncheckedCreateWithoutIconInput, TeamCreateWithoutIconInput>
  }

  export type TournamentMatchReportCreateWithoutAttachmentsInput = {
    type: ReportType
    description: string
    reporter: UserCreateOneWithoutTournamentMatchReportInput
    match: TournamentMatchCreateOneWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedCreateWithoutAttachmentsInput = {
    type: ReportType
    description: string
    matchId: number
    reporterId: number
  }

  export type TournamentMatchReportCreateOrConnectWithoutattachmentsInput = {
    where: TournamentMatchReportWhereUniqueInput
    create: XOR<TournamentMatchReportUncheckedCreateWithoutAttachmentsInput, TournamentMatchReportCreateWithoutAttachmentsInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutIconInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUncheckedUpdateWithoutIconInput, TournamentUpdateWithoutIconInput>
  }

  export type TournamentUpdateManyWithWhereWithoutIconInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUncheckedUpdateManyWithoutTournamentInput, TournamentUpdateManyMutationInput>
  }

  export type TournamentUpsertWithWhereUniqueWithoutIconInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUncheckedUpdateWithoutIconInput, TournamentUpdateWithoutIconInput>
    create: XOR<TournamentUncheckedCreateWithoutIconInput, TournamentCreateWithoutIconInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutCoverInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUncheckedUpdateWithoutCoverInput, NewsUpdateWithoutCoverInput>
  }

  export type NewsUpdateManyWithWhereWithoutCoverInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUncheckedUpdateManyWithoutNewsInput, NewsUpdateManyMutationInput>
  }

  export type NewsUpsertWithWhereUniqueWithoutCoverInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUncheckedUpdateWithoutCoverInput, NewsUpdateWithoutCoverInput>
    create: XOR<NewsUncheckedCreateWithoutCoverInput, NewsCreateWithoutCoverInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutIconInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUncheckedUpdateWithoutIconInput, TeamUpdateWithoutIconInput>
  }

  export type TeamUpdateManyWithWhereWithoutIconInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUncheckedUpdateManyWithoutTeamInput, TeamUpdateManyMutationInput>
  }

  export type TeamScalarWhereInput = {
    AND?: Enumerable<TeamScalarWhereInput>
    OR?: Enumerable<TeamScalarWhereInput>
    NOT?: Enumerable<TeamScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    imageId?: IntNullableFilter | number | null
  }

  export type TeamUpsertWithWhereUniqueWithoutIconInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUncheckedUpdateWithoutIconInput, TeamUpdateWithoutIconInput>
    create: XOR<TeamUncheckedCreateWithoutIconInput, TeamCreateWithoutIconInput>
  }

  export type TournamentMatchReportUpdateWithoutAttachmentsInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    reporter?: UserUpdateOneRequiredWithoutTournamentMatchReportInput
    match?: TournamentMatchUpdateOneRequiredWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedUpdateWithoutAttachmentsInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    matchId?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentMatchReportUpsertWithoutAttachmentsInput = {
    update: XOR<TournamentMatchReportUncheckedUpdateWithoutAttachmentsInput, TournamentMatchReportUpdateWithoutAttachmentsInput>
    create: XOR<TournamentMatchReportUncheckedCreateWithoutAttachmentsInput, TournamentMatchReportCreateWithoutAttachmentsInput>
  }

  export type TournamentCreateWithoutGameInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    organizer: TeamCreateOneWithoutTournamentInput
    icon?: ImageCreateOneWithoutTournamentInput
    participants?: TournamentParticipationCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationCreateManyWithoutTournamentInput
    rewards?: RewardCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchCreateManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutGameInput = {
    id: string
    name: string
    closed?: boolean
    started?: boolean
    groupSize: number
    teamSize: number
    rounds: number
    startsAt: Date | string
    registrationClosesAt: Date | string
    imageId?: number | null
    teamId: string
    participants?: TournamentParticipationUncheckedCreateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedCreateManyWithoutTournamentInput
    rewards?: RewardUncheckedCreateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedCreateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutgameInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentUncheckedCreateWithoutGameInput, TournamentCreateWithoutGameInput>
  }

  export type RoomCodeCreateWithoutGameInput = {
    name: string
    password?: string | null
    TournamentMatch?: TournamentMatchCreateManyWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedCreateWithoutGameInput = {
    id?: number
    name: string
    password?: string | null
    TournamentMatch?: TournamentMatchUncheckedCreateManyWithoutRoomCodeInput
  }

  export type RoomCodeCreateOrConnectWithoutgameInput = {
    where: RoomCodeWhereUniqueInput
    create: XOR<RoomCodeUncheckedCreateWithoutGameInput, RoomCodeCreateWithoutGameInput>
  }

  export type GameAccountCreateWithoutGameInput = {
    id: string
    user: UserCreateOneWithoutGameAccountsInput
  }

  export type GameAccountUncheckedCreateWithoutGameInput = {
    id: string
    userId: number
  }

  export type GameAccountCreateOrConnectWithoutgameInput = {
    where: GameAccountWhereUniqueInput
    create: XOR<GameAccountUncheckedCreateWithoutGameInput, GameAccountCreateWithoutGameInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutGameInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUncheckedUpdateWithoutGameInput, TournamentUpdateWithoutGameInput>
  }

  export type TournamentUpdateManyWithWhereWithoutGameInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUncheckedUpdateManyWithoutTournamentInput, TournamentUpdateManyMutationInput>
  }

  export type TournamentUpsertWithWhereUniqueWithoutGameInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUncheckedUpdateWithoutGameInput, TournamentUpdateWithoutGameInput>
    create: XOR<TournamentUncheckedCreateWithoutGameInput, TournamentCreateWithoutGameInput>
  }

  export type RoomCodeUpdateWithWhereUniqueWithoutGameInput = {
    where: RoomCodeWhereUniqueInput
    data: XOR<RoomCodeUncheckedUpdateWithoutGameInput, RoomCodeUpdateWithoutGameInput>
  }

  export type RoomCodeUpdateManyWithWhereWithoutGameInput = {
    where: RoomCodeScalarWhereInput
    data: XOR<RoomCodeUncheckedUpdateManyWithoutRoomCodeInput, RoomCodeUpdateManyMutationInput>
  }

  export type RoomCodeScalarWhereInput = {
    AND?: Enumerable<RoomCodeScalarWhereInput>
    OR?: Enumerable<RoomCodeScalarWhereInput>
    NOT?: Enumerable<RoomCodeScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    password?: StringNullableFilter | string | null
    gameId?: StringFilter | string
  }

  export type RoomCodeUpsertWithWhereUniqueWithoutGameInput = {
    where: RoomCodeWhereUniqueInput
    update: XOR<RoomCodeUncheckedUpdateWithoutGameInput, RoomCodeUpdateWithoutGameInput>
    create: XOR<RoomCodeUncheckedCreateWithoutGameInput, RoomCodeCreateWithoutGameInput>
  }

  export type GameAccountUpdateWithWhereUniqueWithoutGameInput = {
    where: GameAccountWhereUniqueInput
    data: XOR<GameAccountUncheckedUpdateWithoutGameInput, GameAccountUpdateWithoutGameInput>
  }

  export type GameAccountUpdateManyWithWhereWithoutGameInput = {
    where: GameAccountScalarWhereInput
    data: XOR<GameAccountUncheckedUpdateManyWithoutGameAccountInput, GameAccountUpdateManyMutationInput>
  }

  export type GameAccountUpsertWithWhereUniqueWithoutGameInput = {
    where: GameAccountWhereUniqueInput
    update: XOR<GameAccountUncheckedUpdateWithoutGameInput, GameAccountUpdateWithoutGameInput>
    create: XOR<GameAccountUncheckedCreateWithoutGameInput, GameAccountCreateWithoutGameInput>
  }

  export type GameCreateWithoutGameAccountInput = {
    id: string
    name: string
    Tournament?: TournamentCreateManyWithoutGameInput
    RoomCode?: RoomCodeCreateManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGameAccountInput = {
    id: string
    name: string
    Tournament?: TournamentUncheckedCreateManyWithoutGameInput
    RoomCode?: RoomCodeUncheckedCreateManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGameAccountInput = {
    where: GameWhereUniqueInput
    create: XOR<GameUncheckedCreateWithoutGameAccountInput, GameCreateWithoutGameAccountInput>
  }

  export type UserCreateWithoutGameAccountsInput = {
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TeamMembershipCreateManyWithoutUserInput
    notifications?: NotificationCreateManyWithoutUserInput
    Admin?: AdminCreateManyWithoutUserInput
    News?: NewsCreateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationCreateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationCreateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationCreateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateCreateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportCreateManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutGameAccountsInput = {
    id?: number
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentApplicationId?: number | null
    tournamentParticipationTeamId?: string | null
    tournamentParticipationTournamentId?: string | null
    tournamentMatchStateId?: number | null
    memberships?: TeamMembershipUncheckedCreateManyWithoutUserInput
    notifications?: NotificationUncheckedCreateManyWithoutUserInput
    Admin?: AdminUncheckedCreateManyWithoutUserInput
    News?: NewsUncheckedCreateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedCreateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedCreateManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutgameAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutGameAccountsInput, UserCreateWithoutGameAccountsInput>
  }

  export type GameUpdateWithoutGameAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUpdateManyWithoutGameInput
    RoomCode?: RoomCodeUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutGameAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUncheckedUpdateManyWithoutGameInput
    RoomCode?: RoomCodeUncheckedUpdateManyWithoutGameInput
  }

  export type GameUpsertWithoutGameAccountInput = {
    update: XOR<GameUncheckedUpdateWithoutGameAccountInput, GameUpdateWithoutGameAccountInput>
    create: XOR<GameUncheckedCreateWithoutGameAccountInput, GameCreateWithoutGameAccountInput>
  }

  export type UserUpdateWithoutGameAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutGameAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUpsertWithoutGameAccountsInput = {
    update: XOR<UserUncheckedUpdateWithoutGameAccountsInput, UserUpdateWithoutGameAccountsInput>
    create: XOR<UserUncheckedCreateWithoutGameAccountsInput, UserCreateWithoutGameAccountsInput>
  }

  export type TeamMembershipUpdateWithoutUserInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersInput
  }

  export type TeamMembershipUncheckedUpdateWithoutUserInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMembershipUncheckedUpdateManyWithoutMembershipsInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | NotificationType | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneRequiredWithoutGameAccountInput
  }

  export type GameAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type GameAccountUncheckedUpdateManyWithoutGameAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutUserInput = {

  }

  export type AdminUncheckedUpdateWithoutUserInput = {

  }

  export type AdminUncheckedUpdateManyWithoutAdminInput = {

  }

  export type NewsUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cover?: ImageUpdateOneWithoutNewsInput
  }

  export type NewsUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NewsUncheckedUpdateManyWithoutNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamInvitationUpdateWithoutUserInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamInvitationInput
  }

  export type TeamInvitationUncheckedUpdateWithoutUserInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInvitationUncheckedUpdateManyWithoutTeamInvitationInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentMatchReportUpdateWithoutReporterInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    match?: TournamentMatchUpdateOneRequiredWithoutTournamentMatchReportInput
    attachments?: ImageUpdateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedUpdateWithoutReporterInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    matchId?: IntFieldUpdateOperationsInput | number
    attachments?: ImageUncheckedUpdateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedUpdateManyWithoutTournamentMatchReportInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    matchId?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentParticipationUpdateWithoutTournamentInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutTournamentParticipationInput
    players?: UserUpdateManyWithoutTournamentParticipationInput
    match?: TournamentMatchUpdateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateWithoutTournamentInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateManyWithoutParticipantsInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentApplicationUpdateWithoutTournamentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTournamentApplicationInput
    players?: UserUpdateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedUpdateManyWithoutApplicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardUpdateWithoutTournamentInput = {
    placement?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type RewardUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    placement?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type RewardUncheckedUpdateManyWithoutRewardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    placement?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentGridElementUpdateWithoutTournamentInput = {
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    participant?: TournamentParticipationUpdateOneRequiredWithoutTournamentGridElementInput
    match?: TournamentMatchUpdateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentGridElementUncheckedUpdateManyWithoutTournamentGridElementInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentMatchUpdateWithoutTournamentInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCode?: RoomCodeUpdateOneRequiredWithoutTournamentMatchInput
    participants?: TournamentParticipationUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateWithoutTournamentInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
    participants?: TournamentParticipationUncheckedUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateManyWithoutTournamentMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    roomCodeId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutTournamentApplicationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutTournamentApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateManyWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutTournamentParticipationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchState?: TournamentMatchStateUpdateOneWithoutAcceptedByInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutTournamentParticipationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentMatchStateId?: NullableIntFieldUpdateOperationsInput | number | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type TournamentGridElementUpdateWithoutParticipantInput = {
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    tournament?: TournamentUpdateOneRequiredWithoutTournamentGridElementInput
    match?: TournamentMatchUpdateOneWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutTournamentMatchStateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TeamMembershipUpdateManyWithoutUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUpdateManyWithoutUserInput
    Admin?: AdminUpdateManyWithoutUserInput
    News?: NewsUpdateManyWithoutAuthorInput
    TournamentApplication?: TournamentApplicationUpdateOneWithoutPlayersInput
    TournamentParticipation?: TournamentParticipationUpdateOneWithoutPlayersInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateWithoutTournamentMatchStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: TeamMembershipUncheckedUpdateManyWithoutUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserInput
    Admin?: AdminUncheckedUpdateManyWithoutUserInput
    News?: NewsUncheckedUpdateManyWithoutAuthorInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutUserInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutReporterInput
  }

  export type UserUncheckedUpdateManyWithoutAcceptedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentParticipationTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentParticipationTournamentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamMembershipUpdateWithoutTeamInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsInput
  }

  export type TeamMembershipUncheckedUpdateWithoutTeamInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMembershipUncheckedUpdateManyWithoutMembersInput = {
    role?: EnumTeamRoleTypeFieldUpdateOperationsInput | TeamRoleType
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutOrganizerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentApplicationUpdateWithoutTeamInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneRequiredWithoutApplicantsInput
    players?: UserUpdateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentApplicationInput
  }

  export type TournamentApplicationUncheckedUpdateManyWithoutTournamentApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentParticipationUpdateWithoutTeamInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsInput
    players?: UserUpdateManyWithoutTournamentParticipationInput
    match?: TournamentMatchUpdateOneWithoutParticipantsInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateWithoutTeamInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateManyWithoutTournamentParticipationInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    matchId?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamInvitationUpdateWithoutTeamInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamInvitationInput
  }

  export type TeamInvitationUncheckedUpdateWithoutTeamInput = {
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentParticipationUpdateWithoutMatchInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutTournamentParticipationInput
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsInput
    players?: UserUpdateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutParticipantInput
  }

  export type TournamentParticipationUncheckedUpdateWithoutMatchInput = {
    placement?: NullableIntFieldUpdateOperationsInput | number | null
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    players?: UserUncheckedUpdateManyWithoutTournamentParticipationInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutParticipantInput
  }

  export type TournamentGridElementUpdateWithoutMatchInput = {
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    tournament?: TournamentUpdateOneRequiredWithoutTournamentGridElementInput
    participant?: TournamentParticipationUpdateOneRequiredWithoutTournamentGridElementInput
  }

  export type TournamentGridElementUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    group?: IntFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentMatchStateUpdateWithoutMatchInput = {
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    acceptedBy?: UserUpdateManyWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    acceptedBy?: UserUncheckedUpdateManyWithoutTournamentMatchStateInput
  }

  export type TournamentMatchStateUncheckedUpdateManyWithoutTournamentMatchStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentMatchReportUpdateWithoutMatchInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    reporter?: UserUpdateOneRequiredWithoutTournamentMatchReportInput
    attachments?: ImageUpdateManyWithoutTournamentMatchReportInput
  }

  export type TournamentMatchReportUncheckedUpdateWithoutMatchInput = {
    type?: EnumReportTypeFieldUpdateOperationsInput | ReportType
    description?: StringFieldUpdateOperationsInput | string
    reporterId?: IntFieldUpdateOperationsInput | number
    attachments?: ImageUncheckedUpdateManyWithoutTournamentMatchReportInput
  }

  export type ImageUpdateWithoutTournamentMatchReportInput = {
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Tournament?: TournamentUpdateManyWithoutIconInput
    News?: NewsUpdateManyWithoutCoverInput
    Team?: TeamUpdateManyWithoutIconInput
  }

  export type ImageUncheckedUpdateWithoutTournamentMatchReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    Tournament?: TournamentUncheckedUpdateManyWithoutIconInput
    News?: NewsUncheckedUpdateManyWithoutCoverInput
    Team?: TeamUncheckedUpdateManyWithoutIconInput
  }

  export type ImageUncheckedUpdateManyWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamentMatchUpdateWithoutRoomCodeInput = {
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournament?: TournamentUpdateOneRequiredWithoutTournamentMatchInput
    participants?: TournamentParticipationUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUpdateManyWithoutMatchInput
  }

  export type TournamentMatchUncheckedUpdateWithoutRoomCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    joinUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createRoomUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumMatchStateTypeFieldUpdateOperationsInput | MatchStateType
    tournamentId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutMatchInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutMatchInput
    TournamentMatchState?: TournamentMatchStateUncheckedUpdateManyWithoutMatchInput
    TournamentMatchReport?: TournamentMatchReportUncheckedUpdateManyWithoutMatchInput
  }

  export type TournamentUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    game?: GameUpdateOneRequiredWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type NewsUpdateWithoutCoverInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutNewsInput
  }

  export type NewsUncheckedUpdateWithoutCoverInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMembershipUpdateManyWithoutTeamInput
    Tournament?: TournamentUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamInput
    Tournament?: TournamentUncheckedUpdateManyWithoutOrganizerInput
    TournamentApplication?: TournamentApplicationUncheckedUpdateManyWithoutTeamInput
    TournamentParticipation?: TournamentParticipationUncheckedUpdateManyWithoutTeamInput
    TeamInvitation?: TeamInvitationUncheckedUpdateManyWithoutTeamInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizer?: TeamUpdateOneRequiredWithoutTournamentInput
    icon?: ImageUpdateOneWithoutTournamentInput
    participants?: TournamentParticipationUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUpdateManyWithoutTournamentInput
    rewards?: RewardUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUpdateManyWithoutTournamentInput
  }

  export type TournamentUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    closed?: BoolFieldUpdateOperationsInput | boolean
    started?: BoolFieldUpdateOperationsInput | boolean
    groupSize?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    rounds?: IntFieldUpdateOperationsInput | number
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationClosesAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: StringFieldUpdateOperationsInput | string
    participants?: TournamentParticipationUncheckedUpdateManyWithoutTournamentInput
    applicants?: TournamentApplicationUncheckedUpdateManyWithoutTournamentInput
    rewards?: RewardUncheckedUpdateManyWithoutTournamentInput
    TournamentGridElement?: TournamentGridElementUncheckedUpdateManyWithoutTournamentInput
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutTournamentInput
  }

  export type RoomCodeUpdateWithoutGameInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    TournamentMatch?: TournamentMatchUpdateManyWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedUpdateWithoutGameInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    TournamentMatch?: TournamentMatchUncheckedUpdateManyWithoutRoomCodeInput
  }

  export type RoomCodeUncheckedUpdateManyWithoutRoomCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameAccountUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGameAccountsInput
  }

  export type GameAccountUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GameAccountUncheckedUpdateManyWithoutGameAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}